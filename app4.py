# -*- coding: utf-8 -*-
"""app4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGlpDJrQS46Az5I9p71qRZUSioljahMx
"""

import streamlit as st
st.set_page_config(layout="wide")

st.write("✅ App iniciada correctamente – Tablero App4")

import seaborn as sns
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import io
from datetime import datetime
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import MiniBatchKMeans
from sklearn.metrics import silhouette_score
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.drawing.image import Image as XLImage
import zipfile, os

def cargar_csv_desde_zip(empresa="adargar", region="tacna"):
    """
    Carga un archivo CSV de ventas desde un archivo ZIP.
    """
    # Construir el nombre del archivo ZIP y del CSV interno
    archivo_zip = f"sales_{empresa.lower()}_{region.lower()}_2024_2025.zip"
    nombre_csv = f"sales_{empresa.lower()}_{region.lower()}_2024_2025.csv"

    # Verificar si el archivo ZIP existe en el directorio de la app
    if not os.path.exists(archivo_zip):
        st.error(f"❌ No se encontró el archivo: {archivo_zip}")
        return None

    try:
        with zipfile.ZipFile(archivo_zip) as zf:
            with zf.open(nombre_csv) as file:
                df = pd.read_csv(file, dtype={"COD_PRO": str})
        return df
    except Exception as e:
        st.error(f"⚠️ Error al leer el archivo {nombre_csv} dentro del ZIP: {e}")
        return None

# 📦 1. Cargar datasets de segmentación por región
df_tac = pd.read_csv("clientes_segmentados_tacna.csv", encoding="utf-8")
df_moq = pd.read_csv("clientes_segmentados_moquegua.csv", encoding="utf-8")

# 🧼 2. Corregir formato y encoding
# Los nuevos archivos tienen encabezados y codificación correctos.
df_tac.rename(columns=lambda col: col.strip(), inplace=True)
df_moq.rename(columns=lambda col: col.strip(), inplace=True)

# 🔁 3. Unificar ambos en un solo DataFrame para entrenamiento
rfm = pd.concat([df_tac, df_moq], ignore_index=True)
rfm.columns = rfm.columns.str.strip()

# 🧠 4. Entrenamiento predictivo
# Validar columna de clúster. Ahora el clúster objetivo es 'Cluster_Label'.
if "Cluster_Label" in rfm.columns:
    y = rfm["Cluster_Label"]
else:
    raise ValueError("⚠️ No se encontró la columna 'Cluster_Label' para el entrenamiento.")

X = rfm[["Recency", "Frequency", "Monetary"]]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

modelo = RandomForestClassifier(n_estimators=100, random_state=42)
modelo.fit(X_train, y_train)

# 📈 5. Aplicar predicción y probabilidades
rfm["Cluster_Predicho"] = modelo.predict(X)
rfm["Probabilidades"] = modelo.predict_proba(X).tolist()

# 🧭 6. Mapear índices de clústeres
# Crear un mapeo de etiquetas a índices para las probabilidades
etiquetas_modelo = list(modelo.classes_)
idx_oro = etiquetas_modelo.index("Oro")
idx_bronce = etiquetas_modelo.index("Bronce")
idx_cobre = etiquetas_modelo.index("Cobre")
idx_plata = etiquetas_modelo.index("Plata")
idx_diamante = etiquetas_modelo.index("Diamante")

# 🧮 7. Calcular probabilidades predictivas
rfm["Probabilidad_Ascenso_Oro"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_oro], 4))
rfm["Probabilidad_Ascenso_Plata"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_plata], 4))
rfm["Probabilidad_Descenso_Cobre"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_cobre], 4))
rfm["Probabilidad_Descenso_Bronce"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_bronce], 4))

# 💾 8. Actualizar df_tac y df_moq ya enriquecidos con predicción
df_tac = rfm[rfm["Region"] == "Tacna"].copy()
df_moq = rfm[rfm["Region"] == "Moquegua"].copy()

# 💾 9. Inicializar st.session_state con los dataframes enriquecidos
if "df_to_display" not in st.session_state:
    st.session_state.df_tac = df_tac
    st.session_state.df_moq = df_moq
    st.session_state.df_to_display = df_tac # Por defecto, mostrar Tacna

# ✅ Validaciones de columnas críticas por región
assert "Cluster_Label" in df_tac.columns and df_tac["Cluster_Label"].notna().all(), "❌ Falta columna o hay valores nulos en df_tac['Cluster_Label']"
assert "Cluster_Label" in df_moq.columns and df_moq["Cluster_Label"].notna().all(), "❌ Falta columna o hay valores nulos en df_moq['Cluster_Label']"

for col in ["Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce"]:
    assert col in df_tac.columns and df_tac[col].notna().all(), f"❌ Falta columna o hay valores nulos en df_tac['{col}']"
    assert col in df_moq.columns and df_moq[col].notna().all(), f"❌ Falta columna o hay valores nulos en df_moq['{col}']"

# 🎨 Diccionario de colores y estrategias para 5 clústeres
colores_k5 = {
    "Diamante": "#00FFFF",
    "Oro": "#FFD700",
    "Plata": "#C0C0C0",
    "Cobre": "#B87333",
    "Bronce": "#CD7F32"
}

estrategias = {
    "Diamante": "💎 Crecimiento y retención: programas de lealtad exclusivos y anticipación de necesidades.",
    "Oro": "📈 Fidelizar y potenciar: promociones exclusivas y membresías premium.",
    "Plata": "🤝 Incentivar y escalar: motivar recurrencia con descuentos personalizados.",
    "Cobre": "💡 Oportunidad de venta: enfoque en productos complementarios y reactivación con ofertas de valor.",
    "Bronce": "🧲 Reactivar: campañas de recuperación o win-back por inactividad."
}

# 🔷 Título central del dashboard
st.markdown("""
    <h1 style='text-align: center; color: #003366; margin-bottom: 0.2em;'>
        Dashboard Predictivo – Adargar-Tacna SRL
    </h1>
    <h4 style='text-align: center; color: gray; font-weight: normal; margin-top: 0;'>
        Análisis y estrategias por segmento RFM
    </h4>
    <hr style='margin-top: 0.5em; margin-bottom: 1.5em;'>
""", unsafe_allow_html=True)

# 📋 Definición de las 17 pestañas del dashboard
tabs = st.tabs([
    "💠 Dispersión RFM",
    "📊 Estadísticas RFM por Clúster",
    "📦 Distribución de Clientes por Segmento",
    "💼 Recomendaciones por Segmento",
    "📊 Boxplots RFM",
    "🏅 Clientes de Alto Valor",
    "🛎️ Clientes con Recencia Crítica por Segmento",
    "🔮 Predicción de Evolución de Clientes",
    "📊 Histogramas RFM por Clúster",
    "🎻 Densidad y Dispersión por Clúster",
    "🌌 Scatter 3D RFM por Clúster",
    "🧬 Mapa de Correlación (RFM & Predicción)",
    "🧭 Radar de Perfiles RFM por Clúster",
    "⚖️ Comparativa Regional Tacna vs Moquegua",
    "📆 Evolución Temporal Estratégica",
    "📌 Recomendaciones Estratégicas",
    "📘 Guía de Usuario"
])
(tab1, tab2, tab3, tab4, tab5, tab6, tab7, tab8, tab9, tab10,
 tab11, tab12, tab13, tab14, tab15, tab16, tab17) = tabs

# 🧠 Función robusta para ordenar segmentos con validación
def ordenar_segmentos_seguro(df_agrupado, orden=None, nombre_var="Cluster_Label"):
    if orden is None:
        orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    if not isinstance(df_agrupado.index, pd.Index):
        st.warning(f"⚠️ El objeto proporcionado no tiene un índice válido.")
        return df_agrupado

    if not set(orden).issubset(df_agrupado.index):
        st.warning(f"⚠️ Algunos segmentos de {orden} no están presentes en el índice actual.")
        # Intentar reordenar con los segmentos que sí existen
        presentes = [s for s in orden if s in df_agrupado.index]
        return df_agrupado.reindex(presentes)

    return df_agrupado.reindex(orden)

# 🧭 Layout general y encabezado inicial
# 🎛️ Sidebar profesional
with st.sidebar:
    # Asegúrate de tener el logo de Adargar en la carpeta de tu repositorio
    st.image("logo_adargar.jpg", width=190)

    st.markdown("### 📊 App4 – Evolución Inteligente de Clientes para Adargar-Tacna")
    st.caption("Solución diseñada por Ing. Marco Valcárcel")

    # Selección de región
    region = st.selectbox(
        "📍 Selecciona región",
        ["Tacna", "Moquegua"],
        key="region_selector",
    )

    # --- CORRECCIÓN CRÍTICA ---
    # Actualizamos el DataFrame en st.session_state cada vez que la región cambie
    if region == "Tacna":
        st.session_state.df_to_display = st.session_state.df_tac
    else: # Moquegua
        st.session_state.df_to_display = st.session_state.df_moq

    st.markdown("---")
    st.markdown(f"### 📌 Clientes por Nivel ({region})")

    try:
        # Ahora, todas las métricas usan el DataFrame filtrado de st.session_state
        total = st.session_state.df_to_display["C_CLIEN"].nunique()
        diamante = st.session_state.df_to_display.query("Cluster_Label == 'Diamante'")["C_CLIEN"].nunique()
        oro = st.session_state.df_to_display.query("Cluster_Label == 'Oro'")["C_CLIEN"].nunique()
        plata = st.session_state.df_to_display.query("Cluster_Label == 'Plata'")["C_CLIEN"].nunique()
        cobre = st.session_state.df_to_display.query("Cluster_Label == 'Cobre'")["C_CLIEN"].nunique()
        bronce = st.session_state.df_to_display.query("Cluster_Label == 'Bronce'")["C_CLIEN"].nunique()

        st.metric("🟡 Total únicos", total)
        st.metric("💎 Diamante", diamante)
        st.metric("🟢 Oro", oro)
        st.metric("🔵 Plata", plata)
        st.metric("💡 Cobre", cobre)
        st.metric("🟤 Bronce", bronce)
    except Exception as e:
        st.info(f"ℹ️ Las métricas de clientes se activarán una vez se cargue el dataframe. Error: {e}")

def interpretar_histograma_rfm(df, variable, region=""):
    """
    Genera una interpretación de las métricas RFM (Recencia, Frecuencia, Monetario)
    para cada segmento de clientes, basándose en el análisis de histogramas.
    Esta función ahora utiliza st.session_state para garantizar que la
    interpretación se basa en los datos de la región seleccionada.

    Args:
        df (pd.DataFrame): Este parámetro se mantiene por compatibilidad, pero
                          la función ahora carga el DataFrame desde st.session_state.
        variable (str): La variable RFM a analizar ('Recency', 'Frequency' o 'Monetary').
        region (str): La región a la que corresponden los datos.
    """

    st.markdown(f"### 📌 Interpretación de la variable **{variable}** en {region}")

    # Usamos el DataFrame del estado de la sesión para que los datos sean dinámicos
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df
        st.warning("⚠️ No se encontró 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    # Verificar si la columna existe en el DataFrame para evitar errores
    if variable not in df_a_usar.columns:
        st.error(f"❌ La columna '{variable}' no se encuentra en el DataFrame de la región.")
        return

    try:
        # 📊 Agrupar el DataFrame por segmento y seleccionar la variable de interés
        grupos = df_a_usar.groupby("Cluster_Label")[variable]

        # 📈 Iterar sobre cada segmento y calcular métricas estadísticas clave
        for segmento, valores in grupos:
            desc = valores.describe()
            media = desc["mean"]
            mediana = desc["50%"]
            std = desc["std"]
            asimetría = valores.skew()

            # Evaluar la dispersión (variabilidad) de los datos
            dispersión = "alta" if std > valores.mean() * 0.5 else "moderada" if std > 0 else "baja"

            # ✍️ Mostrar las métricas calculadas
            st.markdown(f"#### 🎯 Segmento **{segmento}**")
            st.markdown(
                f"- Media: **{media:.2f}**, Mediana: **{mediana:.2f}**"
                f"\n- Desviación estándar: **{std:.2f}** ({dispersión})"
                f"\n- Asimetría: **{asimetría:.2f}** {'🔺 positiva' if asimetría > 0 else '🔻 negativa' if asimetría < 0 else '⚖️ simétrica'}"
            )

            # 🧠 Generar una interpretación basada en el valor de asimetría y dispersión
            if asimetría > 1:
                st.info("Distribución sesgada a la derecha: mayoría de valores bajos con algunos muy altos.")
            elif asimetría < -1:
                st.info("Distribución sesgada a la izquierda: mayoría de clientes con valores altos en esta métrica.")
            elif dispersión == "alta":
                st.info("Existe alta variabilidad entre los clientes de este segmento.")
            else:
                st.info("Distribución relativamente equilibrada.")
    except Exception as e:
        st.error(f"Ocurrió un error al generar la interpretación: {e}")

    st.caption("💡 Esta lectura puede ayudarte a detectar segmentos con outliers o con comportamiento atípico para intervenciones personalizadas.")

def interpretar_histograma_probabilidad(df, columna_probabilidad, region=""):
    """
    Función de interpretación automática para cualquier columna de probabilidad.
    Ahora utiliza st.session_state para garantizar que la interpretación
    se basa en los datos de la región seleccionada en el sidebar.

    Args:
        df (pd.DataFrame): Este parámetro se mantiene por compatibilidad, pero
                          la función ahora carga el DataFrame desde st.session_state.
        columna_probabilidad (str): El nombre de la columna que contiene las probabilidades.
        region (str): La región a la que corresponden los datos.
    """
    st.markdown("---")

    # Usamos el DataFrame del estado de la sesión para que los datos sean dinámicos
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df
        st.warning("⚠️ No se encontró 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    # Verificar si la columna existe en el DataFrame para evitar errores
    if columna_probabilidad not in df_a_usar.columns:
        st.error(f"❌ La columna '{columna_probabilidad}' no se encuentra en el DataFrame de la región.")
        return

    # 📊 Calcular las métricas estadísticas clave de la columna de probabilidad
    max_prob = df_a_usar[columna_probabilidad].max()
    min_prob = df_a_usar[columna_probabilidad].min()
    media = df_a_usar[columna_probabilidad].mean()
    mediana = df_a_usar[columna_probabilidad].median()

    # ✂️ Extraer el tipo de probabilidad (Ascenso/Descenso) y el segmento de destino
    partes = columna_probabilidad.replace("Probabilidad_", "").split("_")
    tipo_prob = partes[0]
    segmento_destino = partes[-1]

    st.markdown(f"🧠 **Interpretación Automática del Histograma: {tipo_prob} a {segmento_destino}**")

    # 🎯 Análisis de casos extremos (probabilidad cercana a 1 o 0)
    if np.isclose(max_prob, 1.0):
        st.markdown(f"- 🎯 Hay un grupo de clientes con {tipo_prob} asegurado al segmento **{segmento_destino}** (probabilidad ~1.0). Son casos prioritarios para intervención inmediata.")
    if np.isclose(min_prob, 0.0):
        st.markdown("- ⚠️ Se detecta una base con probabilidad cero. Revisar si son clientes inactivos o sin historial suficiente.")

    # 📈 Interpretación basada en las métricas de tendencia central
    st.markdown(f"- 📊 En **{region}**, la media de {tipo_prob} es **{media:.2f}** y la mediana es **{mediana:.2f}**."
                f"Esto sugiere{' potencial activo' if media > 0.5 else ' baja disposición al cambio'} al segmento **{segmento_destino}**.")

    st.caption("💡 Esta lectura puede ayudarte a detectar oportunidades de crecimiento o de riesgo en tu cartera.")

def interpretar_violin_rfm(df, variable, region):
    """
    Genera una interpretación automática y robusta para un gráfico de violín.
    Esta función ahora utiliza st.session_state.df_to_display para asegurar
    que la interpretación siempre se base en el DataFrame seleccionado.

    Args:
        df (pd.DataFrame): Se mantiene el parámetro por compatibilidad, pero
                          el DataFrame real se carga desde el estado de la sesión.
        variable (str): La variable (columna) a interpretar.
        region (str): El nombre de la región.
    """
    st.markdown("🧠 **Interpretación Automática del Violín Plot:**")

    # Usamos el DataFrame del estado de la sesión para que los datos sean dinámicos
    # y se actualicen con los cambios de la barra lateral.
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df
        st.warning("⚠️ No se encontró 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    try:
        # Agrupamos y forzamos el orden lógico
        resumen_bruto = df_a_usar.groupby("Cluster_Label")[variable].describe()[["mean", "std"]].round(2)
        # La función 'ordenar_segmentos_seguro' debe estar definida en tu código principal
        # o puedes reemplazarla con una lógica de ordenación si es necesario.
        resumen = ordenar_segmentos_seguro(resumen_bruto)

        if resumen is not None and not resumen.empty:
            mayor_media = resumen["mean"].idxmax()
            menor_media = resumen["mean"].idxmin()

            st.markdown(f"- 📍 En **{region}**, el clúster con mayor valor promedio de `{variable}` es **{mayor_media}**.")
            st.markdown(f"- 🧭 El clúster con menor valor promedio es **{menor_media}**.")

            if resumen["std"].max() > 0.5 * resumen["mean"].max():
                st.markdown("- ⚠️ Hay alta dispersión en algunos clústeres, indicando comportamiento variado o presencia de outliers.")
            else:
                st.markdown("- ✅ Las distribuciones son consistentes, lo que sugiere que los clústeres están bien definidos en esta variable.")
        else:
            st.warning("⚠️ No se pudo calcular resumen estadístico confiable para esta métrica.")

    except Exception as e:
        st.error(f"Ocurrió un error al generar la interpretación: {e}")

def ordenar_segmentos_seguro(df_resumen):
    """
    Función auxiliar para ordenar los segmentos de un DataFrame de resumen.
    Se incluye para hacer el código autocontenido.
    """
    try:
        # Intenta ordenar el índice si es numérico
        df_resumen.index = df_resumen.index.astype(int)
        return df_resumen.sort_index()
    except (ValueError, TypeError):
        # Si no es numérico, simplemente ordena alfabéticamente
        return df_resumen.sort_index()

def interpretar_kde_rfm(df, variable, region):
    """
    Genera una interpretación del gráfico KDE para las métricas RFM.
    Esta función ahora utiliza st.session_state para garantizar que la
    interpretación se basa en los datos de la región seleccionada.

    Args:
        df (pd.DataFrame): Este parámetro se mantiene por compatibilidad, pero
                          la función ahora carga el DataFrame desde st.session_state.
        variable (str): La variable RFM a analizar ('Recency', 'Frequency' o 'Monetary').
        region (str): La región a la que corresponden los datos.
    """
    st.markdown("---")
    st.markdown("🧠 **Interpretación Automática del KDE Plot:**")

    # Usamos el DataFrame del estado de la sesión para que los datos sean dinámicos
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df
        st.warning("⚠️ No se encontró 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    # Verificar que las columnas necesarias existen en el DataFrame
    if "Cluster_Label" not in df_a_usar.columns or variable not in df_a_usar.columns:
        st.error(f"❌ Las columnas 'Cluster_Label' o '{variable}' no se encuentran en el DataFrame de la región.")
        return

    try:
        resumen_bruto = df_a_usar.groupby("Cluster_Label")[variable].describe()[["mean", "std"]].round(2)
        resumen = ordenar_segmentos_seguro(resumen_bruto)

        if resumen is not None and not resumen.empty:
            rangos = resumen["mean"].max() - resumen["mean"].min()
            st.markdown(f"- En **{region}**, los valores medios de `{variable}` por clúster varían en un rango de **{rangos:.2f}**.")

            if rangos < 0.1 * resumen["mean"].mean():
                st.markdown("- ⚠️ Las curvas KDE se solapan bastante. Puede haber clústeres con comportamiento poco diferenciado en esta variable.")
            else:
                st.markdown("- ✅ Hay buena separación entre clústeres en términos de densidad. La segmentación parece sólida.")

            dispersion = resumen["std"].mean()
            if dispersion > 0.3 * resumen["mean"].mean():
                st.markdown(f"- La desviación estándar promedio es **{dispersion:.2f}**, lo que indica **alta** dispersión interna en los grupos.")
            else:
                st.markdown(f"- La desviación estándar promedio es **{dispersion:.2f}**, lo que indica **baja** dispersión interna en los grupos.")
        else:
            st.warning("⚠️ No hay suficientes datos agrupados para interpretar el KDE.")
    except Exception as e:
        st.error(f"❌ Error al interpretar el gráfico KDE: {e}")

def ordenar_segmentos_seguro(df_resumen):
    """
    Función auxiliar para ordenar los segmentos de un DataFrame de resumen.
    Se incluye para hacer el código autocontenido.
    """
    try:
        # Intenta ordenar el índice si es numérico
        df_resumen.index = df_resumen.index.astype(int)
        return df_resumen.sort_index()
    except (ValueError, TypeError):
        # Si no es numérico, simplemente ordena alfabéticamente
        return df_resumen.sort_index()

def interpretar_radar_rfm(df_region, region):
    """
    Genera una interpretación del perfil RFM por clúster, basándose en los valores
    promedio de Recency, Frequency y Monetary. Esta función ahora utiliza
    st.session_state para garantizar que la interpretación se basa en los
    datos de la región seleccionada.

    Args:
        df_region (pd.DataFrame): Este parámetro se mantiene por compatibilidad, pero
                                  la función ahora carga el DataFrame desde st.session_state.
        region (str): La región a la que corresponden los datos.
    """
    st.markdown("---")
    st.markdown("🧠 **Interpretación del Perfil RFM por Clúster:**")

    # Usamos el DataFrame del estado de la sesión para que los datos sean dinámicos
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df_region
        st.warning("⚠️ No se encontró 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    # Verificar que las columnas necesarias existen en el DataFrame
    required_cols = ["Cluster_Label", "Recency", "Frequency", "Monetary"]
    if not all(col in df_a_usar.columns for col in required_cols):
        st.error(f"❌ Faltan una o más columnas requeridas en el DataFrame de la región: {required_cols}.")
        return

    try:
        mean_raw = df_a_usar.groupby("Cluster_Label")[["Recency", "Frequency", "Monetary"]].mean().round(1)
        mean_profiles = ordenar_segmentos_seguro(mean_raw)

        if mean_profiles is not None and not mean_profiles.empty:
            # Identificamos clúster con máximos por métrica
            estrella = mean_profiles["Frequency"].idxmax()
            # Para Recency, un valor bajo es mejor, pero el radar plot muestra lo opuesto.
            # La interpretación debe ser coherente con el gráfico.
            rezagado = mean_profiles["Recency"].idxmax()
            ticket_alto = mean_profiles["Monetary"].idxmax()

            st.markdown(f"- ⭐ El segmento **{estrella}** destaca por su **alta frecuencia de compra**.")
            st.markdown(f"- ⌛ El segmento **{rezagado}** muestra el **mayor tiempo desde la última compra (Recency)**, lo que indica clientes menos recientes.")
            st.markdown(f"- 💰 El segmento **{ticket_alto}** tiene el **mayor gasto promedio por cliente**.")

            # 🧠 Análisis cruzado: ¿hay un clúster que lidera en más de una métrica?
            contador_dominancia = {}
            for cluster in [estrella, rezagado, ticket_alto]:
                contador_dominancia[cluster] = contador_dominancia.get(cluster, 0) + 1

            dominante = [k for k, v in contador_dominancia.items() if v >= 2]

            if dominante:
                for clus in dominante:
                    st.success(f"🥇 El segmento **{clus}** lidera en **{contador_dominancia[clus]} métricas** clave. Es un segmento estratégico con alto potencial.")
            else:
                st.info("🔍 No hay un único clúster dominante en más de una métrica. La segmentación presenta especializaciones distintas.")

        else:
            st.warning("⚠️ No se pudo generar interpretación: el resumen promedio está vacío o mal estructurado.")

    except Exception as e:
        st.error(f"❌ Error al interpretar el perfil RFM: {e}")

def ordenar_segmentos_seguro(df_resumen):
    """
    Función auxiliar para ordenar los segmentos de un DataFrame de resumen.
    Se incluye para hacer el código autocontenido.
    """
    try:
        # Intenta ordenar el índice si es numérico
        df_resumen.index = df_resumen.index.astype(int)
        return df_resumen.sort_index()
    except (ValueError, TypeError):
        # Si no es numérico, simplemente ordena alfabéticamente
        return df_resumen.sort_index()

def interpretar_comparativa_regional(df):
    """
    Genera una interpretación del gráfico de barras de comparación regional,
    identificando la región líder en diferentes métricas (cantidad de clientes,
    valor total y ticket promedio).

    Args:
        df (pd.DataFrame): El DataFrame que contiene los datos de las regiones
                          y los clústeres.
    """
    st.markdown("---")
    st.markdown("🧠 **Interpretación Comparativa Regional:**")

    # Verificar que las columnas necesarias existen en el DataFrame
    required_cols = ["Región", "Cantidad", "Monto_Total", "Ticket_Promedio", "Cluster_Label"]
    if not all(col in df.columns for col in required_cols):
        st.error(f"❌ Faltan una o más columnas requeridas en el DataFrame: {required_cols}.")
        return

    try:
        resumen = df.groupby("Región").agg(
            Cantidad=("Cantidad", "sum"),
            Monto_Total=("Monto_Total", "sum"),
            Ticket_Promedio=("Ticket_Promedio", "mean")
        ).round(2)

        if resumen.empty:
            st.warning("⚠️ El DataFrame de resumen regional está vacío. No se puede generar la interpretación.")
            return

        region_lider_volumen = resumen["Cantidad"].idxmax()
        region_lider_valor = resumen["Monto_Total"].idxmax()
        region_lider_ticket = resumen["Ticket_Promedio"].idxmax()

        st.markdown(f"- 📦 La región **{region_lider_volumen}** tiene la mayor cantidad total de clientes.")
        st.markdown(f"- 💰 La región **{region_lider_valor}** lidera en valor monetario acumulado.")
        st.markdown(f"- 🎟️ La región **{region_lider_ticket}** posee el ticket promedio más alto.")

        # 🧠 Análisis cruzado: ¿hay una región que lidera en más de una métrica?
        contador_dominancia = {}
        for region in [region_lider_volumen, region_lider_valor, region_lider_ticket]:
            contador_dominancia[region] = contador_dominancia.get(region, 0) + 1

        dominante = [k for k, v in contador_dominancia.items() if v >= 2]

        if dominante:
            for reg in dominante:
                st.success(f"🏆 **{reg}** es la región más estratégica, liderando en **{contador_dominancia[reg]} métricas** clave.")
        else:
            st.info("🔍 No hay una única región dominante en más de una métrica. Cada región tiene una especialización distinta.")

        # Detección de disparidad en clúster Oro
        df_oro = df[df["Cluster_Label"] == "Oro"]
        if not df_oro.empty:
            top_oro = df_oro.groupby("Región")["Cantidad"].sum().idxmax()
            st.markdown(f"- 🥇 En el segmento Oro, la mayoría de clientes proviene de **{top_oro}**, lo que sugiere un enfoque estratégico en esa región.")
        else:
            st.warning("⚠️ No se encontraron datos para el segmento 'Oro'.")

    except Exception as e:
        st.error(f"❌ Error al interpretar la comparativa regional: {e}")

def ordenar_segmentos_seguro(df_resumen):
    """
    Función auxiliar para ordenar los segmentos de un DataFrame de resumen.
    Se incluye para hacer el código autocontenido.
    """
    try:
        # Intenta ordenar el índice si es numérico
        df_resumen.index = df_resumen.index.astype(int)
        return df_resumen.sort_index()
    except (ValueError, TypeError):
        # Si no es numérico, simplemente ordena alfabéticamente
        return df_resumen.sort_index()

def interpretar_predicciones(region, df_region):
    """
    Genera una interpretación automática y detallada del perfil predictivo
    de la región seleccionada, analizando las probabilidades de ascenso a Oro
    y de descenso a Bronce.

    Args:
        region (str): El nombre de la región seleccionada.
        df_region (pd.DataFrame): El DataFrame filtrado para la región.
    """
    st.markdown("---")
    st.markdown("🧠 **Interpretación automática del perfil predictivo:**")

    # Verificar si el DataFrame está vacío o faltan columnas esenciales
    required_cols = ["Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce", "Cluster_Label"]
    if df_region.empty or not all(col in df_region.columns for col in required_cols):
        st.warning("⚠️ No hay datos disponibles para la interpretación de predicciones en esta región o faltan columnas.")
        return

    try:
        media_ascenso = df_region["Probabilidad_Ascenso_Oro"].mean()
        media_bronce = df_region["Probabilidad_Descenso_Bronce"].mean()

        # Interpretación general de la probabilidad de ascenso
        st.markdown("---")
        st.subheader("Análisis General de la Región")
        if media_ascenso > 0.6:
            st.markdown(f"- 🎯 En **{region}**, existe **alto potencial de ascenso a Oro** (probabilidad promedio: {media_ascenso:.2f}). Se recomienda una campaña de engagement para este grupo.")
        elif media_ascenso < 0.4:
            st.markdown(f"- ⚠️ La probabilidad promedio de ascenso a Oro es baja ({media_ascenso:.2f}). Esto requiere campañas proactivas de activación o estrategias de retención diferenciadas.")
        else:
            st.markdown(f"- 🟡 El ascenso a Oro promedio es intermedio ({media_ascenso:.2f}). Hay potencial para desarrollar y convertir a un segmento importante de clientes.")

        # Interpretación general del riesgo de descenso
        st.markdown("---")
        st.subheader("Análisis de Riesgo de Deserción")
        if media_bronce > 0.6:
            st.markdown(f"- 🔻 También hay **alto riesgo de caída a Bronce** (probabilidad promedio: {media_bronce:.2f}), lo que requiere una estrategia de contención y re-enganche inmediata.")
        elif media_bronce < 0.3:
            st.markdown(f"- ✅ El riesgo de caída a Bronce está controlado (probabilidad promedio: {media_bronce:.2f}). La mayoría de los clientes se mantiene en clústeres de valor.")
        else:
            st.markdown(f"- 🧭 Se detectó un riesgo moderado de caída a Bronce (probabilidad promedio: {media_bronce:.2f}). Se debe monitorear a estos clientes para evitar su salida del segmento.")

        # Análisis por clúster de clientes
        st.markdown("---")
        st.subheader("Oportunidades y Riesgos por Clúster")
        ascenso_por_cluster = ordenar_segmentos_seguro(
            df_region.groupby("Cluster_Label")["Probabilidad_Ascenso_Oro"].mean().round(2)
        )
        bronce_por_cluster = ordenar_segmentos_seguro(
            df_region.groupby("Cluster_Label")["Probabilidad_Descenso_Bronce"].mean().round(2)
        )

        if not ascenso_por_cluster.empty:
            mejor_cluster = ascenso_por_cluster.idxmax()
            st.markdown(f"- 🟩 El clúster **{mejor_cluster}** tiene la mayor probabilidad promedio de **ascenso a Oro** ({ascenso_por_cluster[mejor_cluster]:.2f}). Se recomienda priorizar a estos clientes en las campañas de marketing.")

        if not bronce_por_cluster.empty:
            peor_cluster = bronce_por_cluster.idxmax()
            st.markdown(f"- 🟥 El clúster **{peor_cluster}** concentra el mayor riesgo de **caída a Bronce** ({bronce_por_cluster[peor_cluster]:.2f}). Es crucial implementar acciones de retención para este segmento.")

        # Recomendación táctica cruzada
        if not ascenso_por_cluster.empty and not bronce_por_cluster.empty:
            asc_val = ascenso_por_cluster[ascenso_por_cluster.idxmax()]
            bron_val = bronce_por_cluster[bronce_por_cluster.idxmax()]
            st.markdown("---")
            st.subheader("Estrategia Recomendada")
            if asc_val > 0.7 and bron_val > 0.7:
                st.markdown("- 🔀 Se recomienda una estrategia **dual**: potenciar el ascenso de los segmentos con alto potencial y, al mismo tiempo, contener a los segmentos críticos con alto riesgo de caída.")
            elif asc_val > 0.7:
                st.markdown("- 🎯 La estrategia debe enfocarse en potenciar a los clientes con alto potencial de ascenso. Son los que darán mayor retorno de inversión en este momento.")
            elif bron_val > 0.7:
                st.markdown("- 🛑 La prioridad es la contención. Se deben implementar acciones para retener a los clientes del clúster más riesgoso antes de que se pierdan por completo.")
            else:
                st.info("🔍 Los valores de probabilidad no son extremos. Se recomienda una estrategia de monitoreo constante y de optimización de las campañas existentes.")

    except Exception as e:
        st.error(f"❌ Error durante la interpretación de predicciones: {e}")

def plot_scatter_rfm(df, eje_x, eje_y, titulo="RFM Scatter"):
    """
    Crea un gráfico de dispersión interactivo usando Plotly.
    Plotly es la librería recomendada para gráficos en Streamlit.

    Args:
        df (pd.DataFrame): DataFrame con los datos de clientes, incluyendo las
                          columnas para los ejes, 'Cluster_Label', y datos de hover.
        eje_x (str): Nombre de la columna para el eje X.
        eje_y (str): Nombre de la columna para el eje Y.
        titulo (str): Título del gráfico.
    """
    # Definimos el diccionario de colores para los clústeres
    colores_k5 = {
        0: 'green',
        1: 'blue',
        2: 'red',
        3: 'purple',
        4: 'orange'
    }

    # Usamos plotly.express para crear el gráfico de dispersión de manera sencilla.
    # El diccionario de colores se mapea directamente a la columna 'Cluster_Label'
    fig = px.scatter(
        df,
        x=eje_x,
        y=eje_y,
        color="Cluster_Label",
        title=titulo,
        color_discrete_map=colores_k5,
        hover_data=['C_CLIEN', 'Recency', 'Frequency', 'Monetary'] # Añadimos información en el tooltip
    )

    # Actualizamos el diseño para una mejor visualización
    fig.update_layout(
        title={
            'text': titulo,
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        legend_title_text='Segmento',
        hovermode="closest"
    )

    return fig

with tab1:
    st.subheader("📍 Distribución General de Clientes por Segmento")
    st.caption(f"Visualización de clientes por segmento en la región seleccionada, para la empresa **Adargar**")

    # Selección de ejes
    variables_disponibles = ["Recency", "Frequency", "Monetary"]
    col1, col2 = st.columns(2)
    with col1:
        eje_x = st.selectbox("Eje X", variables_disponibles, key="x1")
    with col2:
        eje_y = st.selectbox("Eje Y", variables_disponibles, index=1, key="y1")

    # Obtener el DataFrame de la región seleccionada
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # Generar el gráfico de dispersión llamando a la función corregida con Plotly
    # Se reemplaza la lógica de Matplotlib para usar la función plot_scatter_rfm.
    fig = plot_scatter_rfm(df_region, eje_x, eje_y, titulo=f"{region} - {eje_y} vs {eje_x}")
    st.plotly_chart(fig)

    st.caption("📊 Distribución actual de clientes por segmento en la región seleccionada:")
    st.dataframe(
        df_region["Cluster_Label"]
        .value_counts()
        .rename_axis("Segmento")
        .reset_index(name="Clientes")
    )

# Dado que ya integramos arriba ese tipo de visualización en el tab1 dinámico (donde el usuario puede seleccionar cualquier combinación
# de ejes RFM y la región), este segundo bloque también queda totalmente abarcado por el tab1, es por eso que las líneas de
# código estan comentadas con #

# Moquegua – Frequency vs Monetary
# plot_scatter_rfm(df_moq, "Frequency", "Monetary", "📍 Moquegua – Frecuencia vs Monto Gastado")

# Tacna – Frequency vs Monetary
# plot_scatter_rfm(df_tac, "Frequency", "Monetary", "📍 Tacna – Frecuencia vs Monto Gastado")

# Idem al bloque anterior

# Moquegua – Recency vs Monetary
# plot_scatter_rfm(df_moq, "Recency", "Monetary", "📍 Moquegua – Recency vs Monto Gastado")

# Tacna – Recency vs Monetary
# plot_scatter_rfm(df_tac, "Recency", "Monetary", "📍 Tacna – Recency vs Monto Gastado")

with tab2:
    st.subheader("📊 Estadísticas de Valor por Clúster RFM")
    st.caption(f"Visualiza promedios de Recency, Frequency y Monetary en clientes de **{region}**")

    # 🧩 Dataset según región activa
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    df_region["Cluster_Label"] = df_region["Cluster_Label"].fillna("Desconocido")

    # 🚨 Nuevo orden con 5 clústeres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    df_region["Cluster_Label"] = pd.Categorical(df_region["Cluster_Label"], categories=orden, ordered=True)

    # 📈 Tabla: Promedio RFM por segmento
    st.markdown("### 📌 Promedios por Clúster RFM")
    resumen = df_region.groupby("Cluster_Label").agg({
        "Recency": "mean",
        "Frequency": "mean",
        "Monetary": "mean"
    }).round(1).reset_index()
    resumen.rename(columns={
        "Recency": "Recency (días)",
        "Frequency": "Frecuencia",
        "Monetary": "Monetary (S/.)"
    }, inplace=True)
    st.dataframe(resumen.style.format({
        "Recency (días)": "{:.1f}",
        "Frecuencia": "{:.1f}",
        "Monetary (S/.)": "S/ {:.1f}"
    }), use_container_width=True)

    # 👥 Tabla: Cantidad por segmento
    st.markdown("### 👥 Cantidad de Clientes por Clúster")
    conteo = df_region["Cluster_Label"].value_counts().reindex(orden).fillna(0).astype(int).reset_index()
    conteo.columns = ["Clúster", "Clientes"]
    st.dataframe(conteo, use_container_width=True)

    # 🧠 Interpretación automática
    with st.expander("🧠 Interpretación automática"):
        if not conteo.empty:
            top_segmento = conteo.loc[conteo["Clientes"].idxmax(), "Clúster"]
            r_max = resumen.loc[resumen["Cluster_Label"] == top_segmento, "Recency (días)"].values[0]
            m_max = resumen.loc[resumen["Cluster_Label"] == top_segmento, "Monetary (S/.)"].values[0]
            st.markdown(f"- 🏆 El clúster más numeroso es **{top_segmento}**, con recency promedio de **{r_max:.1f} días** y consumo medio de **S/ {m_max:.1f}**.")

            # 🚨 Lógica de interpretación actualizada para los nuevos umbrales
            if top_segmento == "Diamante":
                 st.success("💎 El segmento más numeroso es de alto valor. ¡Excelente!")
            elif r_max <= 30:
                st.info("🔁 Recency bajo: indica clientes recientemente activos.")
            elif m_max >= 500:
                st.info("💰 Ticket promedio elevado: estos clientes tienen alto valor monetario.")
            else:
                st.info("🔍 No se encontraron patrones destacados en el segmento más numeroso.")
        else:
            st.warning("⚠️ No se pudo realizar la interpretación automática. DataFrame vacío.")

def ordenar_segmentos_seguro(series_segmentos, nombre_var="Cluster_Label"):
    """
    Función robusta para ordenar segmentos de manera segura.
    Se asegura de que el orden jerárquico se respete,
    y añade cualquier segmento inesperado al final.
    """
    # Definimos el orden jerárquico deseado para los 5 clústeres
    orden_jerarquico = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    # Obtenemos los segmentos que realmente existen en los datos (el índice de la serie)
    segmentos_existentes = list(series_segmentos.index)

    # Creamos el orden final filtrando el orden jerárquico con los segmentos existentes
    orden_final = [seg for seg in orden_jerarquico if seg in segmentos_existentes]

    # Añadimos cualquier segmento existente que no esté en nuestra lista jerárquica
    # Esto es útil si aparece un clúster no esperado en el futuro
    for seg in segmentos_existentes:
        if seg not in orden_final:
            orden_final.append(seg)

    # Reindexamos la serie con el orden final y devolvemos el resultado
    return series_segmentos.reindex(orden_final)

def graficar_tamaño_cluster(df, region=""):
    """
    Función para graficar el tamaño de los clústeres usando Plotly.
    Plotly es la librería recomendada y compatible con Streamlit.
    """
    # 🚨 Usamos el orden y los colores de los 5 clústeres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # Contamos los clientes por clúster y reindexamos para el orden correcto
    conteo = df["Cluster_Label"].value_counts().reindex(orden).fillna(0).astype(int).reset_index()
    conteo.columns = ["Cluster", "Clientes"]

    # Creamos el gráfico de barras interactivo con Plotly
    fig = px.bar(
        conteo,
        x="Cluster",
        y="Clientes",
        color="Cluster",
        color_discrete_map=colores_k5,
        labels={"Cluster": "Segmento", "Clientes": "Nro. de Clientes"},
        title=f"📊 Distribución de clientes por segmento – {region}",
    )

    # Añadimos las etiquetas de texto encima de las barras
    fig.update_traces(texttemplate='%{y}', textposition='outside')
    fig.update_layout(
        title={
            'text': f"📊 Distribución de clientes por segmento – {region}",
            'y': 0.9,
            'x': 0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        xaxis={'categoryorder': 'array', 'categoryarray': orden}, # Aseguramos el orden en el eje X
        hovermode="x unified",
        showlegend=False # La información ya está en el eje X
    )

    return fig

# Ejemplo de cómo se llamaría la función en Streamlit:
# fig_tamano = graficar_tamaño_cluster(df_region, region)
# st.plotly_chart(fig_tamano)

with tab3:
    st.subheader("📦 Distribución de Clientes por Segmento RFM")
    st.caption(f"Visualiza cuántos clientes pertenecen a cada clúster en la región de **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # 👁️ Mostrar gráfico de barras adaptado con Plotly
    # Se ha cambiado st.pyplot por st.plotly_chart para un gráfico interactivo.
    st.plotly_chart(graficar_tamaño_cluster(df_region, region))

    # 🧮 Mostrar tabla resumen de conteo por clúster
    conteo = ordenar_segmentos_seguro(df_region["Cluster_Label"].value_counts()).reset_index()
    conteo.columns = ["Segmento", "Clientes"]
    st.dataframe(conteo, use_container_width=True)

    # 🧠 Interpretación automática
    with st.expander("🧠 Interpretación automática"):
        segmento_max = conteo.loc[conteo["Clientes"].idxmax(), "Segmento"]
        st.markdown(f"- 🏆 El segmento dominante en **{region}** es **{segmento_max}**.")

        # � Lógica de interpretación actualizada para 5 clústeres
        if segmento_max == "Diamante":
            st.success("💎 Excelente: predominan los clientes más valiosos y leales.")
        elif segmento_max == "Oro":
            st.success("✨ Excelente: predominan clientes de alto valor y leales.")
        elif segmento_max == "Plata":
            st.info("📈 Gran oportunidad: clientes constantes con potencial de crecimiento.")
        elif segmento_max == "Cobre":
            st.warning("💡 Atención: mayoría de clientes en estado de oportunidad o riesgo de inactividad.")
        elif segmento_max == "Bronce":
            st.error("⚠️ Alerta: el segmento más numeroso requiere una estrategia urgente de reactivación.")

with tab4:
    st.subheader("💼 Estrategias de Campaña por Clúster RFM")
    st.caption("Aplicables a clientes según su clasificación por Recency, Frequency y Monetary.")

    tabla_html = """
    <div style="border:1px solid #ddd; border-radius:10px; padding:15px; background-color:#fefefe; box-shadow:2px 2px 8px rgba(0,0,0,0.05); margin-top:15px;">

    <h4 style="margin-bottom:10px;">📌 Recomendaciones de Campaña por Segmento</h4>

    <table style="width:100%; border-collapse: collapse; font-family: 'Segoe UI', sans-serif; font-size:15px;">
      <thead style="background-color:#e0e0e0;">
        <tr>
          <th style="border: 1px solid #ccc; padding: 8px;">Clúster</th>
          <th style="border: 1px solid #ccc; padding: 8px;">Perfil</th>
          <th style="border: 1px solid #ccc; padding: 8px;">Objetivo</th>
          <th style="border: 1px solid #ccc; padding: 8px;">Acción Recomendada</th>
        </tr>
      </thead>
      <tbody>
        <tr style="background-color:#e6f8ff;">
          <td style="border: 1px solid #eee; padding: 8px;">💎 Diamante</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes élite, de alto valor</td>
          <td style="border: 1px solid #eee; padding: 8px;">Fidelización y crecimiento</td>
          <td style="border: 1px solid #eee; padding: 8px;">Programas de lealtad exclusivos y anticipación de necesidades.</td>
        </tr>
        <tr style="background-color:#fffbe6;">
          <td style="border: 1px solid #eee; padding: 8px;">🟡 Oro</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes muy valiosos y leales</td>
          <td style="border: 1px solid #eee; padding: 8px;">Fidelización y potenciar</td>
          <td style="border: 1px solid #eee; padding: 8px;">Ofrecer programas VIP y seguimiento personalizado.</td>
        </tr>
        <tr style="background-color:#f0f9ff;">
          <td style="border: 1px solid #eee; padding: 8px;">🔵 Plata</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes con frecuencia y valor medio</td>
          <td style="border: 1px solid #eee; padding: 8px;">Impulso de recurrencia y up-selling</td>
          <td style="border: 1px solid #eee; padding: 8px;">Enviar promociones segmentadas y correos de recordatorio.</td>
        </tr>
        <tr style="background-color:#fff8f6;">
          <td style="border: 1px solid #eee; padding: 8px;">💡 Cobre</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes en riesgo de inactividad</td>
          <td style="border: 1px solid #eee; padding: 8px;">Retención y oportunidad</td>
          <td style="border: 1px solid #eee; padding: 8px;">Enfoque en productos complementarios y reactivación con ofertas de valor.</td>
        </tr>
        <tr style="background-color:#f6e6ff;">
          <td style="border: 1px solid #eee; padding: 8px;">🟤 Bronce</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes de bajo ticket o inactivos</td>
          <td style="border: 1px solid #eee; padding: 8px;">Reactivación</td>
          <td style="border: 1px solid #eee; padding: 8px;">Lanzar campañas con ofertas de bienvenida o combos accesibles.</td>
        </tr>
      </tbody>
    </table>
    </div>
    """
    st.markdown(tabla_html, unsafe_allow_html=True)

def plot_boxplots_rfm(df, region):
    """
    Función que genera boxplots interactivos para las variables RFM por clúster
    usando Plotly. Se utiliza la técnica de 'melt' para reestructurar los datos
    y graficar los tres boxplots en una sola llamada a Plotly.
    """
    # 🚨 Usamos el orden y los colores de los 5 clústeres
    orden_k5 = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # Seleccionamos las variables RFM y el clúster
    rfm_vars = ["Recency", "Frequency", "Monetary"]
    df_plot = df[["Cluster_Label"] + rfm_vars].copy()

    # Se utiliza pd.melt para "derretir" el DataFrame de un formato ancho a uno largo,
    # lo cual es ideal para graficar múltiples variables en un mismo gráfico de Plotly.
    df_melt = df_plot.melt(id_vars="Cluster_Label", value_vars=rfm_vars, var_name="Variable", value_name="Valor")

    # Creamos el gráfico de boxplots utilizando facetas para cada variable
    fig = px.box(
        df_melt,
        x="Cluster_Label",
        y="Valor",
        color="Cluster_Label",
        facet_col="Variable",
        facet_col_wrap=3, # Se muestran los 3 boxplots uno al lado del otro
        category_orders={"Cluster_Label": orden_k5}, # Aseguramos el orden de los clústeres
        color_discrete_map=colores_k5,
        title=f"Distribución RFM por Clúster – {region}",
        labels={"Cluster_Label": "Segmento", "Valor": "Valor"},
    )

    # Ajustes de diseño para mejorar la visualización
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1])) # Elimina el "Variable=" del título de la faceta
    fig.update_layout(
        title={
            'text': f"Distribución RFM por Clúster – {region}",
            'y': 0.9,
            'x': 0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        hovermode="closest",
        legend_title_text='Segmento',
    )

    return fig

# Nueva función para interpretar boxplots
def interpretar_boxplot_rfm(df, variable, region):
    """
    Función de interpretación automática para un boxplot de cualquier variable RFM.
    """
    st.markdown("🧠 **Interpretación Automática del Boxplot:**")
    try:
        resumen_bruto = df.groupby("Cluster_Label")[variable].describe()[["mean", "25%", "50%", "75%"]].round(2)
        resumen = ordenar_segmentos_seguro(resumen_bruto)

        if resumen is not None and not resumen.empty:
            mayor_media = resumen["mean"].idxmax()
            menor_media = resumen["mean"].idxmin()
            q3_max = resumen["75%"].max()

            st.markdown(f"- 📍 En **{region}**, el clúster con mayor valor promedio de `{variable}` es **{mayor_media}**.")
            st.markdown(f"- 🧭 El clúster con menor valor promedio es **{menor_media}**.")

            # Análisis de outliers
            outliers_detectados = False
            for segmento in resumen.index:
                q1 = resumen.loc[segmento, "25%"]
                q3 = resumen.loc[segmento, "75%"]
                iqr = q3 - q1
                limite_superior_teorico = q3 + 1.5 * iqr

                max_real = df[df["Cluster_Label"] == segmento][variable].max()

                if max_real > limite_superior_teorico:
                    st.warning(f"⚠️ El segmento **{segmento}** tiene **valores atípicos** altos en `{variable}`, indicando clientes con comportamiento extremo.")
                    outliers_detectados = True

            if not outliers_detectados:
                st.info("✅ No se detectaron valores atípicos significativos. Los clústeres son bastante homogéneos.")

        else:
            st.warning("⚠️ No se pudo calcular el resumen estadístico confiable para esta métrica.")
    except Exception as e:
        st.error(f"❌ Error al interpretar el gráfico Boxplot: {e}")

# --- Bloque corregido para tab5 ---
with tab5:
    st.subheader("📊 Distribución de métricas RFM por segmento")
    st.caption(f"Comparación visual de dispersión y valores atípicos según el segmento en **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    fig = plot_boxplots_rfm(df_region, region)
    # 🚨 LÍNEA CORREGIDA: Se usa st.plotly_chart para un gráfico interactivo
    st.plotly_chart(fig)

    st.markdown("---") # Separador para mejor lectura
    st.markdown("### 📌 Interpretación automática por métrica")
    for variable in ("Recency", "Frequency", "Monetary"):
        with st.expander(f"📎 Análisis de {variable} por segmento"):
            # 🚨 Se llama a la nueva función de interpretación para boxplots
            interpretar_boxplot_rfm(df_region, variable, region)

with tab6:
    st.subheader("🏅 Top Clientes de Alto Valor: Diamante y Oro")
    st.caption(f"Listado de clientes 'Diamante' y 'Oro' ordenados por valor monetario en **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # 🚨 Se filtra por los 2 segmentos de mayor valor
    df_top_segmentos = df_region[df_region["Cluster_Label"].isin(["Diamante", "Oro"])].copy()

    top_n = st.slider("Selecciona cuántos clientes de alto valor mostrar:", min_value=5, max_value=50, value=10, step=5)

    if not df_top_segmentos.empty:
        top_df = df_top_segmentos.sort_values(by="Monetary", ascending=False).head(top_n).reset_index(drop=True)
        top_df.index += 1

        st.dataframe(
            top_df[["C_CLIEN", "Recency", "Frequency", "Monetary", "Cluster_Label"]].round(1).rename(columns={
                "C_CLIEN": "Código Cliente",
                "Recency": "Recencia (días)",
                "Frequency": "Frecuencia (compras)",
                "Monetary": "Valor Monetario (S/)",
                "Cluster_Label": "Segmento"
            }),
            use_container_width=True
        )

        # 🧾 Excel exportación
        output = io.BytesIO()
        wb = Workbook()
        resumen_sheet = wb.active
        resumen_sheet.title = "Resumen de Top Clientes"

        # 🎨 Estilos
        header_font = Font(bold=True, color="FFFFFF")
        align_center = Alignment(horizontal="center")
        border = Border(bottom=Side(style="thin"))

        # 🚨 Nuevo diccionario con 5 colores para los clústeres
        cluster_fills = {
            "Diamante": PatternFill(start_color="00FFFF", fill_type="solid"),
            "Oro": PatternFill(start_color="FFD700", fill_type="solid"),
            "Plata": PatternFill(start_color="C0C0C0", fill_type="solid"),
            "Cobre": PatternFill(start_color="B87333", fill_type="solid"),
            "Bronce": PatternFill(start_color="CD7F32", fill_type="solid")
        }

        # 🖼️ Logo (si existe)
        try:
            logo = XLImage("logo_adargar.jpg")
            logo.width = 220
            logo.height = 70
            resumen_sheet.add_image(logo, "A1")
        except:
            pass

        # 📋 Título + fecha
        resumen_sheet["A5"] = f"📊 Reporte de Clientes Diamante y Oro – Región: {region}"
        resumen_sheet["A5"].font = Font(bold=True, size=12)
        resumen_sheet["A5"].alignment = align_center
        resumen_sheet.merge_cells("A5:E5")
        resumen_sheet["A6"] = f"Fecha de generación: {datetime.today().strftime('%d/%m/%Y')}"
        resumen_sheet["A6"].font = Font(italic=True, size=10)

        # 🧩 Encabezado
        headers = ["Código Cliente", "Recencia (días)", "Frecuencia (compras)", "Valor Monetario (S/)", "Segmento"]
        for i, h in enumerate(headers, start=1):
            cell = resumen_sheet.cell(row=10, column=i, value=h)
            cell.font = header_font
            cell.alignment = align_center
            cell.fill = cluster_fills.get(top_df["Cluster_Label"].iloc[0], cluster_fills["Oro"]) # 🚨 Ajuste para color
            cell.border = border

        # 👤 Datos
        for i, row in enumerate(top_df.itertuples(index=False), start=11):
            resumen_sheet.cell(row=i, column=1, value=row.C_CLIEN)
            resumen_sheet.cell(row=i, column=2, value=row.Recency)
            resumen_sheet.cell(row=i, column=3, value=row.Frequency)
            resumen_sheet.cell(row=i, column=4, value=row.Monetary)
            cell_cluster = resumen_sheet.cell(row=i, column=5, value=row.Cluster_Label)
            cell_cluster.fill = cluster_fills.get(row.Cluster_Label, None)

        for col in "ABCDE":
            resumen_sheet.column_dimensions[col].width = 20

        # 🗂️ Otras hojas por clúster
        # 🚨 Se itera sobre los 5 clústeres
        for label in ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]:
            df_cl = df_region[df_region["Cluster_Label"] == label].copy()
            hoja = wb.create_sheet(f"Clúster {label}")
            hoja.append(["Código Cliente", "Recencia (días)", "Frecuencia", "Valor Monetario (S/)", "Cluster_Label", "Color", "Región"])
            for r in df_cl.itertuples(index=False):
                hoja.append([
                    r.C_CLIEN, r.Recency, r.Frequency, r.Monetary,
                    r.Cluster_Label, r.Color, r.Region
                ])
            for cell in hoja["1:1"]:
                cell.font = header_font
                cell.fill = cluster_fills[label]
                cell.border = border
                cell.alignment = align_center
            for col in "ABCDEFG":
                hoja.column_dimensions[col].width = 18
            hoja.append([])
            hoja.append(["📌 Estrategia:", estrategias.get(label, "")])

        if "Sheet" in wb.sheetnames:
            del wb["Sheet"]

        wb.save(output)
        output.seek(0)

        st.download_button(
            label=f"📘 Descargar Reporte Excel – {region}",
            data=output,
            # 🚨 Se actualiza el nombre del archivo
            file_name=f"Reporte_Clientes_Diamante_Oro_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.warning(f"⚠️ No se encontraron clientes de alto valor (Diamante o Oro) en la región {region}.")

with tab7:
    st.subheader("🛎️ Clientes con Recencia Crítica por Segmento")
    st.caption(f"Filtra y descarga clientes con señales de abandono en la región **{region}** para activar campañas de retención segmentada.")

    # Selección de región
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # 🚨 Selección de clúster actualizada
    segmentos = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    segmento_seleccionado = st.selectbox("🎯 Selecciona el segmento a analizar:", segmentos, key="seg_critico")

    df_segmento = df_region[df_region["Cluster_Label"] == segmento_seleccionado].copy()

    modo_alerta = st.radio("📊 Criterio de alerta:", ["Recency > percentil 75", "Recency > 90 días"], index=0, key="modo_alerta")

    if modo_alerta == "Recency > percentil 75":
        if not df_segmento.empty:
            umbral = df_segmento["Recency"].quantile(0.75)
            st.markdown(f"🔍 Clientes con Recency > **{umbral:.0f} días** serán marcados como en riesgo.")
        else:
            umbral = 0
            st.markdown("🔍 No hay datos para este segmento. No se puede calcular el umbral.")
    else:
        umbral = 90
        st.markdown("🔍 Clientes con Recency > **90 días** serán marcados como en riesgo.")

    clientes_riesgo = df_segmento[df_segmento["Recency"] > umbral].copy()
    clientes_riesgo = clientes_riesgo.sort_values(by="Recency", ascending=False).reset_index(drop=True)

    col1, col2, col3 = st.columns(3)
    col1.metric(f"Clientes {segmento_seleccionado} Totales", len(df_segmento))
    col2.metric("Clientes en Riesgo", len(clientes_riesgo))
    porcentaje = f"{(100 * len(clientes_riesgo) / len(df_segmento)):.1f}%" if len(df_segmento) > 0 else "0%"
    col3.metric("% en Riesgo", porcentaje)

    if not clientes_riesgo.empty:
        st.markdown("### 📋 Detalle de clientes en riesgo:")
        st.dataframe(
            clientes_riesgo[["C_CLIEN", "Recency", "Frequency", "Monetary", "Cluster_Label"]].round(1).rename(columns={
                "C_CLIEN": "Código Cliente",
                "Recency": "Recencia (días)",
                "Frequency": "Frecuencia (compras)",
                "Monetary": "Valor Monetario (S/)",
                "Cluster_Label": "Segmento"
            }),
            use_container_width=True
        )

        buffer = io.BytesIO()
        wb = Workbook()
        ws = wb.active
        ws.title = f"Alerta {segmento_seleccionado} – {region}"

        ws["A1"] = f"📋 Clientes {segmento_seleccionado} en Riesgo – {region}"
        ws["A1"].font = Font(bold=True)
        ws.merge_cells("A1:D1")
        ws.append(["Código Cliente", "Recencia", "Frecuencia", "Monetario"])

        for r in clientes_riesgo.itertuples(index=False):
            ws.append([r.C_CLIEN, r.Recency, r.Frequency, r.Monetary])

        for col in "ABCD":
            ws.column_dimensions[col].width = 20

        wb.save(buffer)
        buffer.seek(0)

        st.download_button(
            label=f"📄 Descargar Excel – {segmento_seleccionado} – {region}",
            data=buffer,
            file_name=f"Alerta_{segmento_seleccionado}_Riesgo_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.success(f"🎉 No hay clientes {segmento_seleccionado} en riesgo con los criterios actuales.")

    st.markdown("---")
    st.markdown("### 📌 Recomendación Estratégica")

    # 🚨 Diccionario de estrategias actualizado
    estrategias = {
        "Diamante": "Contactar con atención premium, beneficios exclusivos y encuestas de satisfacción.",
        "Oro": "Ofrecer programas VIP y seguimiento personalizado para mantener la lealtad.",
        "Plata": "Ofrecer promociones segmentadas, cupones de incentivo o encuestas de vinculación.",
        "Cobre": "Aplicar campañas de reactivación con ofertas de valor, cross-selling y comunicación proactiva.",
        "Bronce": "Lanzar campañas con ofertas de bienvenida o combos accesibles para reactivar la base."
    }
    st.info(estrategias.get(segmento_seleccionado, "Estrategia no definida para este segmento."))

# 🛠️ Recalcular df_tac y df_moq después de entrenar el modelo
df_tac = rfm[rfm["Region"] == "Tacna"].copy()
df_moq = rfm[rfm["Region"] == "Moquegua"].copy()

# Función para interpretar las predicciones, asumiendo que existe
# Es recomendable definir esta función en otro bloque de código.
def interpretar_predicciones(region, df):
    # Lógica de interpretación para los clústeres...
    st.markdown(f"**Análisis Predictivo en la Región {region}:**")
    for cluster in ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]:
        df_cluster = df[df["Cluster_Label"] == cluster]
        if not df_cluster.empty:
            prob_ascenso_mean = df_cluster["Probabilidad_Ascenso_Oro"].mean()
            prob_descenso_mean = df_cluster["Probabilidad_Descenso_Bronce"].mean()
            st.markdown(f"---")
            st.markdown(f"**Segmento {cluster}:**")
            st.markdown(f"- Probabilidad promedio de ascenso a Oro: **{prob_ascenso_mean:.2f}**")
            st.markdown(f"- Probabilidad promedio de caída a Bronce: **{prob_descenso_mean:.2f}**")

# --- Bloque corregido para tab8 ---
with tab8:
    st.subheader("🔮 Modelo de Evolución de Clientes por Región")
    st.caption(f"Análisis predictivo aplicado a la región **{region}** para anticipar evolución y riesgo de clientes.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # Se usan las nuevas columnas de predicción
    df_region["Probabilidad_Ascenso_Oro"] = pd.to_numeric(df_region["Probabilidad_Ascenso_Oro"], errors="coerce")
    df_region["Probabilidad_Descenso_Bronce"] = pd.to_numeric(df_region["Probabilidad_Descenso_Bronce"], errors="coerce")

    # Vista de clientes con alta probabilidad de ascenso
    st.markdown("### 📈 Clientes con potencial de ascenso")
    umbral = st.slider("📈 Umbral de probabilidad de ascenso a Oro:", 0.5, 1.0, 0.75, step=0.05)

    df_filtrado = df_region[df_region["Probabilidad_Ascenso_Oro"] >= umbral].copy()
    df_filtrado = df_filtrado.sort_values("Probabilidad_Ascenso_Oro", ascending=False).reset_index(drop=True)

    def definir_campaña(row):
        if row["Cluster_Label"] in ["Bronce", "Cobre"] and row["Probabilidad_Ascenso_Oro"] >= umbral:
            return "🎯 Activar con Oferta Especial"
        elif row["Cluster_Label"] == "Plata" and row["Probabilidad_Ascenso_Oro"] >= umbral:
            return "📈 Seguimiento Comercial y Up-selling"
        elif row["Cluster_Label"] in ["Oro", "Diamante"] and row["Probabilidad_Descenso_Bronce"] >= 0.5:
            return "⚠️ Retener Urgentemente"
        else:
            return "🤝 Mantenimiento Estratégico"

    if not df_filtrado.empty:
        df_filtrado["Campaña Sugerida"] = df_filtrado.apply(definir_campaña, axis=1)

        st.markdown(f"📋 Se identificaron **{len(df_filtrado)}** clientes con alta probabilidad de ascenso a Oro.")
        st.dataframe(
            df_filtrado[[
                "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "Campaña Sugerida"
            ]].rename(columns={
                "C_CLIEN": "Código Cliente",
                "Cluster_Label": "Clúster Actual",
                "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro"
            }).round(3),
            use_container_width=True
        )

        excel_buff = io.BytesIO()
        df_exportar = df_filtrado[[
            "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "Campaña Sugerida"
        ]].rename(columns={
            "C_CLIEN": "Código Cliente",
            "Cluster_Label": "Clúster Actual",
            "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro"
        })
        df_exportar.to_excel(excel_buff, index=False)
        excel_buff.seek(0)

        st.download_button(
            "📥 Descargar Excel de Clientes en Evolución",
            data=excel_buff,
            file_name=f"Prediccion_Evolucion_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.info("🔍 No se encontraron clientes que cumplan el umbral de probabilidad establecido.")

    st.subheader("📊 Distribución – Probabilidad de Ascenso a Oro")
    if df_region["Probabilidad_Ascenso_Oro"].notna().sum() > 0:
        # LÍNEA CORREGIDA: Se usa plotly.express para el histograma interactivo
        fig = px.histogram(
            df_region, x="Probabilidad_Ascenso_Oro", nbins=20,
            title=f"Distribución – Probabilidad de Ascenso a Oro ({region})",
            labels={"Probabilidad_Ascenso_Oro": "Probabilidad", "count": "Clientes"}
        )
        st.plotly_chart(fig)

        with st.expander("🧠 Ver interpretación predictiva automática por clúster"):
            interpretar_predicciones(region, df_region)
    else:
        st.warning("⚠️ No hay datos numéricos válidos para graficar.")

    st.subheader("📈 Vista estratégica de Riesgo y Oportunidad (Ascenso vs Caída)")
    st.markdown("🔍 Analiza clientes según su **probabilidad de ascenso a Oro** y **riesgo de caída a Bronce**.")

    col1, col2 = st.columns(2)
    with col1:
        umbral_ascenso = st.slider("🎯 Umbral de ascenso alto", 0.6, 1.0, 0.8, step=0.05, key="umbral_ascenso_plot")
    with col2:
        umbral_caida = st.slider("🛑 Umbral de caída alta", 0.4, 1.0, 0.6, step=0.05, key="umbral_caida_plot")

    def clasificar_cuadrante(row):
        # 🚨 Lógica de clasificación actualizada con las nuevas columnas
        if row["Probabilidad_Ascenso_Oro"] >= umbral_ascenso:
            if row["Probabilidad_Descenso_Bronce"] <= 1 - umbral_caida:
                return "Cliente Estrella (Ascenso Seguro)"
            else:
                return "Potencial de Ascenso y Riesgo"
        elif row["Probabilidad_Descenso_Bronce"] >= umbral_caida:
            if row["Probabilidad_Ascenso_Oro"] <= 1 - umbral_ascenso:
                return "Riesgo de Abandono (Caída Segura)"
            else:
                return "Riesgo con Potencial"
        else:
            return "Zona de Desarrollo y Estabilidad"

    df_region["Segmento Estratégico"] = df_region.apply(clasificar_cuadrante, axis=1)

    st.markdown(f"📌 Se han clasificado **{df_region.shape[0]}** clientes según su perfil estratégico.")
    st.dataframe(
        df_region[[
            "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce", "Segmento Estratégico"
        ]].rename(columns={
            "C_CLIEN": "Código Cliente",
            "Cluster_Label": "Clúster Actual",
            "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro",
            "Probabilidad_Descenso_Bronce": "Prob. Caída a Bronce"
        }).round(3),
        use_container_width=True
    )

    # LÍNEA CORREGIDA: Se usa plotly.express para el scatter plot interactivo
    fig = px.scatter(
        df_region,
        x="Probabilidad_Ascenso_Oro", y="Probabilidad_Descenso_Bronce",
        color="Segmento Estratégico",
        title=f"Matriz Estratégica de Evolución – {region}",
        labels={
            "Probabilidad_Ascenso_Oro": "Probabilidad de Ascenso a Oro",
            "Probabilidad_Descenso_Bronce": "Probabilidad de Caída a Bronce"
        },
        height=500
    )
    # Ajustamos la posición de la leyenda y los ejes
    fig.update_layout(legend_title_text='Segmento Estratégico')
    # Añadimos las líneas de los umbrales
    fig.add_vline(x=umbral_ascenso, line_width=1, line_dash="dash", line_color="gray")
    fig.add_hline(y=umbral_caida, line_width=1, line_dash="dash", line_color="gray")
    st.plotly_chart(fig)

    excel_buffer = io.BytesIO()
    df_exportar_cuadrantes = df_region[[
        "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro",
        "Probabilidad_Descenso_Bronce", "Segmento Estratégico"
    ]].rename(columns={
        "C_CLIEN": "Código Cliente",
        "Cluster_Label": "Clúster Actual",
        "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro",
        "Probabilidad_Descenso_Bronce": "Prob. Caída a Bronce"
    })
    df_exportar_cuadrantes.to_excel(excel_buffer, index=False)
    excel_buffer.seek(0)

    st.download_button(
        "📥 Descargar Excel de Clientes Segmentados",
        data=excel_buffer,
        file_name=f"Matriz_Estrategica_{region}.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

# Nueva función para la interpretación de histogramas RFM
def interpretar_histograma_rfm(df, variable, region):
    st.markdown("### 🔍 Análisis de la distribución por clúster:")

    # Orden de los clústeres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden:
        subset = df[df["Cluster_Label"] == label][variable].dropna()
        if not subset.empty:
            media = subset.mean()
            mediana = subset.median()
            st.markdown(f"**{label}**:")
            st.markdown(f"- Media: **{media:.2f}**, Mediana: **{mediana:.2f}**")

            # Lógica de interpretación básica
            if variable == "Recency":
                if media < 30:
                    st.success(f"  - 🎉 Los clientes de este segmento han comprado recientemente (media < 30 días).")
                elif media > 180:
                    st.error(f"  - ⏳ Los clientes de este segmento están inactivos (media > 180 días).")
                else:
                    st.info(f"  - 📈 Compras a intervalos moderados. Oportunidad de marketing. ")

            elif variable == "Frequency":
                if media >= 10:
                    st.success(f"  - 🛒 Clientes muy recurrentes, compran frecuentemente (media >= 10).")
                elif media >= 3:
                    st.info(f"  - 🔄 Clientes con frecuencia moderada. Se puede impulsar más compras.")
                else:
                    st.warning(f"  - 📉 Clientes poco recurrentes. Fomentar la repetición de compra.")

            elif variable == "Monetary":
                if media >= 2000:
                    st.success(f"  - 💰 Alto valor monetario. Clientes muy valiosos (media >= S/ 2000).")
                elif media >= 500:
                    st.info(f"  - 📈 Valor monetario moderado. Potencial para aumentar el ticket promedio.")
                else:
                    st.warning(f"  - 💸 Bajo valor monetario. Se puede incentivar compras de mayor valor.")

# --- Bloque corregido para tab9 ---
with tab9:
    st.subheader("📊 Distribución de Comportamiento RFM por Clúster")
    st.caption(f"Visualiza la distribución de métricas RFM para los diferentes segmentos en **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    variable = st.selectbox("Selecciona la variable RFM a analizar:", ["Recency", "Frequency", "Monetary"])

    st.markdown(f"🔍 Histograma de **{variable}** segmentado por **Cluster_Label** en **{region}**")

    # 🚨 Diccionario de colores actualizado para los 5 clústeres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # 📊 Histograma apilado con Plotly Express
    fig = px.histogram(
        df_region,
        x=variable,
        color="Cluster_Label",
        color_discrete_map=colores_k5,
        title=f"Distribución de {variable} por Clúster – {region}",
        labels={variable: variable, "count": "Cantidad de Clientes"}
    )
    # Mejora: El modo `stack` es el valor por defecto, pero se puede explicitar si es necesario
    # fig.update_layout(barmode='stack')
    st.plotly_chart(fig)

    # 🧠 Interpretación automática
    with st.expander("🧠 Ver interpretación por clúster"):
        # 🚨 Llamada a la nueva función de interpretación
        interpretar_histograma_rfm(df_region, variable, region)

# 🚨 Nueva función para interpretar los violin plots
def interpretar_violin_rfm(df, variable, region):
    """
    Genera la interpretación de un Violin Plot para los clusters RFM.

    Args:
        df (pd.DataFrame): El DataFrame con los datos de clientes.
        variable (str): La variable a interpretar ('Recency', 'Frequency', 'Monetary').
        region (str): La región seleccionada.
    """
    st.markdown("### 🧠 Interpretación de la Distribución (Violin Plot)")
    st.markdown(f"El ancho del gráfico de violín representa la **densidad de clientes** en cada valor de `{variable}`.")

    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden_clusters:
        # 1. Obtener el subconjunto de datos para el cluster y la variable
        subset = df[df["Cluster_Label"] == label][variable].dropna()

        # 2. 🚨 VERIFICAR SI EL DATAFRAME ESTÁ VACÍO 🚨
        if subset.empty:
            # 3. Si está vacío, mostrar un mensaje de advertencia
            st.markdown(f"**{label}**:")
            st.warning(f"No hay clientes para este segmento en la región **{region}**.")

        else:
            # 4. Si hay datos, proceder con la lógica de interpretación
            media = subset.mean()
            q1 = subset.quantile(0.25)
            q3 = subset.quantile(0.75)
            st.markdown(f"**{label}**:")
            if variable == "Recency":
                if media < 30:
                    st.success(f"- Clientes muy recientes. La mayoría de compras ocurrieron en los últimos {q1:.0f}-{q3:.0f} días.")
                elif media > 90:
                    st.warning(f"- Clientes con alta recencia. La mediana se encuentra en **{subset.median():.0f} días**.")
                else:
                    st.info(f"- Compras en un período de tiempo moderado.")
            elif variable == "Frequency":
                if q3 >= 10:
                    st.success(f"- El 75% de los clientes ha realizado **{q3:.0f} o más compras**. Muy alta frecuencia.")
                elif media < 2:
                    st.warning(f"- La mayoría de los clientes solo ha comprado 1 o 2 veces. Alta inactividad.")
                else:
                    st.info(f"- Frecuencia de compra moderada, con un ticket promedio alto.")
            elif variable == "Monetary":
                if subset.median() > 2000:
                    st.success(f"- Alto valor monetario. El 50% de los clientes gastó más de S/ {subset.median():.0f}.")
                else:
                    st.info(f"- Concentración de gasto en valores más bajos. Oportunidad de up-selling.")

# 🚨 Nueva función para interpretar los KDE plots
def interpretar_kde_rfm(df, variable, region):
    st.markdown("### 🧠 Interpretación de la Densidad (KDE Plot)")
    st.markdown(f"Las curvas de densidad suavizada (KDE) muestran la **concentración de clientes** en los valores de `{variable}`.")
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden_clusters:
        subset = df[df["Cluster_Label"] == label][variable].dropna()
        if not subset.empty:
            media = subset.mean()
            st.markdown(f"**{label}**:")
            if variable == "Recency":
                if media < 30:
                    st.success(f"- La curva tiene un pico en valores bajos, indicando alta concentración de clientes recientes.")
                else:
                    st.info(f"- La curva tiene un pico en valores altos, indicando inactividad en la mayoría de clientes.")
            elif variable == "Frequency":
                if media > 5:
                    st.success(f"- La curva se extiende a la derecha, mostrando que muchos clientes compran frecuentemente.")
                else:
                    st.info(f"- La curva se concentra en valores bajos, indicando que la mayoría de clientes tienen pocas compras.")
            elif variable == "Monetary":
                if media > 1000:
                    st.success(f"- La curva muestra una cola larga a la derecha, indicando un grupo de clientes con muy alto gasto.")
                else:
                    st.info(f"- La curva se concentra en valores bajos, indicando que la mayoría de los clientes tienen un gasto menor.")

# --- Bloque para tab10 ---
with tab10:
    st.subheader("🎻 Análisis de Distribución y Densidad por Variable RFM")
    st.caption(f"Explora la dispersión de métricas RFM según el segmento y región seleccionada: **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    variable = st.selectbox("📌 Variable a analizar:", ["Recency", "Frequency", "Monetary"], key="var_violin")
    df_region[variable] = pd.to_numeric(df_region[variable], errors="coerce")

    # 🚨 Nueva paleta y orden oficial de 5 clústeres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    # 🎼 Violin Plot con Plotly
    st.markdown(f"🎼 **Distribución tipo Violín** de `{variable}` por Clúster")
    fig1 = px.violin(
        df_region,
        x="Cluster_Label",
        y=variable,
        color="Cluster_Label",
        category_orders={"Cluster_Label": orden_clusters},
        color_discrete_map=colores_k5,
        box=True,
        points="all",
        title=f"Violin Plot – {variable} por Clúster ({region})",
        labels={"Cluster_Label": "Segmento", variable: variable}
    )
    st.plotly_chart(fig1)

    with st.expander("🧠 Ver interpretación del Violin Plot"):
        interpretar_violin_rfm(df_region, variable, region)

    # 📈 KDE Plot con Plotly
    st.markdown(f"📈 **Distribución Suavizada (KDE)** de `{variable}` por Clúster")
    fig2 = px.histogram(
        df_region,
        x=variable,
        color="Cluster_Label",
        color_discrete_map=colores_k5,
        marginal="rug",
        title=f"KDE Plot (Aproximado) – {variable} por Clúster ({region})",
        labels={variable: variable, "count": "Cantidad de Clientes"},
        histnorm='density'
    )
    fig2.update_traces(opacity=0.7)
    st.plotly_chart(fig2)

    with st.expander("🧠 Ver interpretación del KDE Plot"):
        interpretar_kde_rfm(df_region, variable, region)

    # 📊 Histograma clásico por clúster con Plotly
    with st.expander("📊 Visual adicional: Histograma clásico por clúster"):
        st.markdown("Comparación directa de la forma bruta de la distribución por segmento.")
        fig3 = px.histogram(
            df_region,
            x=variable,
            color="Cluster_Label",
            color_discrete_map=colores_k5,
            title=f"Histograma Comparativo – {variable} ({region})",
            labels={variable: variable, "count": "Cantidad de Clientes"},
            barmode="overlay",
            opacity=0.7
        )
        st.plotly_chart(fig3)

with tab11:
    st.subheader("🌌 Visualización 3D de Segmentación RFM")
    st.caption(f"Cada punto representa un cliente posicionado en el espacio RFM. Colores indican su clúster asignado para la región **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # ✅ Limpieza de datos numéricos
    for var in ["Recency", "Frequency", "Monetary"]:
        df_region[var] = pd.to_numeric(df_region[var], errors="coerce")

    # 📊 Conteo por clúster
    conteo = df_region["Cluster_Label"].value_counts().reset_index()
    conteo.columns = ["Clúster", "Cantidad de Clientes"]
    st.dataframe(conteo, hide_index=True, use_container_width=True)

    # 🚨 Se actualiza el orden y los colores para los 5 clústeres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # 🎯 Filtro opcional por clúster
    cluster_focus = st.selectbox(
        "Filtrar por clúster:",
        ["Todos"] + [c for c in orden if c in df_region["Cluster_Label"].unique()],
        key="filtro_cl3d"
    )

    df_plot = df_region if cluster_focus == "Todos" else df_region[df_region["Cluster_Label"] == cluster_focus]

    # Limpieza de etiquetas para asegurar coincidencia exacta
    df_plot["Cluster_Label"] = df_plot["Cluster_Label"].astype(str).str.strip()

    # Gráfico 3D con colores oficiales
    fig = px.scatter_3d(
        df_plot,
        x="Recency",
        y="Frequency",
        z="Monetary",
        color="Cluster_Label",
        # 🚨 Se usa el nuevo diccionario de colores
        color_discrete_map=colores_k5,
        hover_data=["C_CLIEN", "Recency", "Frequency", "Monetary"],
        opacity=0.75,
        title=f"Segmentación RFM en 3D – Región {region}"
    )

    fig.update_traces(marker=dict(size=4))
    fig.update_layout(
        scene=dict(
            xaxis_title='Recency',
            yaxis_title='Frequency',
            zaxis_title='Monetary'
        ),
        legend_title="Clúster",
        margin=dict(l=0, r=0, b=0, t=40)
    )

    st.plotly_chart(fig, use_container_width=True)

with tab12:
    st.subheader("🧬 Mapa de Correlación – RFM y Variables Predictivas")
    st.caption(f"Analiza la relación entre las métricas RFM y las probabilidades de evolución de los clientes para la región **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # 🚨 Se usan los nuevos nombres de columnas predictivas
    variables_corr = ["Recency", "Frequency", "Monetary", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce"]

    # Limpieza y validación de datos
    df_corr = df_region[variables_corr].apply(pd.to_numeric, errors="coerce").dropna()

    if df_corr.empty:
        st.warning("⚠️ No hay suficientes datos válidos para construir la matriz de correlación.")
    else:
        matriz_corr = df_corr.corr()

        fig = go.Figure(data=go.Heatmap(
            z=matriz_corr.values,
            x=matriz_corr.columns,
            y=matriz_corr.index,
            colorscale='Bluered',
            zmin=-1,
            zmax=1,
            showscale=True
        ))

        fig.update_layout(
            title=f"Mapa de Correlación – {region}",
            xaxis_nticks=len(matriz_corr.columns),
            yaxis_nticks=len(matriz_corr.columns),
            autosize=True,
            margin=dict(l=50, r=50, b=50, t=50)
        )

        # Añadir anotaciones de texto
        for i in range(len(matriz_corr.index)):
            for j in range(len(matriz_corr.columns)):
                fig.add_annotation(
                    x=matriz_corr.columns[j],
                    y=matriz_corr.index[i],
                    text=f"{matriz_corr.iloc[i, j]:.2f}",
                    showarrow=False,
                    font=dict(color='black' if np.abs(matriz_corr.iloc[i, j]) < 0.5 else 'white')
                )

        st.plotly_chart(fig, use_container_width=True)

        # 🧠 Interpretación automática
        st.markdown("### 🧠 Interpretación inicial:")

        # 🚨 Análisis de correlación de ascenso a Oro
        top_corr_ascenso = matriz_corr["Probabilidad_Ascenso_Oro"].drop("Probabilidad_Ascenso_Oro").sort_values(ascending=False)
        mejor_factor_ascenso = top_corr_ascenso.idxmax()
        valor_max_ascenso = top_corr_ascenso.max()
        st.info(f"🏆 La métrica más correlacionada con la **probabilidad de ascenso a Oro** es **{mejor_factor_ascenso}** (`{valor_max_ascenso:.2f}`). Esto revela un patrón clave para campañas de up-selling y escalamiento.")

        # 🚨 Análisis de correlación de caída a Bronce
        top_corr_caida = matriz_corr["Probabilidad_Descenso_Bronce"].drop("Probabilidad_Descenso_Bronce").sort_values(ascending=False)
        mejor_factor_caida = top_corr_caida.idxmax()
        valor_max_caida = top_corr_caida.max()
        st.warning(f"📉 La métrica más correlacionada con la **probabilidad de caída a Bronce** es **{mejor_factor_caida}** (`{valor_max_caida:.2f}`). Identifica el factor principal de riesgo para campañas de retención o reactivación.")

# 🚨 Nueva función para la interpretación del gráfico de radar
def interpretar_radar_rfm(df, region):
    st.markdown("### 🧠 Interpretación de los Perfiles RFM")
    st.markdown("Cada eje del gráfico de radar representa una métrica RFM normalizada. Cuanto más cerca del borde, mayor es el valor promedio del clúster para esa métrica.")

    perfiles = df.groupby("Cluster_Label")[["Recency", "Frequency", "Monetary"]].mean()

    st.markdown("---")
    st.markdown("#### **Perfil Diamante (Máximo Valor y Lealtad)**")
    st.markdown("🌟 **Recency Baja:** Sus clientes han comprado muy recientemente.")
    st.markdown("🌟 **Frequency Alta:** Tienen un alto número de compras repetidas.")
    st.markdown("🌟 **Monetary Alta:** Generan el mayor valor de ingresos por cliente.")
    st.markdown("Este segmento es la base de clientes más valiosa y leal. La estrategia debe ser la **fidelización extrema** y la **anticipación de sus necesidades** para asegurar su permanencia.")

    st.markdown("---")
    st.markdown("#### **Perfil Oro (Alto Valor)**")
    st.markdown("📈 **Recency Baja:** Compran con regularidad y están activos.")
    st.markdown("📈 **Frequency Alta:** Tienen un buen historial de compras.")
    st.markdown("📈 **Monetary Alta:** Su gasto promedio es significativamente alto.")
    st.markdown("Son la segunda base más valiosa. El objetivo es convertirlos en clientes **'Diamante'** a través de **programas VIP y atención personalizada**.")

    st.markdown("---")
    st.markdown("#### **Perfil Plata (Frecuencia Media)**")
    st.markdown("🔄 **Recency Media:** Su última compra no es tan reciente, pero tampoco muy lejana.")
    st.markdown("🔄 **Frequency Media:** Compran con una frecuencia moderada.")
    st.markdown("🔄 **Monetary Media:** El gasto por cliente es estable y no alcanza los valores más altos.")
    st.markdown("Este segmento tiene un gran potencial de crecimiento. La estrategia es **impulsar la recurrencia** y el **up-selling** con promociones y recordatorios segmentados.")

    st.markdown("---")
    st.markdown("#### **Perfil Cobre (En Riesgo)**")
    st.markdown("⚠️ **Recency Alta:** Ha pasado mucho tiempo desde su última compra.")
    st.markdown("⚠️ **Frequency Baja:** Suelen tener pocas compras.")
    st.markdown("⚠️ **Monetary Baja:** El valor total de su gasto no es muy alto.")
    st.markdown("Este segmento se encuentra en un punto crítico, con alto riesgo de abandono. Las campañas deben centrarse en la **retención proactiva** y la **reactivación** con ofertas de valor cruzado.")

    st.markdown("---")
    st.markdown("#### **Perfil Bronce (Bajo Valor/Inactivos)**")
    st.markdown("💔 **Recency Muy Alta:** Son clientes inactivos o que han dejado de comprar.")
    st.markdown("💔 **Frequency Baja:** El número de compras es muy bajo.")
    st.markdown("💔 **Monetary Baja:** Tienen el menor gasto acumulado.")
    st.markdown("Son clientes de bajo valor. Las campañas deben ser de **reactivación masiva** con ofertas agresivas para intentar recuperarlos.")


# --- Bloque corregido para tab13 ---
with tab13:
    st.subheader("🧭 Perfil Comparativo por Clúster (RFM)")
    st.caption(f"Compara visualmente los promedios normalizados de las métricas RFM por segmento para la región **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    variables = ["Recency", "Frequency", "Monetary"]
    df_radar = df_region.groupby("Cluster_Label")[variables].mean().reset_index()

    # Normalización entre 0 y 1 para el radar
    df_norm = df_radar.copy()
    for var in variables:
        min_val = df_radar[var].min()
        max_val = df_radar[var].max()
        rango = max_val - min_val + 1e-8
        df_norm[var] = (df_radar[var] - min_val) / rango

    # 🎯 Radar Plot
    fig = go.Figure()
    # 🚨 Se actualiza el diccionario de colores para los 5 clústeres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }
    # 🚨 Se actualiza el orden de los clústeres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    df_norm["Cluster_Label"] = pd.Categorical(df_norm["Cluster_Label"], categories=orden, ordered=True)
    df_norm = df_norm.sort_values("Cluster_Label")

    for _, row in df_norm.iterrows():
        fig.add_trace(go.Scatterpolar(
            r=row[variables].values,
            theta=variables,
            fill='toself',
            name=row['Cluster_Label'],
            line=dict(color=colores_k5.get(row['Cluster_Label'], "#888"))
        ))

    fig.update_layout(
        polar=dict(radialaxis=dict(visible=True, range=[0, 1])),
        title=f"Perfiles Normalizados por Clúster – {region}",
        showlegend=True,
        margin=dict(t=50, l=0, r=0, b=0)
    )
    st.plotly_chart(fig, use_container_width=True)

    # 🧠 Interpretación automática
    interpretar_radar_rfm(df_region, region)

# 🚨 Nueva función de interpretación comparativa
def interpretar_comparativa_regional(df):
    st.markdown("### 🧠 Análisis Comparativo Automático")

    # Aseguramos que las columnas existen para evitar errores
    if "Región" not in df.columns or "Cantidad" not in df.columns or "Monto_Total" not in df.columns:
        st.error("Error: Las columnas 'Región', 'Cantidad' o 'Monto_Total' no se encuentran en el DataFrame.")
        return

    df_tac = df[df["Región"] == "Tacna"]
    df_moq = df[df["Región"] == "Moquegua"]

    st.markdown("---")
    st.markdown("#### **Análisis de Clientes (Cantidad)**")

    total_tac = df_tac["Cantidad"].sum()
    total_moq = df_moq["Cantidad"].sum()
    st.info(f"👉 **Tacna** tiene un total de **{total_tac} clientes**, mientras que **Moquegua** tiene **{total_moq} clientes**.")

    if total_tac > total_moq:
        st.success(f"Tacna tiene una base de clientes más grande, lo que sugiere una mayor presencia de mercado.")
    elif total_moq > total_tac:
        st.success(f"Moquegua tiene una base de clientes más grande, indicando una mayor penetración en esa región.")
    else:
        st.info("Ambas regiones tienen un número similar de clientes.")

    st.markdown("---")
    st.markdown("#### **Análisis de Valor Monetario**")

    total_monto_tac = df_tac["Monto_Total"].sum()
    total_monto_moq = df_moq["Monto_Total"].sum()
    st.info(f"👉 El valor total de ingresos en **Tacna** es de **S/ {total_monto_tac:.2f}**, y en **Moquegua** es de **S/ {total_monto_moq:.2f}**.")

    if total_monto_tac > total_monto_moq:
        st.success("A pesar de la base de clientes, Tacna genera un mayor volumen de ingresos total.")
    elif total_monto_moq > total_monto_tac:
        st.success("Moquegua es la región que genera el mayor volumen de ingresos total.")
    else:
        st.info("Ambas regiones generan un valor monetario similar.")

    st.markdown("---")
    st.markdown("#### **Análisis de Ticket Promedio**")

    # Se calcula el ticket promedio global para cada región
    ticket_promedio_tac = df_tac["Monto_Total"].sum() / df_tac["Cantidad"].sum() if df_tac["Cantidad"].sum() > 0 else 0
    ticket_promedio_moq = df_moq["Monto_Total"].sum() / df_moq["Cantidad"].sum() if df_moq["Cantidad"].sum() > 0 else 0
    st.info(f"👉 El ticket promedio global es de **S/ {ticket_promedio_tac:.2f}** en Tacna y **S/ {ticket_promedio_moq:.2f}** en Moquegua.")

    if ticket_promedio_tac > ticket_promedio_moq:
        st.success("El ticket promedio por cliente es más alto en Tacna, lo que sugiere clientes con mayor capacidad de gasto.")
    elif ticket_promedio_moq > ticket_promedio_tac:
        st.success("El ticket promedio por cliente es más alto en Moquegua, lo que indica que los clientes gastan más por transacción.")
    else:
        st.info("El ticket promedio es similar en ambas regiones.")


# --- Bloque corregido para tab14 ---
with tab14:
    st.subheader("⚖️ Diagnóstico Comparativo entre Regiones")
    st.caption("Analiza cómo se comportan los segmentos RFM entre Tacna y Moquegua en términos de volumen, valor monetario y ticket promedio.")

    # Asegúrate de tener los DataFrames df_tac y df_moq definidos globalmente o pasados
    # de lo contrario, esto fallará. Asumiendo que están definidos.
    # df_tac = ...
    # df_moq = ...

    # 🔍 Agrupación por región y clúster
    resumen_tac = df_tac.groupby("Cluster_Label").agg(
        Cantidad=("C_CLIEN", "count"),
        Monto_Total=("Monetary", "sum"),
        Ticket_Promedio=("Monetary", "mean")
    ).reset_index()
    resumen_tac["Región"] = "Tacna"

    resumen_moq = df_moq.groupby("Cluster_Label").agg(
        Cantidad=("C_CLIEN", "count"),
        Monto_Total=("Monetary", "sum"),
        Ticket_Promedio=("Monetary", "mean")
    ).reset_index()
    resumen_moq["Región"] = "Moquegua"

    resumen_total = pd.concat([resumen_tac, resumen_moq], ignore_index=True)

    # 🚨 Se actualiza el orden de los clústeres a 5
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    # Filtra los clústeres que no existen en el DataFrame antes de crear la categoría
    resumen_total_filtered = resumen_total[resumen_total["Cluster_Label"].isin(orden)]
    resumen_total_filtered["Cluster_Label"] = pd.Categorical(resumen_total_filtered["Cluster_Label"], categories=orden, ordered=True)
    resumen_total_filtered = resumen_total_filtered.sort_values(["Cluster_Label", "Región"])


    # 🎨 Gráfico: Distribución de clientes por clúster y región
    st.markdown("### 📊 Distribución de Clientes por Clúster")
    fig1 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Cantidad",
        color="Región",
        barmode="group",
        text="Cantidad",
        title="Cantidad de Clientes por Clúster y Región",
        color_discrete_sequence=px.colors.qualitative.Set2
    )
    st.plotly_chart(fig1, use_container_width=True)

    # 💰 Gráfico: Monto total por clúster y región
    st.markdown("### 💰 Valor Monetario Total por Clúster")
    fig2 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Monto_Total",
        color="Región",
        barmode="group",
        text_auto=".2s",
        title="Suma Total de Consumo por Región y Clúster",
        color_discrete_sequence=px.colors.qualitative.Set3
    )
    st.plotly_chart(fig2, use_container_width=True)

    # 🎟️ Gráfico: Ticket promedio
    st.markdown("### 🎟️ Ticket Promedio por Clúster")
    fig3 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Ticket_Promedio",
        color="Región",
        barmode="group",
        text_auto=".2f",
        title="Comparación de Ticket Promedio",
        color_discrete_sequence=px.colors.qualitative.Safe
    )
    st.plotly_chart(fig3, use_container_width=True)

    # 📑 Tabla resumen y exportación
    st.markdown("### 🧾 Tabla Resumen Gerencial")
    resumen_formato = resumen_total_filtered.copy()
    resumen_formato["Ticket_Promedio"] = resumen_formato["Ticket_Promedio"].round(2)
    resumen_formato["Monto_Total"] = resumen_formato["Monto_Total"].round(2)
    st.dataframe(resumen_formato, use_container_width=True)

    # 🧠 Interpretación comparativa automática
    interpretar_comparativa_regional(resumen_total_filtered)

    # 📥 Botón de descarga Excel
    excel_buf = io.BytesIO()
    resumen_formato.to_excel(excel_buf, index=False)
    excel_buf.seek(0)

    st.download_button(
        "📥 Descargar Comparativa Regional",
        data=excel_buf,
        file_name="Comparativa_Regional_Tacna_vs_Moquegua.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

def cargar_csv_desde_zip(region_slug):
    """Función simulada para cargar datos de ventas.
    En una implementación real, se adaptaría."""
    try:
        df_ventas = pd.read_csv("clientes_segmentados_moquegua.csv")
        df_ventas = df_ventas.rename(columns={"Monetary": "TOTAL_VENTA", "Recency": "FECHA"})
        df_ventas["FECHA"] = pd.to_datetime(df_ventas["FECHA"], unit="D", origin="2024-01-01")
        return df_ventas
    except FileNotFoundError:
        st.error(f"❌ No se encontró el archivo de ventas para la región {region_slug}.")
        return None

with tab15:
    st.subheader("📆 Evolución Mensual de Clientes y Predicción Estratégica")
    st.caption(f"Evalúa el comportamiento mensual de clientes en la región **{region}** según perfil predictivo.")

    region_slug = region.lower()
    df_ventas = cargar_csv_desde_zip(region_slug)

    if df_ventas is None:
        st.stop()
    else:
        st.success(f"✅ Datos cargados correctamente para {region}")

    df_ventas["FECHA"] = pd.to_datetime(df_ventas["FECHA"], errors="coerce")
    fechas_validas = df_ventas["FECHA"].notna().sum()
    st.caption(f"🗓️ Fechas válidas detectadas: {fechas_validas:,}")
    if fechas_validas == 0:
        st.error("❌ Ninguna fecha válida fue detectada en los datos de ventas.")
        st.stop()

    df_ventas["PERIODO_MES"] = df_ventas["FECHA"].dt.to_period("M").astype(str)

    df_cluster = df_tac.copy() if region == "Tacna" else df_moq.copy()
    df_ventas["C_CLIEN"] = df_ventas["C_CLIEN"].astype(str)
    df_cluster["C_CLIEN"] = df_cluster["C_CLIEN"].astype(str)

    # 🚨 Corrección: Asegura que las columnas de probabilidad existan antes de usarlas.
    # Esto maneja el caso donde el archivo de datos original no las tiene.
    if "Probabilidad_Ascenso_Oro" not in df_cluster.columns and "Probabilidad_Ascenso" in df_cluster.columns:
        df_cluster = df_cluster.rename(columns={"Probabilidad_Ascenso": "Probabilidad_Ascenso_Oro"})

    if "Probabilidad_Descenso_Bronce" not in df_cluster.columns and "Probabilidad_Bronce" in df_cluster.columns:
        df_cluster = df_cluster.rename(columns={"Probabilidad_Bronce": "Probabilidad_Descenso_Bronce"})

    df_cluster["Probabilidad_Ascenso_Oro"] = pd.to_numeric(df_cluster["Probabilidad_Ascenso_Oro"], errors="coerce")
    df_cluster["Probabilidad_Descenso_Bronce"] = pd.to_numeric(df_cluster["Probabilidad_Descenso_Bronce"], errors="coerce")

    df_full = df_ventas.merge(df_cluster, on="C_CLIEN", how="inner")
    st.write(f"🔍 Registros tras el merge: {len(df_full):,}")
    if df_full.empty:
        st.warning("⚠️ No hay coincidencias entre ventas y clustering.")
        st.stop()

    def clasificar_segmento(row):
        if row["Probabilidad_Ascenso_Oro"] >= 0.8 and row["Probabilidad_Descenso_Bronce"] <= 0.3:
            return "Cliente Estrella"
        elif row["Probabilidad_Ascenso_Oro"] < 0.5 and row["Probabilidad_Descenso_Bronce"] >= 0.7:
            return "Riesgo de Abandono"
        elif 0.5 <= row["Probabilidad_Ascenso_Oro"] < 0.8 and 0.3 < row["Probabilidad_Descenso_Bronce"] < 0.7:
            return "Zona de Desarrollo"
        else:
            return "Segmento Estable"

    df_full["Segmento Estratégico"] = df_full.apply(clasificar_segmento, axis=1)

    periodos_disponibles = sorted(df_full["PERIODO_MES"].dropna().unique())
    if len(periodos_disponibles) == 0:
        st.warning("⚠️ No hay periodos válidos tras la fusión.")
        st.stop()

    periodo_ini, periodo_fin = st.select_slider(
        "Selecciona el rango de meses a analizar:",
        options=periodos_disponibles,
        value=(periodos_disponibles[0], periodos_disponibles[-1])
    )
    df_full = df_full[df_full["PERIODO_MES"].between(periodo_ini, periodo_fin)]

    resumen_mensual = df_full.groupby("PERIODO_MES").agg(
        Prom_Ascenso=("Probabilidad_Ascenso_Oro", "mean"),
        Prom_Caida=("Probabilidad_Descenso_Bronce", "mean"),
        Total_Clientes=("C_CLIEN", "nunique")
    ).reset_index()

    fig1 = go.Figure()
    fig1.add_trace(go.Scatter(x=resumen_mensual["PERIODO_MES"], y=resumen_mensual["Prom_Ascenso"],
                              name='Prob. Ascenso a Oro', mode='lines+markers', line=dict(color="green")))
    fig1.add_trace(go.Scatter(x=resumen_mensual["PERIODO_MES"], y=resumen_mensual["Prom_Caida"],
                              name='Prob. Caída a Bronce', mode='lines+markers', line=dict(color="firebrick")))
    fig1.update_layout(title="📈 Probabilidad Predictiva Promedio Mensual", xaxis_title="Mes", yaxis_title="Probabilidad")
    st.plotly_chart(fig1, use_container_width=True)

    if "Recency" in df_full.columns:
        df_full["Recency"] = pd.to_numeric(df_full["Recency"], errors="coerce")
        recency_mensual = df_full.groupby("PERIODO_MES")["Recency"].mean().reset_index()

        fig_rec = go.Figure()
        fig_rec.add_trace(go.Scatter(
            x=recency_mensual["PERIODO_MES"],
            y=recency_mensual["Recency"],
            mode='lines+markers',
            line=dict(color="royalblue")
        ))
        fig_rec.update_layout(
            title="📉 Recencia Promedio (días sin compra)",
            xaxis_title="Mes",
            yaxis_title="Días sin Compra"
        )
        st.plotly_chart(fig_rec, use_container_width=True)

    st.markdown("### 🧭 Evolución de Segmento Estratégico")
    dist_segmento = df_full.groupby(["PERIODO_MES", "Segmento Estratégico"]).agg(
        Cantidad=("C_CLIEN", "nunique")
    ).reset_index()
    total_mes = df_full.groupby("PERIODO_MES")["C_CLIEN"].nunique().reset_index(name="Total")
    dist_segmento = dist_segmento.merge(total_mes, on="PERIODO_MES")
    dist_segmento["%"] = 100 * dist_segmento["Cantidad"] / dist_segmento["Total"]

    fig2 = px.area(
        dist_segmento,
        x="PERIODO_MES", y="%", color="Segmento Estratégico",
        groupnorm="percent",
        color_discrete_sequence=px.colors.qualitative.Pastel,
        title="📊 Distribución de Segmentos Estratégicos por Mes"
    )
    st.plotly_chart(fig2, use_container_width=True)

    with st.expander("🧠 Ver interpretación de tendencias"):
        if not resumen_mensual.empty:
            mes_max = resumen_mensual.loc[resumen_mensual["Prom_Ascenso"].idxmax(), "PERIODO_MES"]
            max_asc = resumen_mensual["Prom_Ascenso"].max()
            mes_min = resumen_mensual.loc[resumen_mensual["Prom_Caida"].idxmin(), "PERIODO_MES"]
            min_caida = resumen_mensual["Prom_Caida"].min()
            top_seg = dist_segmento.groupby("Segmento Estratégico")["Cantidad"].sum().idxmax()

            st.markdown(f"- 🟢 Mayor ascenso promedio a Oro: **{mes_max}** (`{max_asc:.2f}`)")
            st.markdown(f"- ✅ Menor riesgo de caída a Bronce: **{mes_min}** (`{min_caida:.2f}`)")
            st.markdown(f"- 📌 Segmento más frecuente: **{top_seg}**")
        else:
            st.info("No hay datos suficientes en el rango de fechas seleccionado.")

    excel_buf = io.BytesIO()
    resumen_mensual.to_excel(excel_buf, index=False)
    excel_buf.seek(0)

    st.download_button(
        label="📤 Descargar Excel de Evolución Mensual",
        data=excel_buf,
        file_name=f"Evolucion_Predictiva_{region}.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

    with st.expander("🔎 Consulta de comportamiento por cliente específico"):
        clientes_disponibles = sorted(df_full["C_CLIEN"].unique())

        if not clientes_disponibles:
            st.info("No hay clientes disponibles en el período y región seleccionados.")
        else:
            cod_cliente = st.selectbox(
                "Selecciona un cliente:",
                clientes_disponibles,
                key="cliente_selector"
            )

            df_cliente = df_full[df_full["C_CLIEN"] == cod_cliente]

            if df_cliente.empty:
                st.warning("⚠️ Cliente no encontrado en los datos actuales.")
            else:
                st.markdown(f"### 📌 Evolución mensual para cliente **{cod_cliente}**")

                fig_ind = go.Figure()
                fig_ind.add_trace(go.Scatter(
                    x=df_cliente["PERIODO_MES"],
                    y=df_cliente["Probabilidad_Ascenso_Oro"],
                    name="Prob. Ascenso a Oro",
                    mode="lines+markers",
                    line=dict(color="green")
                ))
                fig_ind.add_trace(go.Scatter(
                    x=df_cliente["PERIODO_MES"],
                    y=df_cliente["Probabilidad_Descenso_Bronce"],
                    name="Prob. Caída a Bronce",
                    mode="lines+markers",
                    line=dict(color="firebrick")
                ))
                fig_ind.update_layout(
                    xaxis_title="Mes",
                    yaxis_title="Probabilidad",
                    title="📈 Perfil predictivo individual por mes"
                )
                st.plotly_chart(fig_ind, use_container_width=True)

                if "Recency" in df_cliente.columns and df_cliente["Recency"].notna().any():
                    fig_ind_rec = go.Figure()
                    fig_ind_rec.add_trace(go.Scatter(
                        x=df_cliente["PERIODO_MES"],
                        y=df_cliente["Recency"],
                        mode="lines+markers",
                        name="Recency",
                        line=dict(color="royalblue")
                    ))
                    fig_ind_rec.update_layout(
                        title="📉 Recencia mensual (días sin compra)",
                        xaxis_title="Mes",
                        yaxis_title="Días sin Compra"
                    )
                    st.plotly_chart(fig_ind_rec, use_container_width=True)

                buf_cliente = io.BytesIO()
                df_export = df_cliente[["PERIODO_MES", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce", "Recency"]].copy()
                df_export.columns = ["Mes", "Probabilidad de Ascenso a Oro", "Probabilidad de Caída a Bronce", "Recencia (días)"]
                df_export.to_excel(buf_cliente, index=False)
                buf_cliente.seek(0)

                st.download_button(
                    label="📤 Descargar historial de este cliente",
                    data=buf_cliente,
                    file_name=f"Historial_Cliente_{cod_cliente}_{region}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )

                st.caption("Puedes comparar estas curvas con el promedio regional para detectar oportunidades de intervención temprana.")

with tab16:
    st.subheader("📌 Estrategias Sugeridas por Clúster")
    st.caption(f"Estrategias basadas en la distribución actual de clientes en **{region}**")

    # 🔍 Selección dinámica del DataFrame según región
    # Asegúrate de que df_tac y df_moq están definidos en el ámbito global o en el contexto de tu aplicación Streamlit
    try:
        df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    except NameError:
        st.error("Error: Los DataFrames 'df_tac' o 'df_moq' no están definidos. Asegúrate de cargarlos previamente.")
        st.stop()

    df_region["Cluster_Label"] = df_region["Cluster_Label"].fillna("Desconocido")
    total = df_region["C_CLIEN"].nunique()

    # 🚨 Se actualiza el orden y la paleta para 5 clústeres
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "blue",
        "Oro": "gold",
        "Plata": "silver",
        "Cobre": "#B87333",
        "Bronce": "brown"
    }

    # 🧮 Conteo por segmento
    conteo = df_region.groupby("Cluster_Label")["C_CLIEN"].nunique().reindex(orden_clusters).fillna(0).astype(int)

    st.markdown("### 📊 Distribución actual de clientes")

    col1, col2, col3, col4, col5, col6 = st.columns(6)
    col1.metric("👥 Totales", f"{total:,}")
    col2.metric("💎 Diamante", f"{conteo['Diamante']:,}")
    col3.metric("🟡 Oro", f"{conteo['Oro']:,}")
    col4.metric("⚪ Plata", f"{conteo['Plata']:,}")
    col5.metric("🟠 Cobre", f"{conteo['Cobre']:,}")
    col6.metric("🟤 Bronce", f"{conteo['Bronce']:,}")

    st.markdown("---")
    st.markdown("🧠 Estas recomendaciones se basan en el perfil de valor y comportamiento transaccional de cada clúster:")

    col1, col2 = st.columns(2)
    with col1:
        st.markdown("### 💎 Diamante")
        st.success("Clientes de máximo valor y lealtad")
        st.markdown("""
- 🤝 **Relación exclusiva:** Trato preferencial, acceso a eventos privados.
- 🎁 **Servicios a medida:** Ofertas personalizadas, productos exclusivos.
- 💬 **Feedback directo:** Considerar sus opiniones para la mejora del negocio.
- 🎉 **Celebraciones:** Felicitaciones en fechas especiales, detalles de alto valor.
""")

    with col2:
        st.markdown("### 🟡 Oro")
        st.info("Clientes muy valiosos y recurrentes")
        st.markdown("""
- 🥇 **Up-selling:** Incentivos para aumentar su ticket promedio.
- 🎁 **Recompensas VIP:** Programas de lealtad por puntos, beneficios tangibles.
- 📞 **Atención preferente:** Canal de soporte rápido y eficaz.
- 🛒 **Recomendaciones:** Productos complementarios que ya son de su interés.
""")

    st.markdown("---")

    col1, col2 = st.columns(2)
    with col1:
        st.markdown("### ⚪ Plata")
        st.info("Clientes con potencial de crecimiento")
        st.markdown("""
- 📈 **Activación de frecuencia:** Cupones o descuentos por compras repetidas.
- 💡 **Recomendaciones:** Sugerir productos con buen margen para aumentar el valor.
- 📧 **Comunicación constante:** Newsletters con contenido de valor y promociones.
- 🛍️ **Bundles de productos:** Ofertas por la compra de paquetes de productos.
""")

    with col2:
        st.markdown("### 🟠 Cobre")
        st.warning("Clientes con riesgo de inactividad")
        st.markdown("""
- 🔄 **Reactivación:** Campañas de email/SMS/WhatsApp para traerlos de vuelta.
- 🎁 **Ofertas agresivas:** Descuentos o promociones exclusivas para su siguiente compra.
- 🔎 **Identificación de dolor:** Encuestas para entender por qué bajó su frecuencia.
- ⏳ **Urgency marketing:** Ofertas de tiempo limitado para motivar la compra.
""")

    st.markdown("---")
    st.markdown("### 🟤 Bronce")
    st.warning("Clientes inactivos o de bajo valor")
    st.markdown("""
- 📉 **Coste-efectividad:** No invertir grandes recursos, enfocarse en campañas masivas.
- 🎯 **Ofertas de entrada:** Promociones muy bajas para una primera (o segunda) compra.
- 🗑️ **Limpieza de base:** Considerar su eliminación de listas de marketing si no hay respuesta.
- 📣 **Awareness:** Mantener la marca en su mente con contenido de bajo coste.
""")


    st.markdown("---")
    st.caption("Estas estrategias están alineadas con el análisis RFM y patrones históricos de clientes en cada región.")

    # 🔮 Recomendaciones predictivas por perfil
    st.markdown("### 🧭 Recomendaciones según Cuadrante Estratégico (Predicción de Evolución)")

    with st.expander("📉 Ver estrategias por perfil de riesgo y ascenso"):
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### 🟢 Cliente Estrella")
            st.success("Alta probabilidad de ascenso, bajo riesgo de caída")
            st.markdown("""
- 🎯 **Activación inmediata de beneficios:** Activar beneficios 'Oro' o 'Diamante'.
- 🛍️ **Ofertas personalizadas:** Incentivar la recompra con productos exclusivos.
- 🧠 **Feedback directo:** Recopilar sus opiniones para mejorar la experiencia.
- 🪄 **Recomendaciones cruzadas:** Sugerir productos de alto valor que aún no ha probado.
""")

            st.markdown("### 🟡 Zona de Desarrollo")
            st.info("Valores intermedios, potencial latente")
            st.markdown("""
- 🤝 **Acompañamiento:** Campañas educativas sobre el uso de otros productos.
- 📈 **Probar upgrades:** Ofrecer descuentos para motivar compras de mayor valor.
- 💬 **Encuestas o dinámicas:** Activar su interés con contenido interactivo.
- 📊 **Monitoreo periódico:** Evaluar su evolución de clúster trimestralmente.
""")

        with col2:
            st.markdown("### 🔴 Riesgo de Abandono")
            st.warning("Alta probabilidad de caída")
            st.markdown("""
- 🚨 **Campañas urgentes de retención:** Incentivos agresivos para una compra inmediata.
- 🧲 **Incentivos de regreso:** Ofrecer cupones de alto valor o descuentos significativos.
- 📞 **Llamadas o mensajes directos:** Contacto personal para recuperar al cliente.
- 🔍 **Evaluación de fricciones:** Analizar si hubo un problema o mala experiencia de servicio.
""")

            st.markdown("### ⚪ Segmento Estable")
            st.info("Bajo ascenso y bajo riesgo")
            st.markdown("""
- 🤖 **Automatización de marketing:** Mantenerlos informados con newsletters y contenido.
- 🔄 **Reforzar el awareness:** Recordar la marca con contenido útil y relevante.
- 🧭 **Potencial de activación:** Promociones selectivas para motivar la compra.
- ⏱️ **Revisión trimestral:** Monitorear su comportamiento para detectar cambios.
""")

        st.caption("Basado en la matriz predictiva de ascenso a **Oro** y caída a **Bronce** desarrollada en la pestaña de evolución.")

with tab17:
    st.subheader("📘 Manual de Navegación y Uso Estratégico")
    st.caption("Recomendaciones para interpretar, navegar y aprovechar al máximo el dashboard.")

    with st.expander("� ¿Cuál es el objetivo general del dashboard?"):
        st.markdown("""
Este sistema fue diseñado para **explorar, segmentar, predecir y activar estrategias** sobre clientes a partir de información transaccional, con enfoque regional en **Tacna** y **Moquegua**.

- Aplica análisis RFM (Recency, Frequency, Monetary)
- Integra **clustering de 5 segmentos** y análisis de evolución
- Permite exportación y activación de campañas
""")

    with st.expander("🧭 ¿Cómo está estructurado el dashboard?"):
        st.markdown("""
- **Tabs 1–5:** Validación inicial de clústeres y métricas RFM
- **Tabs 6–8:** Identificación, alerta y predicción de comportamiento
- **Tabs 9–11:** Exploración de distribución por variable y segmento
- **Tabs 12–14:** Correlación, perfiles y comparativa regional
- **Tab 15:** Evolución temporal estratégica de clientes
- **Tab 16:** Recomendaciones estratégicas
- **Tab 17:** Esta guía interactiva
""")

    with st.expander("💡 ¿Qué buenas prácticas debo seguir?"):
        st.markdown("""
- Selecciona siempre la **región** antes de explorar
- Ajusta los **umbrales de riesgo y ascenso** según el escenario
- Exporta datos con los botones 📥 donde estén disponibles
- Revisa las interpretaciones bajo expanders 🧠 para mayor contexto
""")

    with st.expander("📎 ¿Qué tipo de campañas se recomiendan según el perfil del cliente?"):
        st.markdown("""
- 💎 **Diamante:** Fidelización extrema y servicios exclusivos.
- 🟡 **Oro:** Fidelización avanzada y beneficios exclusivos.
- ⚪ **Plata:** Incentivo a la frecuencia y seguimiento.
- 🟠 **Cobre:** Intervención proactiva para evitar la inactividad.
- 🟤 **Bronce:** Reactivación o atención cautiva.
- 🧭 **Cliente Estrella:** Activación de recompensas inmediatas.
- 🔴 **Riesgo:** Contacto urgente o incentivo de retención.
- ⚪ **Estables:** Automatización y monitoreo pasivo.
""")

    st.markdown("---")
    st.caption("📌 Esta guía está diseñada para onboarding de analistas, equipos comerciales y responsables regionales.")