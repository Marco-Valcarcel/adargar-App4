# -*- coding: utf-8 -*-
"""app4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGlpDJrQS46Az5I9p71qRZUSioljahMx
"""

import streamlit as st
st.set_page_config(layout="wide")

st.write("‚úÖ App iniciada correctamente ‚Äì Tablero App4")

import seaborn as sns
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import io
from datetime import datetime
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import MiniBatchKMeans
from sklearn.metrics import silhouette_score
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.drawing.image import Image as XLImage
import zipfile, os

def cargar_csv_desde_zip(empresa="adargar", region="tacna"):
    """
    Carga un archivo CSV de ventas desde un archivo ZIP.
    """
    # Construir el nombre del archivo ZIP y del CSV interno
    archivo_zip = f"sales_{empresa.lower()}_{region.lower()}_2024_2025.zip"
    nombre_csv = f"sales_{empresa.lower()}_{region.lower()}_2024_2025.csv"

    # Verificar si el archivo ZIP existe en el directorio de la app
    if not os.path.exists(archivo_zip):
        st.error(f"‚ùå No se encontr√≥ el archivo: {archivo_zip}")
        return None

    try:
        with zipfile.ZipFile(archivo_zip) as zf:
            with zf.open(nombre_csv) as file:
                df = pd.read_csv(file, dtype={"COD_PRO": str})
        return df
    except Exception as e:
        st.error(f"‚ö†Ô∏è Error al leer el archivo {nombre_csv} dentro del ZIP: {e}")
        return None

# üì¶ 1. Cargar datasets de segmentaci√≥n por regi√≥n
df_tac = pd.read_csv("clientes_segmentados_tacna.csv", encoding="utf-8")
df_moq = pd.read_csv("clientes_segmentados_moquegua.csv", encoding="utf-8")

# üßº 2. Corregir formato y encoding
# Los nuevos archivos tienen encabezados y codificaci√≥n correctos.
df_tac.rename(columns=lambda col: col.strip(), inplace=True)
df_moq.rename(columns=lambda col: col.strip(), inplace=True)

# üîÅ 3. Unificar ambos en un solo DataFrame para entrenamiento
rfm = pd.concat([df_tac, df_moq], ignore_index=True)
rfm.columns = rfm.columns.str.strip()

# üß† 4. Entrenamiento predictivo
# Validar columna de cl√∫ster. Ahora el cl√∫ster objetivo es 'Cluster_Label'.
if "Cluster_Label" in rfm.columns:
    y = rfm["Cluster_Label"]
else:
    raise ValueError("‚ö†Ô∏è No se encontr√≥ la columna 'Cluster_Label' para el entrenamiento.")

X = rfm[["Recency", "Frequency", "Monetary"]]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

modelo = RandomForestClassifier(n_estimators=100, random_state=42)
modelo.fit(X_train, y_train)

# üìà 5. Aplicar predicci√≥n y probabilidades
rfm["Cluster_Predicho"] = modelo.predict(X)
rfm["Probabilidades"] = modelo.predict_proba(X).tolist()

# üß≠ 6. Mapear √≠ndices de cl√∫steres
# Crear un mapeo de etiquetas a √≠ndices para las probabilidades
etiquetas_modelo = list(modelo.classes_)
idx_oro = etiquetas_modelo.index("Oro")
idx_bronce = etiquetas_modelo.index("Bronce")
idx_cobre = etiquetas_modelo.index("Cobre")
idx_plata = etiquetas_modelo.index("Plata")
idx_diamante = etiquetas_modelo.index("Diamante")

# üßÆ 7. Calcular probabilidades predictivas
rfm["Probabilidad_Ascenso_Oro"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_oro], 4))
rfm["Probabilidad_Ascenso_Plata"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_plata], 4))
rfm["Probabilidad_Descenso_Cobre"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_cobre], 4))
rfm["Probabilidad_Descenso_Bronce"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_bronce], 4))

# üíæ 8. Actualizar df_tac y df_moq ya enriquecidos con predicci√≥n
df_tac = rfm[rfm["Region"] == "Tacna"].copy()
df_moq = rfm[rfm["Region"] == "Moquegua"].copy()

# üíæ 9. Inicializar st.session_state con los dataframes enriquecidos
if "df_to_display" not in st.session_state:
    st.session_state.df_tac = df_tac
    st.session_state.df_moq = df_moq
    st.session_state.df_to_display = df_tac # Por defecto, mostrar Tacna

# ‚úÖ Validaciones de columnas cr√≠ticas por regi√≥n
assert "Cluster_Label" in df_tac.columns and df_tac["Cluster_Label"].notna().all(), "‚ùå Falta columna o hay valores nulos en df_tac['Cluster_Label']"
assert "Cluster_Label" in df_moq.columns and df_moq["Cluster_Label"].notna().all(), "‚ùå Falta columna o hay valores nulos en df_moq['Cluster_Label']"

for col in ["Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce"]:
    assert col in df_tac.columns and df_tac[col].notna().all(), f"‚ùå Falta columna o hay valores nulos en df_tac['{col}']"
    assert col in df_moq.columns and df_moq[col].notna().all(), f"‚ùå Falta columna o hay valores nulos en df_moq['{col}']"

# üé® Diccionario de colores y estrategias para 5 cl√∫steres
colores_k5 = {
    "Diamante": "#00FFFF",
    "Oro": "#FFD700",
    "Plata": "#C0C0C0",
    "Cobre": "#B87333",
    "Bronce": "#CD7F32"
}

estrategias = {
    "Diamante": "üíé Crecimiento y retenci√≥n: programas de lealtad exclusivos y anticipaci√≥n de necesidades.",
    "Oro": "üìà Fidelizar y potenciar: promociones exclusivas y membres√≠as premium.",
    "Plata": "ü§ù Incentivar y escalar: motivar recurrencia con descuentos personalizados.",
    "Cobre": "üí° Oportunidad de venta: enfoque en productos complementarios y reactivaci√≥n con ofertas de valor.",
    "Bronce": "üß≤ Reactivar: campa√±as de recuperaci√≥n o win-back por inactividad."
}

# üî∑ T√≠tulo central del dashboard
st.markdown("""
    <h1 style='text-align: center; color: #003366; margin-bottom: 0.2em;'>
        Dashboard Predictivo ‚Äì Adargar-Tacna SRL
    </h1>
    <h4 style='text-align: center; color: gray; font-weight: normal; margin-top: 0;'>
        An√°lisis y estrategias por segmento RFM
    </h4>
    <hr style='margin-top: 0.5em; margin-bottom: 1.5em;'>
""", unsafe_allow_html=True)

# üìã Definici√≥n de las 17 pesta√±as del dashboard
tabs = st.tabs([
    "üí† Dispersi√≥n RFM",
    "üìä Estad√≠sticas RFM por Cl√∫ster",
    "üì¶ Distribuci√≥n de Clientes por Segmento",
    "üíº Recomendaciones por Segmento",
    "üìä Boxplots RFM",
    "üèÖ Clientes de Alto Valor",
    "üõéÔ∏è Clientes con Recencia Cr√≠tica por Segmento",
    "üîÆ Predicci√≥n de Evoluci√≥n de Clientes",
    "üìä Histogramas RFM por Cl√∫ster",
    "üéª Densidad y Dispersi√≥n por Cl√∫ster",
    "üåå Scatter 3D RFM por Cl√∫ster",
    "üß¨ Mapa de Correlaci√≥n (RFM & Predicci√≥n)",
    "üß≠ Radar de Perfiles RFM por Cl√∫ster",
    "‚öñÔ∏è Comparativa Regional Tacna vs Moquegua",
    "üìÜ Evoluci√≥n Temporal Estrat√©gica",
    "üìå Recomendaciones Estrat√©gicas",
    "üìò Gu√≠a de Usuario"
])
(tab1, tab2, tab3, tab4, tab5, tab6, tab7, tab8, tab9, tab10,
 tab11, tab12, tab13, tab14, tab15, tab16, tab17) = tabs

# üß† Funci√≥n robusta para ordenar segmentos con validaci√≥n
def ordenar_segmentos_seguro(df_agrupado, orden=None, nombre_var="Cluster_Label"):
    if orden is None:
        orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    if not isinstance(df_agrupado.index, pd.Index):
        st.warning(f"‚ö†Ô∏è El objeto proporcionado no tiene un √≠ndice v√°lido.")
        return df_agrupado

    if not set(orden).issubset(df_agrupado.index):
        st.warning(f"‚ö†Ô∏è Algunos segmentos de {orden} no est√°n presentes en el √≠ndice actual.")
        # Intentar reordenar con los segmentos que s√≠ existen
        presentes = [s for s in orden if s in df_agrupado.index]
        return df_agrupado.reindex(presentes)

    return df_agrupado.reindex(orden)

# üß≠ Layout general y encabezado inicial
# üéõÔ∏è Sidebar profesional
with st.sidebar:
    # Aseg√∫rate de tener el logo de Adargar en la carpeta de tu repositorio
    st.image("logo_adargar.jpg", width=190)

    st.markdown("### üìä App4 ‚Äì Evoluci√≥n Inteligente de Clientes para Adargar-Tacna")
    st.caption("Soluci√≥n dise√±ada por Ing. Marco Valc√°rcel")

    # Selecci√≥n de regi√≥n
    region = st.selectbox(
        "üìç Selecciona regi√≥n",
        ["Tacna", "Moquegua"],
        key="region_selector",
    )

    # --- CORRECCI√ìN CR√çTICA ---
    # Actualizamos el DataFrame en st.session_state cada vez que la regi√≥n cambie
    if region == "Tacna":
        st.session_state.df_to_display = st.session_state.df_tac
    else: # Moquegua
        st.session_state.df_to_display = st.session_state.df_moq

    st.markdown("---")
    st.markdown(f"### üìå Clientes por Nivel ({region})")

    try:
        # Ahora, todas las m√©tricas usan el DataFrame filtrado de st.session_state
        total = st.session_state.df_to_display["C_CLIEN"].nunique()
        diamante = st.session_state.df_to_display.query("Cluster_Label == 'Diamante'")["C_CLIEN"].nunique()
        oro = st.session_state.df_to_display.query("Cluster_Label == 'Oro'")["C_CLIEN"].nunique()
        plata = st.session_state.df_to_display.query("Cluster_Label == 'Plata'")["C_CLIEN"].nunique()
        cobre = st.session_state.df_to_display.query("Cluster_Label == 'Cobre'")["C_CLIEN"].nunique()
        bronce = st.session_state.df_to_display.query("Cluster_Label == 'Bronce'")["C_CLIEN"].nunique()

        st.metric("üü° Total √∫nicos", total)
        st.metric("üíé Diamante", diamante)
        st.metric("üü¢ Oro", oro)
        st.metric("üîµ Plata", plata)
        st.metric("üí° Cobre", cobre)
        st.metric("üü§ Bronce", bronce)
    except Exception as e:
        st.info(f"‚ÑπÔ∏è Las m√©tricas de clientes se activar√°n una vez se cargue el dataframe. Error: {e}")

def interpretar_histograma_rfm(df, variable, region=""):
    """
    Genera una interpretaci√≥n de las m√©tricas RFM (Recencia, Frecuencia, Monetario)
    para cada segmento de clientes, bas√°ndose en el an√°lisis de histogramas.
    Esta funci√≥n ahora utiliza st.session_state para garantizar que la
    interpretaci√≥n se basa en los datos de la regi√≥n seleccionada.

    Args:
        df (pd.DataFrame): Este par√°metro se mantiene por compatibilidad, pero
                          la funci√≥n ahora carga el DataFrame desde st.session_state.
        variable (str): La variable RFM a analizar ('Recency', 'Frequency' o 'Monetary').
        region (str): La regi√≥n a la que corresponden los datos.
    """

    st.markdown(f"### üìå Interpretaci√≥n de la variable **{variable}** en {region}")

    # Usamos el DataFrame del estado de la sesi√≥n para que los datos sean din√°micos
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df
        st.warning("‚ö†Ô∏è No se encontr√≥ 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    # Verificar si la columna existe en el DataFrame para evitar errores
    if variable not in df_a_usar.columns:
        st.error(f"‚ùå La columna '{variable}' no se encuentra en el DataFrame de la regi√≥n.")
        return

    try:
        # üìä Agrupar el DataFrame por segmento y seleccionar la variable de inter√©s
        grupos = df_a_usar.groupby("Cluster_Label")[variable]

        # üìà Iterar sobre cada segmento y calcular m√©tricas estad√≠sticas clave
        for segmento, valores in grupos:
            desc = valores.describe()
            media = desc["mean"]
            mediana = desc["50%"]
            std = desc["std"]
            asimetr√≠a = valores.skew()

            # Evaluar la dispersi√≥n (variabilidad) de los datos
            dispersi√≥n = "alta" if std > valores.mean() * 0.5 else "moderada" if std > 0 else "baja"

            # ‚úçÔ∏è Mostrar las m√©tricas calculadas
            st.markdown(f"#### üéØ Segmento **{segmento}**")
            st.markdown(
                f"- Media: **{media:.2f}**, Mediana: **{mediana:.2f}**"
                f"\n- Desviaci√≥n est√°ndar: **{std:.2f}** ({dispersi√≥n})"
                f"\n- Asimetr√≠a: **{asimetr√≠a:.2f}** {'üî∫ positiva' if asimetr√≠a > 0 else 'üîª negativa' if asimetr√≠a < 0 else '‚öñÔ∏è sim√©trica'}"
            )

            # üß† Generar una interpretaci√≥n basada en el valor de asimetr√≠a y dispersi√≥n
            if asimetr√≠a > 1:
                st.info("Distribuci√≥n sesgada a la derecha: mayor√≠a de valores bajos con algunos muy altos.")
            elif asimetr√≠a < -1:
                st.info("Distribuci√≥n sesgada a la izquierda: mayor√≠a de clientes con valores altos en esta m√©trica.")
            elif dispersi√≥n == "alta":
                st.info("Existe alta variabilidad entre los clientes de este segmento.")
            else:
                st.info("Distribuci√≥n relativamente equilibrada.")
    except Exception as e:
        st.error(f"Ocurri√≥ un error al generar la interpretaci√≥n: {e}")

    st.caption("üí° Esta lectura puede ayudarte a detectar segmentos con outliers o con comportamiento at√≠pico para intervenciones personalizadas.")

def interpretar_histograma_probabilidad(df, columna_probabilidad, region=""):
    """
    Funci√≥n de interpretaci√≥n autom√°tica para cualquier columna de probabilidad.
    Ahora utiliza st.session_state para garantizar que la interpretaci√≥n
    se basa en los datos de la regi√≥n seleccionada en el sidebar.

    Args:
        df (pd.DataFrame): Este par√°metro se mantiene por compatibilidad, pero
                          la funci√≥n ahora carga el DataFrame desde st.session_state.
        columna_probabilidad (str): El nombre de la columna que contiene las probabilidades.
        region (str): La regi√≥n a la que corresponden los datos.
    """
    st.markdown("---")

    # Usamos el DataFrame del estado de la sesi√≥n para que los datos sean din√°micos
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df
        st.warning("‚ö†Ô∏è No se encontr√≥ 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    # Verificar si la columna existe en el DataFrame para evitar errores
    if columna_probabilidad not in df_a_usar.columns:
        st.error(f"‚ùå La columna '{columna_probabilidad}' no se encuentra en el DataFrame de la regi√≥n.")
        return

    # üìä Calcular las m√©tricas estad√≠sticas clave de la columna de probabilidad
    max_prob = df_a_usar[columna_probabilidad].max()
    min_prob = df_a_usar[columna_probabilidad].min()
    media = df_a_usar[columna_probabilidad].mean()
    mediana = df_a_usar[columna_probabilidad].median()

    # ‚úÇÔ∏è Extraer el tipo de probabilidad (Ascenso/Descenso) y el segmento de destino
    partes = columna_probabilidad.replace("Probabilidad_", "").split("_")
    tipo_prob = partes[0]
    segmento_destino = partes[-1]

    st.markdown(f"üß† **Interpretaci√≥n Autom√°tica del Histograma: {tipo_prob} a {segmento_destino}**")

    # üéØ An√°lisis de casos extremos (probabilidad cercana a 1 o 0)
    if np.isclose(max_prob, 1.0):
        st.markdown(f"- üéØ Hay un grupo de clientes con {tipo_prob} asegurado al segmento **{segmento_destino}** (probabilidad ~1.0). Son casos prioritarios para intervenci√≥n inmediata.")
    if np.isclose(min_prob, 0.0):
        st.markdown("- ‚ö†Ô∏è Se detecta una base con probabilidad cero. Revisar si son clientes inactivos o sin historial suficiente.")

    # üìà Interpretaci√≥n basada en las m√©tricas de tendencia central
    st.markdown(f"- üìä En **{region}**, la media de {tipo_prob} es **{media:.2f}** y la mediana es **{mediana:.2f}**."
                f"Esto sugiere{' potencial activo' if media > 0.5 else ' baja disposici√≥n al cambio'} al segmento **{segmento_destino}**.")

    st.caption("üí° Esta lectura puede ayudarte a detectar oportunidades de crecimiento o de riesgo en tu cartera.")

def interpretar_violin_rfm(df, variable, region):
    """
    Genera una interpretaci√≥n autom√°tica y robusta para un gr√°fico de viol√≠n.
    Esta funci√≥n ahora utiliza st.session_state.df_to_display para asegurar
    que la interpretaci√≥n siempre se base en el DataFrame seleccionado.

    Args:
        df (pd.DataFrame): Se mantiene el par√°metro por compatibilidad, pero
                          el DataFrame real se carga desde el estado de la sesi√≥n.
        variable (str): La variable (columna) a interpretar.
        region (str): El nombre de la regi√≥n.
    """
    st.markdown("üß† **Interpretaci√≥n Autom√°tica del Viol√≠n Plot:**")

    # Usamos el DataFrame del estado de la sesi√≥n para que los datos sean din√°micos
    # y se actualicen con los cambios de la barra lateral.
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df
        st.warning("‚ö†Ô∏è No se encontr√≥ 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    try:
        # Agrupamos y forzamos el orden l√≥gico
        resumen_bruto = df_a_usar.groupby("Cluster_Label")[variable].describe()[["mean", "std"]].round(2)
        # La funci√≥n 'ordenar_segmentos_seguro' debe estar definida en tu c√≥digo principal
        # o puedes reemplazarla con una l√≥gica de ordenaci√≥n si es necesario.
        resumen = ordenar_segmentos_seguro(resumen_bruto)

        if resumen is not None and not resumen.empty:
            mayor_media = resumen["mean"].idxmax()
            menor_media = resumen["mean"].idxmin()

            st.markdown(f"- üìç En **{region}**, el cl√∫ster con mayor valor promedio de `{variable}` es **{mayor_media}**.")
            st.markdown(f"- üß≠ El cl√∫ster con menor valor promedio es **{menor_media}**.")

            if resumen["std"].max() > 0.5 * resumen["mean"].max():
                st.markdown("- ‚ö†Ô∏è Hay alta dispersi√≥n en algunos cl√∫steres, indicando comportamiento variado o presencia de outliers.")
            else:
                st.markdown("- ‚úÖ Las distribuciones son consistentes, lo que sugiere que los cl√∫steres est√°n bien definidos en esta variable.")
        else:
            st.warning("‚ö†Ô∏è No se pudo calcular resumen estad√≠stico confiable para esta m√©trica.")

    except Exception as e:
        st.error(f"Ocurri√≥ un error al generar la interpretaci√≥n: {e}")

def ordenar_segmentos_seguro(df_resumen):
    """
    Funci√≥n auxiliar para ordenar los segmentos de un DataFrame de resumen.
    Se incluye para hacer el c√≥digo autocontenido.
    """
    try:
        # Intenta ordenar el √≠ndice si es num√©rico
        df_resumen.index = df_resumen.index.astype(int)
        return df_resumen.sort_index()
    except (ValueError, TypeError):
        # Si no es num√©rico, simplemente ordena alfab√©ticamente
        return df_resumen.sort_index()

def interpretar_kde_rfm(df, variable, region):
    """
    Genera una interpretaci√≥n del gr√°fico KDE para las m√©tricas RFM.
    Esta funci√≥n ahora utiliza st.session_state para garantizar que la
    interpretaci√≥n se basa en los datos de la regi√≥n seleccionada.

    Args:
        df (pd.DataFrame): Este par√°metro se mantiene por compatibilidad, pero
                          la funci√≥n ahora carga el DataFrame desde st.session_state.
        variable (str): La variable RFM a analizar ('Recency', 'Frequency' o 'Monetary').
        region (str): La regi√≥n a la que corresponden los datos.
    """
    st.markdown("---")
    st.markdown("üß† **Interpretaci√≥n Autom√°tica del KDE Plot:**")

    # Usamos el DataFrame del estado de la sesi√≥n para que los datos sean din√°micos
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df
        st.warning("‚ö†Ô∏è No se encontr√≥ 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    # Verificar que las columnas necesarias existen en el DataFrame
    if "Cluster_Label" not in df_a_usar.columns or variable not in df_a_usar.columns:
        st.error(f"‚ùå Las columnas 'Cluster_Label' o '{variable}' no se encuentran en el DataFrame de la regi√≥n.")
        return

    try:
        resumen_bruto = df_a_usar.groupby("Cluster_Label")[variable].describe()[["mean", "std"]].round(2)
        resumen = ordenar_segmentos_seguro(resumen_bruto)

        if resumen is not None and not resumen.empty:
            rangos = resumen["mean"].max() - resumen["mean"].min()
            st.markdown(f"- En **{region}**, los valores medios de `{variable}` por cl√∫ster var√≠an en un rango de **{rangos:.2f}**.")

            if rangos < 0.1 * resumen["mean"].mean():
                st.markdown("- ‚ö†Ô∏è Las curvas KDE se solapan bastante. Puede haber cl√∫steres con comportamiento poco diferenciado en esta variable.")
            else:
                st.markdown("- ‚úÖ Hay buena separaci√≥n entre cl√∫steres en t√©rminos de densidad. La segmentaci√≥n parece s√≥lida.")

            dispersion = resumen["std"].mean()
            if dispersion > 0.3 * resumen["mean"].mean():
                st.markdown(f"- La desviaci√≥n est√°ndar promedio es **{dispersion:.2f}**, lo que indica **alta** dispersi√≥n interna en los grupos.")
            else:
                st.markdown(f"- La desviaci√≥n est√°ndar promedio es **{dispersion:.2f}**, lo que indica **baja** dispersi√≥n interna en los grupos.")
        else:
            st.warning("‚ö†Ô∏è No hay suficientes datos agrupados para interpretar el KDE.")
    except Exception as e:
        st.error(f"‚ùå Error al interpretar el gr√°fico KDE: {e}")

def ordenar_segmentos_seguro(df_resumen):
    """
    Funci√≥n auxiliar para ordenar los segmentos de un DataFrame de resumen.
    Se incluye para hacer el c√≥digo autocontenido.
    """
    try:
        # Intenta ordenar el √≠ndice si es num√©rico
        df_resumen.index = df_resumen.index.astype(int)
        return df_resumen.sort_index()
    except (ValueError, TypeError):
        # Si no es num√©rico, simplemente ordena alfab√©ticamente
        return df_resumen.sort_index()

def interpretar_radar_rfm(df_region, region):
    """
    Genera una interpretaci√≥n del perfil RFM por cl√∫ster, bas√°ndose en los valores
    promedio de Recency, Frequency y Monetary. Esta funci√≥n ahora utiliza
    st.session_state para garantizar que la interpretaci√≥n se basa en los
    datos de la regi√≥n seleccionada.

    Args:
        df_region (pd.DataFrame): Este par√°metro se mantiene por compatibilidad, pero
                                  la funci√≥n ahora carga el DataFrame desde st.session_state.
        region (str): La regi√≥n a la que corresponden los datos.
    """
    st.markdown("---")
    st.markdown("üß† **Interpretaci√≥n del Perfil RFM por Cl√∫ster:**")

    # Usamos el DataFrame del estado de la sesi√≥n para que los datos sean din√°micos
    if 'df_to_display' in st.session_state:
        df_a_usar = st.session_state.df_to_display
    else:
        # En caso de que no exista, usamos el DataFrame pasado como argumento (fallback)
        df_a_usar = df_region
        st.warning("‚ö†Ô∏è No se encontr√≥ 'df_to_display' en st.session_state. Usando el DataFrame por defecto.")

    # Verificar que las columnas necesarias existen en el DataFrame
    required_cols = ["Cluster_Label", "Recency", "Frequency", "Monetary"]
    if not all(col in df_a_usar.columns for col in required_cols):
        st.error(f"‚ùå Faltan una o m√°s columnas requeridas en el DataFrame de la regi√≥n: {required_cols}.")
        return

    try:
        mean_raw = df_a_usar.groupby("Cluster_Label")[["Recency", "Frequency", "Monetary"]].mean().round(1)
        mean_profiles = ordenar_segmentos_seguro(mean_raw)

        if mean_profiles is not None and not mean_profiles.empty:
            # Identificamos cl√∫ster con m√°ximos por m√©trica
            estrella = mean_profiles["Frequency"].idxmax()
            # Para Recency, un valor bajo es mejor, pero el radar plot muestra lo opuesto.
            # La interpretaci√≥n debe ser coherente con el gr√°fico.
            rezagado = mean_profiles["Recency"].idxmax()
            ticket_alto = mean_profiles["Monetary"].idxmax()

            st.markdown(f"- ‚≠ê El segmento **{estrella}** destaca por su **alta frecuencia de compra**.")
            st.markdown(f"- ‚åõ El segmento **{rezagado}** muestra el **mayor tiempo desde la √∫ltima compra (Recency)**, lo que indica clientes menos recientes.")
            st.markdown(f"- üí∞ El segmento **{ticket_alto}** tiene el **mayor gasto promedio por cliente**.")

            # üß† An√°lisis cruzado: ¬øhay un cl√∫ster que lidera en m√°s de una m√©trica?
            contador_dominancia = {}
            for cluster in [estrella, rezagado, ticket_alto]:
                contador_dominancia[cluster] = contador_dominancia.get(cluster, 0) + 1

            dominante = [k for k, v in contador_dominancia.items() if v >= 2]

            if dominante:
                for clus in dominante:
                    st.success(f"ü•á El segmento **{clus}** lidera en **{contador_dominancia[clus]} m√©tricas** clave. Es un segmento estrat√©gico con alto potencial.")
            else:
                st.info("üîç No hay un √∫nico cl√∫ster dominante en m√°s de una m√©trica. La segmentaci√≥n presenta especializaciones distintas.")

        else:
            st.warning("‚ö†Ô∏è No se pudo generar interpretaci√≥n: el resumen promedio est√° vac√≠o o mal estructurado.")

    except Exception as e:
        st.error(f"‚ùå Error al interpretar el perfil RFM: {e}")

def ordenar_segmentos_seguro(df_resumen):
    """
    Funci√≥n auxiliar para ordenar los segmentos de un DataFrame de resumen.
    Se incluye para hacer el c√≥digo autocontenido.
    """
    try:
        # Intenta ordenar el √≠ndice si es num√©rico
        df_resumen.index = df_resumen.index.astype(int)
        return df_resumen.sort_index()
    except (ValueError, TypeError):
        # Si no es num√©rico, simplemente ordena alfab√©ticamente
        return df_resumen.sort_index()

def interpretar_comparativa_regional(df):
    """
    Genera una interpretaci√≥n del gr√°fico de barras de comparaci√≥n regional,
    identificando la regi√≥n l√≠der en diferentes m√©tricas (cantidad de clientes,
    valor total y ticket promedio).

    Args:
        df (pd.DataFrame): El DataFrame que contiene los datos de las regiones
                          y los cl√∫steres.
    """
    st.markdown("---")
    st.markdown("üß† **Interpretaci√≥n Comparativa Regional:**")

    # Verificar que las columnas necesarias existen en el DataFrame
    required_cols = ["Regi√≥n", "Cantidad", "Monto_Total", "Ticket_Promedio", "Cluster_Label"]
    if not all(col in df.columns for col in required_cols):
        st.error(f"‚ùå Faltan una o m√°s columnas requeridas en el DataFrame: {required_cols}.")
        return

    try:
        resumen = df.groupby("Regi√≥n").agg(
            Cantidad=("Cantidad", "sum"),
            Monto_Total=("Monto_Total", "sum"),
            Ticket_Promedio=("Ticket_Promedio", "mean")
        ).round(2)

        if resumen.empty:
            st.warning("‚ö†Ô∏è El DataFrame de resumen regional est√° vac√≠o. No se puede generar la interpretaci√≥n.")
            return

        region_lider_volumen = resumen["Cantidad"].idxmax()
        region_lider_valor = resumen["Monto_Total"].idxmax()
        region_lider_ticket = resumen["Ticket_Promedio"].idxmax()

        st.markdown(f"- üì¶ La regi√≥n **{region_lider_volumen}** tiene la mayor cantidad total de clientes.")
        st.markdown(f"- üí∞ La regi√≥n **{region_lider_valor}** lidera en valor monetario acumulado.")
        st.markdown(f"- üéüÔ∏è La regi√≥n **{region_lider_ticket}** posee el ticket promedio m√°s alto.")

        # üß† An√°lisis cruzado: ¬øhay una regi√≥n que lidera en m√°s de una m√©trica?
        contador_dominancia = {}
        for region in [region_lider_volumen, region_lider_valor, region_lider_ticket]:
            contador_dominancia[region] = contador_dominancia.get(region, 0) + 1

        dominante = [k for k, v in contador_dominancia.items() if v >= 2]

        if dominante:
            for reg in dominante:
                st.success(f"üèÜ **{reg}** es la regi√≥n m√°s estrat√©gica, liderando en **{contador_dominancia[reg]} m√©tricas** clave.")
        else:
            st.info("üîç No hay una √∫nica regi√≥n dominante en m√°s de una m√©trica. Cada regi√≥n tiene una especializaci√≥n distinta.")

        # Detecci√≥n de disparidad en cl√∫ster Oro
        df_oro = df[df["Cluster_Label"] == "Oro"]
        if not df_oro.empty:
            top_oro = df_oro.groupby("Regi√≥n")["Cantidad"].sum().idxmax()
            st.markdown(f"- ü•á En el segmento Oro, la mayor√≠a de clientes proviene de **{top_oro}**, lo que sugiere un enfoque estrat√©gico en esa regi√≥n.")
        else:
            st.warning("‚ö†Ô∏è No se encontraron datos para el segmento 'Oro'.")

    except Exception as e:
        st.error(f"‚ùå Error al interpretar la comparativa regional: {e}")

def ordenar_segmentos_seguro(df_resumen):
    """
    Funci√≥n auxiliar para ordenar los segmentos de un DataFrame de resumen.
    Se incluye para hacer el c√≥digo autocontenido.
    """
    try:
        # Intenta ordenar el √≠ndice si es num√©rico
        df_resumen.index = df_resumen.index.astype(int)
        return df_resumen.sort_index()
    except (ValueError, TypeError):
        # Si no es num√©rico, simplemente ordena alfab√©ticamente
        return df_resumen.sort_index()

def interpretar_predicciones(region, df_region):
    """
    Genera una interpretaci√≥n autom√°tica y detallada del perfil predictivo
    de la regi√≥n seleccionada, analizando las probabilidades de ascenso a Oro
    y de descenso a Bronce.

    Args:
        region (str): El nombre de la regi√≥n seleccionada.
        df_region (pd.DataFrame): El DataFrame filtrado para la regi√≥n.
    """
    st.markdown("---")
    st.markdown("üß† **Interpretaci√≥n autom√°tica del perfil predictivo:**")

    # Verificar si el DataFrame est√° vac√≠o o faltan columnas esenciales
    required_cols = ["Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce", "Cluster_Label"]
    if df_region.empty or not all(col in df_region.columns for col in required_cols):
        st.warning("‚ö†Ô∏è No hay datos disponibles para la interpretaci√≥n de predicciones en esta regi√≥n o faltan columnas.")
        return

    try:
        media_ascenso = df_region["Probabilidad_Ascenso_Oro"].mean()
        media_bronce = df_region["Probabilidad_Descenso_Bronce"].mean()

        # Interpretaci√≥n general de la probabilidad de ascenso
        st.markdown("---")
        st.subheader("An√°lisis General de la Regi√≥n")
        if media_ascenso > 0.6:
            st.markdown(f"- üéØ En **{region}**, existe **alto potencial de ascenso a Oro** (probabilidad promedio: {media_ascenso:.2f}). Se recomienda una campa√±a de engagement para este grupo.")
        elif media_ascenso < 0.4:
            st.markdown(f"- ‚ö†Ô∏è La probabilidad promedio de ascenso a Oro es baja ({media_ascenso:.2f}). Esto requiere campa√±as proactivas de activaci√≥n o estrategias de retenci√≥n diferenciadas.")
        else:
            st.markdown(f"- üü° El ascenso a Oro promedio es intermedio ({media_ascenso:.2f}). Hay potencial para desarrollar y convertir a un segmento importante de clientes.")

        # Interpretaci√≥n general del riesgo de descenso
        st.markdown("---")
        st.subheader("An√°lisis de Riesgo de Deserci√≥n")
        if media_bronce > 0.6:
            st.markdown(f"- üîª Tambi√©n hay **alto riesgo de ca√≠da a Bronce** (probabilidad promedio: {media_bronce:.2f}), lo que requiere una estrategia de contenci√≥n y re-enganche inmediata.")
        elif media_bronce < 0.3:
            st.markdown(f"- ‚úÖ El riesgo de ca√≠da a Bronce est√° controlado (probabilidad promedio: {media_bronce:.2f}). La mayor√≠a de los clientes se mantiene en cl√∫steres de valor.")
        else:
            st.markdown(f"- üß≠ Se detect√≥ un riesgo moderado de ca√≠da a Bronce (probabilidad promedio: {media_bronce:.2f}). Se debe monitorear a estos clientes para evitar su salida del segmento.")

        # An√°lisis por cl√∫ster de clientes
        st.markdown("---")
        st.subheader("Oportunidades y Riesgos por Cl√∫ster")
        ascenso_por_cluster = ordenar_segmentos_seguro(
            df_region.groupby("Cluster_Label")["Probabilidad_Ascenso_Oro"].mean().round(2)
        )
        bronce_por_cluster = ordenar_segmentos_seguro(
            df_region.groupby("Cluster_Label")["Probabilidad_Descenso_Bronce"].mean().round(2)
        )

        if not ascenso_por_cluster.empty:
            mejor_cluster = ascenso_por_cluster.idxmax()
            st.markdown(f"- üü© El cl√∫ster **{mejor_cluster}** tiene la mayor probabilidad promedio de **ascenso a Oro** ({ascenso_por_cluster[mejor_cluster]:.2f}). Se recomienda priorizar a estos clientes en las campa√±as de marketing.")

        if not bronce_por_cluster.empty:
            peor_cluster = bronce_por_cluster.idxmax()
            st.markdown(f"- üü• El cl√∫ster **{peor_cluster}** concentra el mayor riesgo de **ca√≠da a Bronce** ({bronce_por_cluster[peor_cluster]:.2f}). Es crucial implementar acciones de retenci√≥n para este segmento.")

        # Recomendaci√≥n t√°ctica cruzada
        if not ascenso_por_cluster.empty and not bronce_por_cluster.empty:
            asc_val = ascenso_por_cluster[ascenso_por_cluster.idxmax()]
            bron_val = bronce_por_cluster[bronce_por_cluster.idxmax()]
            st.markdown("---")
            st.subheader("Estrategia Recomendada")
            if asc_val > 0.7 and bron_val > 0.7:
                st.markdown("- üîÄ Se recomienda una estrategia **dual**: potenciar el ascenso de los segmentos con alto potencial y, al mismo tiempo, contener a los segmentos cr√≠ticos con alto riesgo de ca√≠da.")
            elif asc_val > 0.7:
                st.markdown("- üéØ La estrategia debe enfocarse en potenciar a los clientes con alto potencial de ascenso. Son los que dar√°n mayor retorno de inversi√≥n en este momento.")
            elif bron_val > 0.7:
                st.markdown("- üõë La prioridad es la contenci√≥n. Se deben implementar acciones para retener a los clientes del cl√∫ster m√°s riesgoso antes de que se pierdan por completo.")
            else:
                st.info("üîç Los valores de probabilidad no son extremos. Se recomienda una estrategia de monitoreo constante y de optimizaci√≥n de las campa√±as existentes.")

    except Exception as e:
        st.error(f"‚ùå Error durante la interpretaci√≥n de predicciones: {e}")

def plot_scatter_rfm(df, eje_x, eje_y, titulo="RFM Scatter"):
    """
    Crea un gr√°fico de dispersi√≥n interactivo usando Plotly.
    Plotly es la librer√≠a recomendada para gr√°ficos en Streamlit.

    Args:
        df (pd.DataFrame): DataFrame con los datos de clientes, incluyendo las
                          columnas para los ejes, 'Cluster_Label', y datos de hover.
        eje_x (str): Nombre de la columna para el eje X.
        eje_y (str): Nombre de la columna para el eje Y.
        titulo (str): T√≠tulo del gr√°fico.
    """
    # Definimos el diccionario de colores para los cl√∫steres
    colores_k5 = {
        0: 'green',
        1: 'blue',
        2: 'red',
        3: 'purple',
        4: 'orange'
    }

    # Usamos plotly.express para crear el gr√°fico de dispersi√≥n de manera sencilla.
    # El diccionario de colores se mapea directamente a la columna 'Cluster_Label'
    fig = px.scatter(
        df,
        x=eje_x,
        y=eje_y,
        color="Cluster_Label",
        title=titulo,
        color_discrete_map=colores_k5,
        hover_data=['C_CLIEN', 'Recency', 'Frequency', 'Monetary'] # A√±adimos informaci√≥n en el tooltip
    )

    # Actualizamos el dise√±o para una mejor visualizaci√≥n
    fig.update_layout(
        title={
            'text': titulo,
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        legend_title_text='Segmento',
        hovermode="closest"
    )

    return fig

with tab1:
    st.subheader("üìç Distribuci√≥n General de Clientes por Segmento")
    st.caption(f"Visualizaci√≥n de clientes por segmento en la regi√≥n seleccionada, para la empresa **Adargar**")

    # Selecci√≥n de ejes
    variables_disponibles = ["Recency", "Frequency", "Monetary"]
    col1, col2 = st.columns(2)
    with col1:
        eje_x = st.selectbox("Eje X", variables_disponibles, key="x1")
    with col2:
        eje_y = st.selectbox("Eje Y", variables_disponibles, index=1, key="y1")

    # Obtener el DataFrame de la regi√≥n seleccionada
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # Generar el gr√°fico de dispersi√≥n llamando a la funci√≥n corregida con Plotly
    # Se reemplaza la l√≥gica de Matplotlib para usar la funci√≥n plot_scatter_rfm.
    fig = plot_scatter_rfm(df_region, eje_x, eje_y, titulo=f"{region} - {eje_y} vs {eje_x}")
    st.plotly_chart(fig)

    st.caption("üìä Distribuci√≥n actual de clientes por segmento en la regi√≥n seleccionada:")
    st.dataframe(
        df_region["Cluster_Label"]
        .value_counts()
        .rename_axis("Segmento")
        .reset_index(name="Clientes")
    )

# Dado que ya integramos arriba ese tipo de visualizaci√≥n en el tab1 din√°mico (donde el usuario puede seleccionar cualquier combinaci√≥n
# de ejes RFM y la regi√≥n), este segundo bloque tambi√©n queda totalmente abarcado por el tab1, es por eso que las l√≠neas de
# c√≥digo estan comentadas con #

# Moquegua ‚Äì Frequency vs Monetary
# plot_scatter_rfm(df_moq, "Frequency", "Monetary", "üìç Moquegua ‚Äì Frecuencia vs Monto Gastado")

# Tacna ‚Äì Frequency vs Monetary
# plot_scatter_rfm(df_tac, "Frequency", "Monetary", "üìç Tacna ‚Äì Frecuencia vs Monto Gastado")

# Idem al bloque anterior

# Moquegua ‚Äì Recency vs Monetary
# plot_scatter_rfm(df_moq, "Recency", "Monetary", "üìç Moquegua ‚Äì Recency vs Monto Gastado")

# Tacna ‚Äì Recency vs Monetary
# plot_scatter_rfm(df_tac, "Recency", "Monetary", "üìç Tacna ‚Äì Recency vs Monto Gastado")

with tab2:
    st.subheader("üìä Estad√≠sticas de Valor por Cl√∫ster RFM")
    st.caption(f"Visualiza promedios de Recency, Frequency y Monetary en clientes de **{region}**")

    # üß© Dataset seg√∫n regi√≥n activa
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    df_region["Cluster_Label"] = df_region["Cluster_Label"].fillna("Desconocido")

    # üö® Nuevo orden con 5 cl√∫steres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    df_region["Cluster_Label"] = pd.Categorical(df_region["Cluster_Label"], categories=orden, ordered=True)

    # üìà Tabla: Promedio RFM por segmento
    st.markdown("### üìå Promedios por Cl√∫ster RFM")
    resumen = df_region.groupby("Cluster_Label").agg({
        "Recency": "mean",
        "Frequency": "mean",
        "Monetary": "mean"
    }).round(1).reset_index()
    resumen.rename(columns={
        "Recency": "Recency (d√≠as)",
        "Frequency": "Frecuencia",
        "Monetary": "Monetary (S/.)"
    }, inplace=True)
    st.dataframe(resumen.style.format({
        "Recency (d√≠as)": "{:.1f}",
        "Frecuencia": "{:.1f}",
        "Monetary (S/.)": "S/ {:.1f}"
    }), use_container_width=True)

    # üë• Tabla: Cantidad por segmento
    st.markdown("### üë• Cantidad de Clientes por Cl√∫ster")
    conteo = df_region["Cluster_Label"].value_counts().reindex(orden).fillna(0).astype(int).reset_index()
    conteo.columns = ["Cl√∫ster", "Clientes"]
    st.dataframe(conteo, use_container_width=True)

    # üß† Interpretaci√≥n autom√°tica
    with st.expander("üß† Interpretaci√≥n autom√°tica"):
        if not conteo.empty:
            top_segmento = conteo.loc[conteo["Clientes"].idxmax(), "Cl√∫ster"]
            r_max = resumen.loc[resumen["Cluster_Label"] == top_segmento, "Recency (d√≠as)"].values[0]
            m_max = resumen.loc[resumen["Cluster_Label"] == top_segmento, "Monetary (S/.)"].values[0]
            st.markdown(f"- üèÜ El cl√∫ster m√°s numeroso es **{top_segmento}**, con recency promedio de **{r_max:.1f} d√≠as** y consumo medio de **S/ {m_max:.1f}**.")

            # üö® L√≥gica de interpretaci√≥n actualizada para los nuevos umbrales
            if top_segmento == "Diamante":
                 st.success("üíé El segmento m√°s numeroso es de alto valor. ¬°Excelente!")
            elif r_max <= 30:
                st.info("üîÅ Recency bajo: indica clientes recientemente activos.")
            elif m_max >= 500:
                st.info("üí∞ Ticket promedio elevado: estos clientes tienen alto valor monetario.")
            else:
                st.info("üîç No se encontraron patrones destacados en el segmento m√°s numeroso.")
        else:
            st.warning("‚ö†Ô∏è No se pudo realizar la interpretaci√≥n autom√°tica. DataFrame vac√≠o.")

def ordenar_segmentos_seguro(series_segmentos, nombre_var="Cluster_Label"):
    """
    Funci√≥n robusta para ordenar segmentos de manera segura.
    Se asegura de que el orden jer√°rquico se respete,
    y a√±ade cualquier segmento inesperado al final.
    """
    # Definimos el orden jer√°rquico deseado para los 5 cl√∫steres
    orden_jerarquico = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    # Obtenemos los segmentos que realmente existen en los datos (el √≠ndice de la serie)
    segmentos_existentes = list(series_segmentos.index)

    # Creamos el orden final filtrando el orden jer√°rquico con los segmentos existentes
    orden_final = [seg for seg in orden_jerarquico if seg in segmentos_existentes]

    # A√±adimos cualquier segmento existente que no est√© en nuestra lista jer√°rquica
    # Esto es √∫til si aparece un cl√∫ster no esperado en el futuro
    for seg in segmentos_existentes:
        if seg not in orden_final:
            orden_final.append(seg)

    # Reindexamos la serie con el orden final y devolvemos el resultado
    return series_segmentos.reindex(orden_final)

def graficar_tama√±o_cluster(df, region=""):
    """
    Funci√≥n para graficar el tama√±o de los cl√∫steres usando Plotly.
    Plotly es la librer√≠a recomendada y compatible con Streamlit.
    """
    # üö® Usamos el orden y los colores de los 5 cl√∫steres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # Contamos los clientes por cl√∫ster y reindexamos para el orden correcto
    conteo = df["Cluster_Label"].value_counts().reindex(orden).fillna(0).astype(int).reset_index()
    conteo.columns = ["Cluster", "Clientes"]

    # Creamos el gr√°fico de barras interactivo con Plotly
    fig = px.bar(
        conteo,
        x="Cluster",
        y="Clientes",
        color="Cluster",
        color_discrete_map=colores_k5,
        labels={"Cluster": "Segmento", "Clientes": "Nro. de Clientes"},
        title=f"üìä Distribuci√≥n de clientes por segmento ‚Äì {region}",
    )

    # A√±adimos las etiquetas de texto encima de las barras
    fig.update_traces(texttemplate='%{y}', textposition='outside')
    fig.update_layout(
        title={
            'text': f"üìä Distribuci√≥n de clientes por segmento ‚Äì {region}",
            'y': 0.9,
            'x': 0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        xaxis={'categoryorder': 'array', 'categoryarray': orden}, # Aseguramos el orden en el eje X
        hovermode="x unified",
        showlegend=False # La informaci√≥n ya est√° en el eje X
    )

    return fig

# Ejemplo de c√≥mo se llamar√≠a la funci√≥n en Streamlit:
# fig_tamano = graficar_tama√±o_cluster(df_region, region)
# st.plotly_chart(fig_tamano)

with tab3:
    st.subheader("üì¶ Distribuci√≥n de Clientes por Segmento RFM")
    st.caption(f"Visualiza cu√°ntos clientes pertenecen a cada cl√∫ster en la regi√≥n de **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # üëÅÔ∏è Mostrar gr√°fico de barras adaptado con Plotly
    # Se ha cambiado st.pyplot por st.plotly_chart para un gr√°fico interactivo.
    st.plotly_chart(graficar_tama√±o_cluster(df_region, region))

    # üßÆ Mostrar tabla resumen de conteo por cl√∫ster
    conteo = ordenar_segmentos_seguro(df_region["Cluster_Label"].value_counts()).reset_index()
    conteo.columns = ["Segmento", "Clientes"]
    st.dataframe(conteo, use_container_width=True)

    # üß† Interpretaci√≥n autom√°tica
    with st.expander("üß† Interpretaci√≥n autom√°tica"):
        segmento_max = conteo.loc[conteo["Clientes"].idxmax(), "Segmento"]
        st.markdown(f"- üèÜ El segmento dominante en **{region}** es **{segmento_max}**.")

        # ÔøΩ L√≥gica de interpretaci√≥n actualizada para 5 cl√∫steres
        if segmento_max == "Diamante":
            st.success("üíé Excelente: predominan los clientes m√°s valiosos y leales.")
        elif segmento_max == "Oro":
            st.success("‚ú® Excelente: predominan clientes de alto valor y leales.")
        elif segmento_max == "Plata":
            st.info("üìà Gran oportunidad: clientes constantes con potencial de crecimiento.")
        elif segmento_max == "Cobre":
            st.warning("üí° Atenci√≥n: mayor√≠a de clientes en estado de oportunidad o riesgo de inactividad.")
        elif segmento_max == "Bronce":
            st.error("‚ö†Ô∏è Alerta: el segmento m√°s numeroso requiere una estrategia urgente de reactivaci√≥n.")

with tab4:
    st.subheader("üíº Estrategias de Campa√±a por Cl√∫ster RFM")
    st.caption("Aplicables a clientes seg√∫n su clasificaci√≥n por Recency, Frequency y Monetary.")

    tabla_html = """
    <div style="border:1px solid #ddd; border-radius:10px; padding:15px; background-color:#fefefe; box-shadow:2px 2px 8px rgba(0,0,0,0.05); margin-top:15px;">

    <h4 style="margin-bottom:10px;">üìå Recomendaciones de Campa√±a por Segmento</h4>

    <table style="width:100%; border-collapse: collapse; font-family: 'Segoe UI', sans-serif; font-size:15px;">
      <thead style="background-color:#e0e0e0;">
        <tr>
          <th style="border: 1px solid #ccc; padding: 8px;">Cl√∫ster</th>
          <th style="border: 1px solid #ccc; padding: 8px;">Perfil</th>
          <th style="border: 1px solid #ccc; padding: 8px;">Objetivo</th>
          <th style="border: 1px solid #ccc; padding: 8px;">Acci√≥n Recomendada</th>
        </tr>
      </thead>
      <tbody>
        <tr style="background-color:#e6f8ff;">
          <td style="border: 1px solid #eee; padding: 8px;">üíé Diamante</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes √©lite, de alto valor</td>
          <td style="border: 1px solid #eee; padding: 8px;">Fidelizaci√≥n y crecimiento</td>
          <td style="border: 1px solid #eee; padding: 8px;">Programas de lealtad exclusivos y anticipaci√≥n de necesidades.</td>
        </tr>
        <tr style="background-color:#fffbe6;">
          <td style="border: 1px solid #eee; padding: 8px;">üü° Oro</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes muy valiosos y leales</td>
          <td style="border: 1px solid #eee; padding: 8px;">Fidelizaci√≥n y potenciar</td>
          <td style="border: 1px solid #eee; padding: 8px;">Ofrecer programas VIP y seguimiento personalizado.</td>
        </tr>
        <tr style="background-color:#f0f9ff;">
          <td style="border: 1px solid #eee; padding: 8px;">üîµ Plata</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes con frecuencia y valor medio</td>
          <td style="border: 1px solid #eee; padding: 8px;">Impulso de recurrencia y up-selling</td>
          <td style="border: 1px solid #eee; padding: 8px;">Enviar promociones segmentadas y correos de recordatorio.</td>
        </tr>
        <tr style="background-color:#fff8f6;">
          <td style="border: 1px solid #eee; padding: 8px;">üí° Cobre</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes en riesgo de inactividad</td>
          <td style="border: 1px solid #eee; padding: 8px;">Retenci√≥n y oportunidad</td>
          <td style="border: 1px solid #eee; padding: 8px;">Enfoque en productos complementarios y reactivaci√≥n con ofertas de valor.</td>
        </tr>
        <tr style="background-color:#f6e6ff;">
          <td style="border: 1px solid #eee; padding: 8px;">üü§ Bronce</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes de bajo ticket o inactivos</td>
          <td style="border: 1px solid #eee; padding: 8px;">Reactivaci√≥n</td>
          <td style="border: 1px solid #eee; padding: 8px;">Lanzar campa√±as con ofertas de bienvenida o combos accesibles.</td>
        </tr>
      </tbody>
    </table>
    </div>
    """
    st.markdown(tabla_html, unsafe_allow_html=True)

def plot_boxplots_rfm(df, region):
    """
    Funci√≥n que genera boxplots interactivos para las variables RFM por cl√∫ster
    usando Plotly. Se utiliza la t√©cnica de 'melt' para reestructurar los datos
    y graficar los tres boxplots en una sola llamada a Plotly.
    """
    # üö® Usamos el orden y los colores de los 5 cl√∫steres
    orden_k5 = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # Seleccionamos las variables RFM y el cl√∫ster
    rfm_vars = ["Recency", "Frequency", "Monetary"]
    df_plot = df[["Cluster_Label"] + rfm_vars].copy()

    # Se utiliza pd.melt para "derretir" el DataFrame de un formato ancho a uno largo,
    # lo cual es ideal para graficar m√∫ltiples variables en un mismo gr√°fico de Plotly.
    df_melt = df_plot.melt(id_vars="Cluster_Label", value_vars=rfm_vars, var_name="Variable", value_name="Valor")

    # Creamos el gr√°fico de boxplots utilizando facetas para cada variable
    fig = px.box(
        df_melt,
        x="Cluster_Label",
        y="Valor",
        color="Cluster_Label",
        facet_col="Variable",
        facet_col_wrap=3, # Se muestran los 3 boxplots uno al lado del otro
        category_orders={"Cluster_Label": orden_k5}, # Aseguramos el orden de los cl√∫steres
        color_discrete_map=colores_k5,
        title=f"Distribuci√≥n RFM por Cl√∫ster ‚Äì {region}",
        labels={"Cluster_Label": "Segmento", "Valor": "Valor"},
    )

    # Ajustes de dise√±o para mejorar la visualizaci√≥n
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1])) # Elimina el "Variable=" del t√≠tulo de la faceta
    fig.update_layout(
        title={
            'text': f"Distribuci√≥n RFM por Cl√∫ster ‚Äì {region}",
            'y': 0.9,
            'x': 0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        hovermode="closest",
        legend_title_text='Segmento',
    )

    return fig

# Nueva funci√≥n para interpretar boxplots
def interpretar_boxplot_rfm(df, variable, region):
    """
    Funci√≥n de interpretaci√≥n autom√°tica para un boxplot de cualquier variable RFM.
    """
    st.markdown("üß† **Interpretaci√≥n Autom√°tica del Boxplot:**")
    try:
        resumen_bruto = df.groupby("Cluster_Label")[variable].describe()[["mean", "25%", "50%", "75%"]].round(2)
        resumen = ordenar_segmentos_seguro(resumen_bruto)

        if resumen is not None and not resumen.empty:
            mayor_media = resumen["mean"].idxmax()
            menor_media = resumen["mean"].idxmin()
            q3_max = resumen["75%"].max()

            st.markdown(f"- üìç En **{region}**, el cl√∫ster con mayor valor promedio de `{variable}` es **{mayor_media}**.")
            st.markdown(f"- üß≠ El cl√∫ster con menor valor promedio es **{menor_media}**.")

            # An√°lisis de outliers
            outliers_detectados = False
            for segmento in resumen.index:
                q1 = resumen.loc[segmento, "25%"]
                q3 = resumen.loc[segmento, "75%"]
                iqr = q3 - q1
                limite_superior_teorico = q3 + 1.5 * iqr

                max_real = df[df["Cluster_Label"] == segmento][variable].max()

                if max_real > limite_superior_teorico:
                    st.warning(f"‚ö†Ô∏è El segmento **{segmento}** tiene **valores at√≠picos** altos en `{variable}`, indicando clientes con comportamiento extremo.")
                    outliers_detectados = True

            if not outliers_detectados:
                st.info("‚úÖ No se detectaron valores at√≠picos significativos. Los cl√∫steres son bastante homog√©neos.")

        else:
            st.warning("‚ö†Ô∏è No se pudo calcular el resumen estad√≠stico confiable para esta m√©trica.")
    except Exception as e:
        st.error(f"‚ùå Error al interpretar el gr√°fico Boxplot: {e}")

# --- Bloque corregido para tab5 ---
with tab5:
    st.subheader("üìä Distribuci√≥n de m√©tricas RFM por segmento")
    st.caption(f"Comparaci√≥n visual de dispersi√≥n y valores at√≠picos seg√∫n el segmento en **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    fig = plot_boxplots_rfm(df_region, region)
    # üö® L√çNEA CORREGIDA: Se usa st.plotly_chart para un gr√°fico interactivo
    st.plotly_chart(fig)

    st.markdown("---") # Separador para mejor lectura
    st.markdown("### üìå Interpretaci√≥n autom√°tica por m√©trica")
    for variable in ("Recency", "Frequency", "Monetary"):
        with st.expander(f"üìé An√°lisis de {variable} por segmento"):
            # üö® Se llama a la nueva funci√≥n de interpretaci√≥n para boxplots
            interpretar_boxplot_rfm(df_region, variable, region)

with tab6:
    st.subheader("üèÖ Top Clientes de Alto Valor: Diamante y Oro")
    st.caption(f"Listado de clientes 'Diamante' y 'Oro' ordenados por valor monetario en **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # üö® Se filtra por los 2 segmentos de mayor valor
    df_top_segmentos = df_region[df_region["Cluster_Label"].isin(["Diamante", "Oro"])].copy()

    top_n = st.slider("Selecciona cu√°ntos clientes de alto valor mostrar:", min_value=5, max_value=50, value=10, step=5)

    if not df_top_segmentos.empty:
        top_df = df_top_segmentos.sort_values(by="Monetary", ascending=False).head(top_n).reset_index(drop=True)
        top_df.index += 1

        st.dataframe(
            top_df[["C_CLIEN", "Recency", "Frequency", "Monetary", "Cluster_Label"]].round(1).rename(columns={
                "C_CLIEN": "C√≥digo Cliente",
                "Recency": "Recencia (d√≠as)",
                "Frequency": "Frecuencia (compras)",
                "Monetary": "Valor Monetario (S/)",
                "Cluster_Label": "Segmento"
            }),
            use_container_width=True
        )

        # üßæ Excel exportaci√≥n
        output = io.BytesIO()
        wb = Workbook()
        resumen_sheet = wb.active
        resumen_sheet.title = "Resumen de Top Clientes"

        # üé® Estilos
        header_font = Font(bold=True, color="FFFFFF")
        align_center = Alignment(horizontal="center")
        border = Border(bottom=Side(style="thin"))

        # üö® Nuevo diccionario con 5 colores para los cl√∫steres
        cluster_fills = {
            "Diamante": PatternFill(start_color="00FFFF", fill_type="solid"),
            "Oro": PatternFill(start_color="FFD700", fill_type="solid"),
            "Plata": PatternFill(start_color="C0C0C0", fill_type="solid"),
            "Cobre": PatternFill(start_color="B87333", fill_type="solid"),
            "Bronce": PatternFill(start_color="CD7F32", fill_type="solid")
        }

        # üñºÔ∏è Logo (si existe)
        try:
            logo = XLImage("logo_adargar.jpg")
            logo.width = 220
            logo.height = 70
            resumen_sheet.add_image(logo, "A1")
        except:
            pass

        # üìã T√≠tulo + fecha
        resumen_sheet["A5"] = f"üìä Reporte de Clientes Diamante y Oro ‚Äì Regi√≥n: {region}"
        resumen_sheet["A5"].font = Font(bold=True, size=12)
        resumen_sheet["A5"].alignment = align_center
        resumen_sheet.merge_cells("A5:E5")
        resumen_sheet["A6"] = f"Fecha de generaci√≥n: {datetime.today().strftime('%d/%m/%Y')}"
        resumen_sheet["A6"].font = Font(italic=True, size=10)

        # üß© Encabezado
        headers = ["C√≥digo Cliente", "Recencia (d√≠as)", "Frecuencia (compras)", "Valor Monetario (S/)", "Segmento"]
        for i, h in enumerate(headers, start=1):
            cell = resumen_sheet.cell(row=10, column=i, value=h)
            cell.font = header_font
            cell.alignment = align_center
            cell.fill = cluster_fills.get(top_df["Cluster_Label"].iloc[0], cluster_fills["Oro"]) # üö® Ajuste para color
            cell.border = border

        # üë§ Datos
        for i, row in enumerate(top_df.itertuples(index=False), start=11):
            resumen_sheet.cell(row=i, column=1, value=row.C_CLIEN)
            resumen_sheet.cell(row=i, column=2, value=row.Recency)
            resumen_sheet.cell(row=i, column=3, value=row.Frequency)
            resumen_sheet.cell(row=i, column=4, value=row.Monetary)
            cell_cluster = resumen_sheet.cell(row=i, column=5, value=row.Cluster_Label)
            cell_cluster.fill = cluster_fills.get(row.Cluster_Label, None)

        for col in "ABCDE":
            resumen_sheet.column_dimensions[col].width = 20

        # üóÇÔ∏è Otras hojas por cl√∫ster
        # üö® Se itera sobre los 5 cl√∫steres
        for label in ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]:
            df_cl = df_region[df_region["Cluster_Label"] == label].copy()
            hoja = wb.create_sheet(f"Cl√∫ster {label}")
            hoja.append(["C√≥digo Cliente", "Recencia (d√≠as)", "Frecuencia", "Valor Monetario (S/)", "Cluster_Label", "Color", "Regi√≥n"])
            for r in df_cl.itertuples(index=False):
                hoja.append([
                    r.C_CLIEN, r.Recency, r.Frequency, r.Monetary,
                    r.Cluster_Label, r.Color, r.Region
                ])
            for cell in hoja["1:1"]:
                cell.font = header_font
                cell.fill = cluster_fills[label]
                cell.border = border
                cell.alignment = align_center
            for col in "ABCDEFG":
                hoja.column_dimensions[col].width = 18
            hoja.append([])
            hoja.append(["üìå Estrategia:", estrategias.get(label, "")])

        if "Sheet" in wb.sheetnames:
            del wb["Sheet"]

        wb.save(output)
        output.seek(0)

        st.download_button(
            label=f"üìò Descargar Reporte Excel ‚Äì {region}",
            data=output,
            # üö® Se actualiza el nombre del archivo
            file_name=f"Reporte_Clientes_Diamante_Oro_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.warning(f"‚ö†Ô∏è No se encontraron clientes de alto valor (Diamante o Oro) en la regi√≥n {region}.")

with tab7:
    st.subheader("üõéÔ∏è Clientes con Recencia Cr√≠tica por Segmento")
    st.caption(f"Filtra y descarga clientes con se√±ales de abandono en la regi√≥n **{region}** para activar campa√±as de retenci√≥n segmentada.")

    # Selecci√≥n de regi√≥n
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # üö® Selecci√≥n de cl√∫ster actualizada
    segmentos = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    segmento_seleccionado = st.selectbox("üéØ Selecciona el segmento a analizar:", segmentos, key="seg_critico")

    df_segmento = df_region[df_region["Cluster_Label"] == segmento_seleccionado].copy()

    modo_alerta = st.radio("üìä Criterio de alerta:", ["Recency > percentil 75", "Recency > 90 d√≠as"], index=0, key="modo_alerta")

    if modo_alerta == "Recency > percentil 75":
        if not df_segmento.empty:
            umbral = df_segmento["Recency"].quantile(0.75)
            st.markdown(f"üîç Clientes con Recency > **{umbral:.0f} d√≠as** ser√°n marcados como en riesgo.")
        else:
            umbral = 0
            st.markdown("üîç No hay datos para este segmento. No se puede calcular el umbral.")
    else:
        umbral = 90
        st.markdown("üîç Clientes con Recency > **90 d√≠as** ser√°n marcados como en riesgo.")

    clientes_riesgo = df_segmento[df_segmento["Recency"] > umbral].copy()
    clientes_riesgo = clientes_riesgo.sort_values(by="Recency", ascending=False).reset_index(drop=True)

    col1, col2, col3 = st.columns(3)
    col1.metric(f"Clientes {segmento_seleccionado} Totales", len(df_segmento))
    col2.metric("Clientes en Riesgo", len(clientes_riesgo))
    porcentaje = f"{(100 * len(clientes_riesgo) / len(df_segmento)):.1f}%" if len(df_segmento) > 0 else "0%"
    col3.metric("% en Riesgo", porcentaje)

    if not clientes_riesgo.empty:
        st.markdown("### üìã Detalle de clientes en riesgo:")
        st.dataframe(
            clientes_riesgo[["C_CLIEN", "Recency", "Frequency", "Monetary", "Cluster_Label"]].round(1).rename(columns={
                "C_CLIEN": "C√≥digo Cliente",
                "Recency": "Recencia (d√≠as)",
                "Frequency": "Frecuencia (compras)",
                "Monetary": "Valor Monetario (S/)",
                "Cluster_Label": "Segmento"
            }),
            use_container_width=True
        )

        buffer = io.BytesIO()
        wb = Workbook()
        ws = wb.active
        ws.title = f"Alerta {segmento_seleccionado} ‚Äì {region}"

        ws["A1"] = f"üìã Clientes {segmento_seleccionado} en Riesgo ‚Äì {region}"
        ws["A1"].font = Font(bold=True)
        ws.merge_cells("A1:D1")
        ws.append(["C√≥digo Cliente", "Recencia", "Frecuencia", "Monetario"])

        for r in clientes_riesgo.itertuples(index=False):
            ws.append([r.C_CLIEN, r.Recency, r.Frequency, r.Monetary])

        for col in "ABCD":
            ws.column_dimensions[col].width = 20

        wb.save(buffer)
        buffer.seek(0)

        st.download_button(
            label=f"üìÑ Descargar Excel ‚Äì {segmento_seleccionado} ‚Äì {region}",
            data=buffer,
            file_name=f"Alerta_{segmento_seleccionado}_Riesgo_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.success(f"üéâ No hay clientes {segmento_seleccionado} en riesgo con los criterios actuales.")

    st.markdown("---")
    st.markdown("### üìå Recomendaci√≥n Estrat√©gica")

    # üö® Diccionario de estrategias actualizado
    estrategias = {
        "Diamante": "Contactar con atenci√≥n premium, beneficios exclusivos y encuestas de satisfacci√≥n.",
        "Oro": "Ofrecer programas VIP y seguimiento personalizado para mantener la lealtad.",
        "Plata": "Ofrecer promociones segmentadas, cupones de incentivo o encuestas de vinculaci√≥n.",
        "Cobre": "Aplicar campa√±as de reactivaci√≥n con ofertas de valor, cross-selling y comunicaci√≥n proactiva.",
        "Bronce": "Lanzar campa√±as con ofertas de bienvenida o combos accesibles para reactivar la base."
    }
    st.info(estrategias.get(segmento_seleccionado, "Estrategia no definida para este segmento."))

# üõ†Ô∏è Recalcular df_tac y df_moq despu√©s de entrenar el modelo
df_tac = rfm[rfm["Region"] == "Tacna"].copy()
df_moq = rfm[rfm["Region"] == "Moquegua"].copy()

# Funci√≥n para interpretar las predicciones, asumiendo que existe
# Es recomendable definir esta funci√≥n en otro bloque de c√≥digo.
def interpretar_predicciones(region, df):
    # L√≥gica de interpretaci√≥n para los cl√∫steres...
    st.markdown(f"**An√°lisis Predictivo en la Regi√≥n {region}:**")
    for cluster in ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]:
        df_cluster = df[df["Cluster_Label"] == cluster]
        if not df_cluster.empty:
            prob_ascenso_mean = df_cluster["Probabilidad_Ascenso_Oro"].mean()
            prob_descenso_mean = df_cluster["Probabilidad_Descenso_Bronce"].mean()
            st.markdown(f"---")
            st.markdown(f"**Segmento {cluster}:**")
            st.markdown(f"- Probabilidad promedio de ascenso a Oro: **{prob_ascenso_mean:.2f}**")
            st.markdown(f"- Probabilidad promedio de ca√≠da a Bronce: **{prob_descenso_mean:.2f}**")

# --- Bloque corregido para tab8 ---
with tab8:
    st.subheader("üîÆ Modelo de Evoluci√≥n de Clientes por Regi√≥n")
    st.caption(f"An√°lisis predictivo aplicado a la regi√≥n **{region}** para anticipar evoluci√≥n y riesgo de clientes.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # Se usan las nuevas columnas de predicci√≥n
    df_region["Probabilidad_Ascenso_Oro"] = pd.to_numeric(df_region["Probabilidad_Ascenso_Oro"], errors="coerce")
    df_region["Probabilidad_Descenso_Bronce"] = pd.to_numeric(df_region["Probabilidad_Descenso_Bronce"], errors="coerce")

    # Vista de clientes con alta probabilidad de ascenso
    st.markdown("### üìà Clientes con potencial de ascenso")
    umbral = st.slider("üìà Umbral de probabilidad de ascenso a Oro:", 0.5, 1.0, 0.75, step=0.05)

    df_filtrado = df_region[df_region["Probabilidad_Ascenso_Oro"] >= umbral].copy()
    df_filtrado = df_filtrado.sort_values("Probabilidad_Ascenso_Oro", ascending=False).reset_index(drop=True)

    def definir_campa√±a(row):
        if row["Cluster_Label"] in ["Bronce", "Cobre"] and row["Probabilidad_Ascenso_Oro"] >= umbral:
            return "üéØ Activar con Oferta Especial"
        elif row["Cluster_Label"] == "Plata" and row["Probabilidad_Ascenso_Oro"] >= umbral:
            return "üìà Seguimiento Comercial y Up-selling"
        elif row["Cluster_Label"] in ["Oro", "Diamante"] and row["Probabilidad_Descenso_Bronce"] >= 0.5:
            return "‚ö†Ô∏è Retener Urgentemente"
        else:
            return "ü§ù Mantenimiento Estrat√©gico"

    if not df_filtrado.empty:
        df_filtrado["Campa√±a Sugerida"] = df_filtrado.apply(definir_campa√±a, axis=1)

        st.markdown(f"üìã Se identificaron **{len(df_filtrado)}** clientes con alta probabilidad de ascenso a Oro.")
        st.dataframe(
            df_filtrado[[
                "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "Campa√±a Sugerida"
            ]].rename(columns={
                "C_CLIEN": "C√≥digo Cliente",
                "Cluster_Label": "Cl√∫ster Actual",
                "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro"
            }).round(3),
            use_container_width=True
        )

        excel_buff = io.BytesIO()
        df_exportar = df_filtrado[[
            "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "Campa√±a Sugerida"
        ]].rename(columns={
            "C_CLIEN": "C√≥digo Cliente",
            "Cluster_Label": "Cl√∫ster Actual",
            "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro"
        })
        df_exportar.to_excel(excel_buff, index=False)
        excel_buff.seek(0)

        st.download_button(
            "üì• Descargar Excel de Clientes en Evoluci√≥n",
            data=excel_buff,
            file_name=f"Prediccion_Evolucion_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.info("üîç No se encontraron clientes que cumplan el umbral de probabilidad establecido.")

    st.subheader("üìä Distribuci√≥n ‚Äì Probabilidad de Ascenso a Oro")
    if df_region["Probabilidad_Ascenso_Oro"].notna().sum() > 0:
        # L√çNEA CORREGIDA: Se usa plotly.express para el histograma interactivo
        fig = px.histogram(
            df_region, x="Probabilidad_Ascenso_Oro", nbins=20,
            title=f"Distribuci√≥n ‚Äì Probabilidad de Ascenso a Oro ({region})",
            labels={"Probabilidad_Ascenso_Oro": "Probabilidad", "count": "Clientes"}
        )
        st.plotly_chart(fig)

        with st.expander("üß† Ver interpretaci√≥n predictiva autom√°tica por cl√∫ster"):
            interpretar_predicciones(region, df_region)
    else:
        st.warning("‚ö†Ô∏è No hay datos num√©ricos v√°lidos para graficar.")

    st.subheader("üìà Vista estrat√©gica de Riesgo y Oportunidad (Ascenso vs Ca√≠da)")
    st.markdown("üîç Analiza clientes seg√∫n su **probabilidad de ascenso a Oro** y **riesgo de ca√≠da a Bronce**.")

    col1, col2 = st.columns(2)
    with col1:
        umbral_ascenso = st.slider("üéØ Umbral de ascenso alto", 0.6, 1.0, 0.8, step=0.05, key="umbral_ascenso_plot")
    with col2:
        umbral_caida = st.slider("üõë Umbral de ca√≠da alta", 0.4, 1.0, 0.6, step=0.05, key="umbral_caida_plot")

    def clasificar_cuadrante(row):
        # üö® L√≥gica de clasificaci√≥n actualizada con las nuevas columnas
        if row["Probabilidad_Ascenso_Oro"] >= umbral_ascenso:
            if row["Probabilidad_Descenso_Bronce"] <= 1 - umbral_caida:
                return "Cliente Estrella (Ascenso Seguro)"
            else:
                return "Potencial de Ascenso y Riesgo"
        elif row["Probabilidad_Descenso_Bronce"] >= umbral_caida:
            if row["Probabilidad_Ascenso_Oro"] <= 1 - umbral_ascenso:
                return "Riesgo de Abandono (Ca√≠da Segura)"
            else:
                return "Riesgo con Potencial"
        else:
            return "Zona de Desarrollo y Estabilidad"

    df_region["Segmento Estrat√©gico"] = df_region.apply(clasificar_cuadrante, axis=1)

    st.markdown(f"üìå Se han clasificado **{df_region.shape[0]}** clientes seg√∫n su perfil estrat√©gico.")
    st.dataframe(
        df_region[[
            "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce", "Segmento Estrat√©gico"
        ]].rename(columns={
            "C_CLIEN": "C√≥digo Cliente",
            "Cluster_Label": "Cl√∫ster Actual",
            "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro",
            "Probabilidad_Descenso_Bronce": "Prob. Ca√≠da a Bronce"
        }).round(3),
        use_container_width=True
    )

    # L√çNEA CORREGIDA: Se usa plotly.express para el scatter plot interactivo
    fig = px.scatter(
        df_region,
        x="Probabilidad_Ascenso_Oro", y="Probabilidad_Descenso_Bronce",
        color="Segmento Estrat√©gico",
        title=f"Matriz Estrat√©gica de Evoluci√≥n ‚Äì {region}",
        labels={
            "Probabilidad_Ascenso_Oro": "Probabilidad de Ascenso a Oro",
            "Probabilidad_Descenso_Bronce": "Probabilidad de Ca√≠da a Bronce"
        },
        height=500
    )
    # Ajustamos la posici√≥n de la leyenda y los ejes
    fig.update_layout(legend_title_text='Segmento Estrat√©gico')
    # A√±adimos las l√≠neas de los umbrales
    fig.add_vline(x=umbral_ascenso, line_width=1, line_dash="dash", line_color="gray")
    fig.add_hline(y=umbral_caida, line_width=1, line_dash="dash", line_color="gray")
    st.plotly_chart(fig)

    excel_buffer = io.BytesIO()
    df_exportar_cuadrantes = df_region[[
        "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro",
        "Probabilidad_Descenso_Bronce", "Segmento Estrat√©gico"
    ]].rename(columns={
        "C_CLIEN": "C√≥digo Cliente",
        "Cluster_Label": "Cl√∫ster Actual",
        "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro",
        "Probabilidad_Descenso_Bronce": "Prob. Ca√≠da a Bronce"
    })
    df_exportar_cuadrantes.to_excel(excel_buffer, index=False)
    excel_buffer.seek(0)

    st.download_button(
        "üì• Descargar Excel de Clientes Segmentados",
        data=excel_buffer,
        file_name=f"Matriz_Estrategica_{region}.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

# Nueva funci√≥n para la interpretaci√≥n de histogramas RFM
def interpretar_histograma_rfm(df, variable, region):
    st.markdown("### üîç An√°lisis de la distribuci√≥n por cl√∫ster:")

    # Orden de los cl√∫steres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden:
        subset = df[df["Cluster_Label"] == label][variable].dropna()
        if not subset.empty:
            media = subset.mean()
            mediana = subset.median()
            st.markdown(f"**{label}**:")
            st.markdown(f"- Media: **{media:.2f}**, Mediana: **{mediana:.2f}**")

            # L√≥gica de interpretaci√≥n b√°sica
            if variable == "Recency":
                if media < 30:
                    st.success(f" ¬†- üéâ Los clientes de este segmento han comprado recientemente (media < 30 d√≠as).")
                elif media > 180:
                    st.error(f" ¬†- ‚è≥ Los clientes de este segmento est√°n inactivos (media > 180 d√≠as).")
                else:
                    st.info(f" ¬†- üìà Compras a intervalos moderados. Oportunidad de marketing. ")

            elif variable == "Frequency":
                if media >= 10:
                    st.success(f" ¬†- üõí Clientes muy recurrentes, compran frecuentemente (media >= 10).")
                elif media >= 3:
                    st.info(f" ¬†- üîÑ Clientes con frecuencia moderada. Se puede impulsar m√°s compras.")
                else:
                    st.warning(f" ¬†- üìâ Clientes poco recurrentes. Fomentar la repetici√≥n de compra.")

            elif variable == "Monetary":
                if media >= 2000:
                    st.success(f" ¬†- üí∞ Alto valor monetario. Clientes muy valiosos (media >= S/ 2000).")
                elif media >= 500:
                    st.info(f" ¬†- üìà Valor monetario moderado. Potencial para aumentar el ticket promedio.")
                else:
                    st.warning(f" ¬†- üí∏ Bajo valor monetario. Se puede incentivar compras de mayor valor.")

# --- Bloque corregido para tab9 ---
with tab9:
    st.subheader("üìä Distribuci√≥n de Comportamiento RFM por Cl√∫ster")
    st.caption(f"Visualiza la distribuci√≥n de m√©tricas RFM para los diferentes segmentos en **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    variable = st.selectbox("Selecciona la variable RFM a analizar:", ["Recency", "Frequency", "Monetary"])

    st.markdown(f"üîç Histograma de **{variable}** segmentado por **Cluster_Label** en **{region}**")

    # üö® Diccionario de colores actualizado para los 5 cl√∫steres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # üìä Histograma apilado con Plotly Express
    fig = px.histogram(
        df_region,
        x=variable,
        color="Cluster_Label",
        color_discrete_map=colores_k5,
        title=f"Distribuci√≥n de {variable} por Cl√∫ster ‚Äì {region}",
        labels={variable: variable, "count": "Cantidad de Clientes"}
    )
    # Mejora: El modo `stack` es el valor por defecto, pero se puede explicitar si es necesario
    # fig.update_layout(barmode='stack')
    st.plotly_chart(fig)

    # üß† Interpretaci√≥n autom√°tica
    with st.expander("üß† Ver interpretaci√≥n por cl√∫ster"):
        # üö® Llamada a la nueva funci√≥n de interpretaci√≥n
        interpretar_histograma_rfm(df_region, variable, region)

# üö® Nueva funci√≥n para interpretar los violin plots
def interpretar_violin_rfm(df, variable, region):
    """
    Genera la interpretaci√≥n de un Violin Plot para los clusters RFM.

    Args:
        df (pd.DataFrame): El DataFrame con los datos de clientes.
        variable (str): La variable a interpretar ('Recency', 'Frequency', 'Monetary').
        region (str): La regi√≥n seleccionada.
    """
    st.markdown("### üß† Interpretaci√≥n de la Distribuci√≥n (Violin Plot)")
    st.markdown(f"El ancho del gr√°fico de viol√≠n representa la **densidad de clientes** en cada valor de `{variable}`.")

    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden_clusters:
        # 1. Obtener el subconjunto de datos para el cluster y la variable
        subset = df[df["Cluster_Label"] == label][variable].dropna()

        # 2. üö® VERIFICAR SI EL DATAFRAME EST√Å VAC√çO üö®
        if subset.empty:
            # 3. Si est√° vac√≠o, mostrar un mensaje de advertencia
            st.markdown(f"**{label}**:")
            st.warning(f"No hay clientes para este segmento en la regi√≥n **{region}**.")

        else:
            # 4. Si hay datos, proceder con la l√≥gica de interpretaci√≥n
            media = subset.mean()
            q1 = subset.quantile(0.25)
            q3 = subset.quantile(0.75)
            st.markdown(f"**{label}**:")
            if variable == "Recency":
                if media < 30:
                    st.success(f"- Clientes muy recientes. La mayor√≠a de compras ocurrieron en los √∫ltimos {q1:.0f}-{q3:.0f} d√≠as.")
                elif media > 90:
                    st.warning(f"- Clientes con alta recencia. La mediana se encuentra en **{subset.median():.0f} d√≠as**.")
                else:
                    st.info(f"- Compras en un per√≠odo de tiempo moderado.")
            elif variable == "Frequency":
                if q3 >= 10:
                    st.success(f"- El 75% de los clientes ha realizado **{q3:.0f} o m√°s compras**. Muy alta frecuencia.")
                elif media < 2:
                    st.warning(f"- La mayor√≠a de los clientes solo ha comprado 1 o 2 veces. Alta inactividad.")
                else:
                    st.info(f"- Frecuencia de compra moderada, con un ticket promedio alto.")
            elif variable == "Monetary":
                if subset.median() > 2000:
                    st.success(f"- Alto valor monetario. El 50% de los clientes gast√≥ m√°s de S/ {subset.median():.0f}.")
                else:
                    st.info(f"- Concentraci√≥n de gasto en valores m√°s bajos. Oportunidad de up-selling.")

# üö® Nueva funci√≥n para interpretar los KDE plots
def interpretar_kde_rfm(df, variable, region):
    st.markdown("### üß† Interpretaci√≥n de la Densidad (KDE Plot)")
    st.markdown(f"Las curvas de densidad suavizada (KDE) muestran la **concentraci√≥n de clientes** en los valores de `{variable}`.")
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden_clusters:
        subset = df[df["Cluster_Label"] == label][variable].dropna()
        if not subset.empty:
            media = subset.mean()
            st.markdown(f"**{label}**:")
            if variable == "Recency":
                if media < 30:
                    st.success(f"- La curva tiene un pico en valores bajos, indicando alta concentraci√≥n de clientes recientes.")
                else:
                    st.info(f"- La curva tiene un pico en valores altos, indicando inactividad en la mayor√≠a de clientes.")
            elif variable == "Frequency":
                if media > 5:
                    st.success(f"- La curva se extiende a la derecha, mostrando que muchos clientes compran frecuentemente.")
                else:
                    st.info(f"- La curva se concentra en valores bajos, indicando que la mayor√≠a de clientes tienen pocas compras.")
            elif variable == "Monetary":
                if media > 1000:
                    st.success(f"- La curva muestra una cola larga a la derecha, indicando un grupo de clientes con muy alto gasto.")
                else:
                    st.info(f"- La curva se concentra en valores bajos, indicando que la mayor√≠a de los clientes tienen un gasto menor.")

# --- Bloque para tab10 ---
with tab10:
    st.subheader("üéª An√°lisis de Distribuci√≥n y Densidad por Variable RFM")
    st.caption(f"Explora la dispersi√≥n de m√©tricas RFM seg√∫n el segmento y regi√≥n seleccionada: **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    variable = st.selectbox("üìå Variable a analizar:", ["Recency", "Frequency", "Monetary"], key="var_violin")
    df_region[variable] = pd.to_numeric(df_region[variable], errors="coerce")

    # üö® Nueva paleta y orden oficial de 5 cl√∫steres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    # üéº Violin Plot con Plotly
    st.markdown(f"üéº **Distribuci√≥n tipo Viol√≠n** de `{variable}` por Cl√∫ster")
    fig1 = px.violin(
        df_region,
        x="Cluster_Label",
        y=variable,
        color="Cluster_Label",
        category_orders={"Cluster_Label": orden_clusters},
        color_discrete_map=colores_k5,
        box=True,
        points="all",
        title=f"Violin Plot ‚Äì {variable} por Cl√∫ster ({region})",
        labels={"Cluster_Label": "Segmento", variable: variable}
    )
    st.plotly_chart(fig1)

    with st.expander("üß† Ver interpretaci√≥n del Violin Plot"):
        interpretar_violin_rfm(df_region, variable, region)

    # üìà KDE Plot con Plotly
    st.markdown(f"üìà **Distribuci√≥n Suavizada (KDE)** de `{variable}` por Cl√∫ster")
    fig2 = px.histogram(
        df_region,
        x=variable,
        color="Cluster_Label",
        color_discrete_map=colores_k5,
        marginal="rug",
        title=f"KDE Plot (Aproximado) ‚Äì {variable} por Cl√∫ster ({region})",
        labels={variable: variable, "count": "Cantidad de Clientes"},
        histnorm='density'
    )
    fig2.update_traces(opacity=0.7)
    st.plotly_chart(fig2)

    with st.expander("üß† Ver interpretaci√≥n del KDE Plot"):
        interpretar_kde_rfm(df_region, variable, region)

    # üìä Histograma cl√°sico por cl√∫ster con Plotly
    with st.expander("üìä Visual adicional: Histograma cl√°sico por cl√∫ster"):
        st.markdown("Comparaci√≥n directa de la forma bruta de la distribuci√≥n por segmento.")
        fig3 = px.histogram(
            df_region,
            x=variable,
            color="Cluster_Label",
            color_discrete_map=colores_k5,
            title=f"Histograma Comparativo ‚Äì {variable} ({region})",
            labels={variable: variable, "count": "Cantidad de Clientes"},
            barmode="overlay",
            opacity=0.7
        )
        st.plotly_chart(fig3)

with tab11:
    st.subheader("üåå Visualizaci√≥n 3D de Segmentaci√≥n RFM")
    st.caption(f"Cada punto representa un cliente posicionado en el espacio RFM. Colores indican su cl√∫ster asignado para la regi√≥n **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # ‚úÖ Limpieza de datos num√©ricos
    for var in ["Recency", "Frequency", "Monetary"]:
        df_region[var] = pd.to_numeric(df_region[var], errors="coerce")

    # üìä Conteo por cl√∫ster
    conteo = df_region["Cluster_Label"].value_counts().reset_index()
    conteo.columns = ["Cl√∫ster", "Cantidad de Clientes"]
    st.dataframe(conteo, hide_index=True, use_container_width=True)

    # üö® Se actualiza el orden y los colores para los 5 cl√∫steres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # üéØ Filtro opcional por cl√∫ster
    cluster_focus = st.selectbox(
        "Filtrar por cl√∫ster:",
        ["Todos"] + [c for c in orden if c in df_region["Cluster_Label"].unique()],
        key="filtro_cl3d"
    )

    df_plot = df_region if cluster_focus == "Todos" else df_region[df_region["Cluster_Label"] == cluster_focus]

    # Limpieza de etiquetas para asegurar coincidencia exacta
    df_plot["Cluster_Label"] = df_plot["Cluster_Label"].astype(str).str.strip()

    # Gr√°fico 3D con colores oficiales
    fig = px.scatter_3d(
        df_plot,
        x="Recency",
        y="Frequency",
        z="Monetary",
        color="Cluster_Label",
        # üö® Se usa el nuevo diccionario de colores
        color_discrete_map=colores_k5,
        hover_data=["C_CLIEN", "Recency", "Frequency", "Monetary"],
        opacity=0.75,
        title=f"Segmentaci√≥n RFM en 3D ‚Äì Regi√≥n {region}"
    )

    fig.update_traces(marker=dict(size=4))
    fig.update_layout(
        scene=dict(
            xaxis_title='Recency',
            yaxis_title='Frequency',
            zaxis_title='Monetary'
        ),
        legend_title="Cl√∫ster",
        margin=dict(l=0, r=0, b=0, t=40)
    )

    st.plotly_chart(fig, use_container_width=True)

with tab12:
    st.subheader("üß¨ Mapa de Correlaci√≥n ‚Äì RFM y Variables Predictivas")
    st.caption(f"Analiza la relaci√≥n entre las m√©tricas RFM y las probabilidades de evoluci√≥n de los clientes para la regi√≥n **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # üö® Se usan los nuevos nombres de columnas predictivas
    variables_corr = ["Recency", "Frequency", "Monetary", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce"]

    # Limpieza y validaci√≥n de datos
    df_corr = df_region[variables_corr].apply(pd.to_numeric, errors="coerce").dropna()

    if df_corr.empty:
        st.warning("‚ö†Ô∏è No hay suficientes datos v√°lidos para construir la matriz de correlaci√≥n.")
    else:
        matriz_corr = df_corr.corr()

        fig = go.Figure(data=go.Heatmap(
            z=matriz_corr.values,
            x=matriz_corr.columns,
            y=matriz_corr.index,
            colorscale='Bluered',
            zmin=-1,
            zmax=1,
            showscale=True
        ))

        fig.update_layout(
            title=f"Mapa de Correlaci√≥n ‚Äì {region}",
            xaxis_nticks=len(matriz_corr.columns),
            yaxis_nticks=len(matriz_corr.columns),
            autosize=True,
            margin=dict(l=50, r=50, b=50, t=50)
        )

        # A√±adir anotaciones de texto
        for i in range(len(matriz_corr.index)):
            for j in range(len(matriz_corr.columns)):
                fig.add_annotation(
                    x=matriz_corr.columns[j],
                    y=matriz_corr.index[i],
                    text=f"{matriz_corr.iloc[i, j]:.2f}",
                    showarrow=False,
                    font=dict(color='black' if np.abs(matriz_corr.iloc[i, j]) < 0.5 else 'white')
                )

        st.plotly_chart(fig, use_container_width=True)

        # üß† Interpretaci√≥n autom√°tica
        st.markdown("### üß† Interpretaci√≥n inicial:")

        # üö® An√°lisis de correlaci√≥n de ascenso a Oro
        top_corr_ascenso = matriz_corr["Probabilidad_Ascenso_Oro"].drop("Probabilidad_Ascenso_Oro").sort_values(ascending=False)
        mejor_factor_ascenso = top_corr_ascenso.idxmax()
        valor_max_ascenso = top_corr_ascenso.max()
        st.info(f"üèÜ La m√©trica m√°s correlacionada con la **probabilidad de ascenso a Oro** es **{mejor_factor_ascenso}** (`{valor_max_ascenso:.2f}`). Esto revela un patr√≥n clave para campa√±as de up-selling y escalamiento.")

        # üö® An√°lisis de correlaci√≥n de ca√≠da a Bronce
        top_corr_caida = matriz_corr["Probabilidad_Descenso_Bronce"].drop("Probabilidad_Descenso_Bronce").sort_values(ascending=False)
        mejor_factor_caida = top_corr_caida.idxmax()
        valor_max_caida = top_corr_caida.max()
        st.warning(f"üìâ La m√©trica m√°s correlacionada con la **probabilidad de ca√≠da a Bronce** es **{mejor_factor_caida}** (`{valor_max_caida:.2f}`). Identifica el factor principal de riesgo para campa√±as de retenci√≥n o reactivaci√≥n.")

# üö® Nueva funci√≥n para la interpretaci√≥n del gr√°fico de radar
def interpretar_radar_rfm(df, region):
    st.markdown("### üß† Interpretaci√≥n de los Perfiles RFM")
    st.markdown("Cada eje del gr√°fico de radar representa una m√©trica RFM normalizada. Cuanto m√°s cerca del borde, mayor es el valor promedio del cl√∫ster para esa m√©trica.")

    perfiles = df.groupby("Cluster_Label")[["Recency", "Frequency", "Monetary"]].mean()

    st.markdown("---")
    st.markdown("#### **Perfil Diamante (M√°ximo Valor y Lealtad)**")
    st.markdown("üåü **Recency Baja:** Sus clientes han comprado muy recientemente.")
    st.markdown("üåü **Frequency Alta:** Tienen un alto n√∫mero de compras repetidas.")
    st.markdown("üåü **Monetary Alta:** Generan el mayor valor de ingresos por cliente.")
    st.markdown("Este segmento es la base de clientes m√°s valiosa y leal. La estrategia debe ser la **fidelizaci√≥n extrema** y la **anticipaci√≥n de sus necesidades** para asegurar su permanencia.")

    st.markdown("---")
    st.markdown("#### **Perfil Oro (Alto Valor)**")
    st.markdown("üìà **Recency Baja:** Compran con regularidad y est√°n activos.")
    st.markdown("üìà **Frequency Alta:** Tienen un buen historial de compras.")
    st.markdown("üìà **Monetary Alta:** Su gasto promedio es significativamente alto.")
    st.markdown("Son la segunda base m√°s valiosa. El objetivo es convertirlos en clientes **'Diamante'** a trav√©s de **programas VIP y atenci√≥n personalizada**.")

    st.markdown("---")
    st.markdown("#### **Perfil Plata (Frecuencia Media)**")
    st.markdown("üîÑ **Recency Media:** Su √∫ltima compra no es tan reciente, pero tampoco muy lejana.")
    st.markdown("üîÑ **Frequency Media:** Compran con una frecuencia moderada.")
    st.markdown("üîÑ **Monetary Media:** El gasto por cliente es estable y no alcanza los valores m√°s altos.")
    st.markdown("Este segmento tiene un gran potencial de crecimiento. La estrategia es **impulsar la recurrencia** y el **up-selling** con promociones y recordatorios segmentados.")

    st.markdown("---")
    st.markdown("#### **Perfil Cobre (En Riesgo)**")
    st.markdown("‚ö†Ô∏è **Recency Alta:** Ha pasado mucho tiempo desde su √∫ltima compra.")
    st.markdown("‚ö†Ô∏è **Frequency Baja:** Suelen tener pocas compras.")
    st.markdown("‚ö†Ô∏è **Monetary Baja:** El valor total de su gasto no es muy alto.")
    st.markdown("Este segmento se encuentra en un punto cr√≠tico, con alto riesgo de abandono. Las campa√±as deben centrarse en la **retenci√≥n proactiva** y la **reactivaci√≥n** con ofertas de valor cruzado.")

    st.markdown("---")
    st.markdown("#### **Perfil Bronce (Bajo Valor/Inactivos)**")
    st.markdown("üíî **Recency Muy Alta:** Son clientes inactivos o que han dejado de comprar.")
    st.markdown("üíî **Frequency Baja:** El n√∫mero de compras es muy bajo.")
    st.markdown("üíî **Monetary Baja:** Tienen el menor gasto acumulado.")
    st.markdown("Son clientes de bajo valor. Las campa√±as deben ser de **reactivaci√≥n masiva** con ofertas agresivas para intentar recuperarlos.")


# --- Bloque corregido para tab13 ---
with tab13:
    st.subheader("üß≠ Perfil Comparativo por Cl√∫ster (RFM)")
    st.caption(f"Compara visualmente los promedios normalizados de las m√©tricas RFM por segmento para la regi√≥n **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    variables = ["Recency", "Frequency", "Monetary"]
    df_radar = df_region.groupby("Cluster_Label")[variables].mean().reset_index()

    # Normalizaci√≥n entre 0 y 1 para el radar
    df_norm = df_radar.copy()
    for var in variables:
        min_val = df_radar[var].min()
        max_val = df_radar[var].max()
        rango = max_val - min_val + 1e-8
        df_norm[var] = (df_radar[var] - min_val) / rango

    # üéØ Radar Plot
    fig = go.Figure()
    # üö® Se actualiza el diccionario de colores para los 5 cl√∫steres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }
    # üö® Se actualiza el orden de los cl√∫steres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    df_norm["Cluster_Label"] = pd.Categorical(df_norm["Cluster_Label"], categories=orden, ordered=True)
    df_norm = df_norm.sort_values("Cluster_Label")

    for _, row in df_norm.iterrows():
        fig.add_trace(go.Scatterpolar(
            r=row[variables].values,
            theta=variables,
            fill='toself',
            name=row['Cluster_Label'],
            line=dict(color=colores_k5.get(row['Cluster_Label'], "#888"))
        ))

    fig.update_layout(
        polar=dict(radialaxis=dict(visible=True, range=[0, 1])),
        title=f"Perfiles Normalizados por Cl√∫ster ‚Äì {region}",
        showlegend=True,
        margin=dict(t=50, l=0, r=0, b=0)
    )
    st.plotly_chart(fig, use_container_width=True)

    # üß† Interpretaci√≥n autom√°tica
    interpretar_radar_rfm(df_region, region)

# üö® Nueva funci√≥n de interpretaci√≥n comparativa
def interpretar_comparativa_regional(df):
    st.markdown("### üß† An√°lisis Comparativo Autom√°tico")

    # Aseguramos que las columnas existen para evitar errores
    if "Regi√≥n" not in df.columns or "Cantidad" not in df.columns or "Monto_Total" not in df.columns:
        st.error("Error: Las columnas 'Regi√≥n', 'Cantidad' o 'Monto_Total' no se encuentran en el DataFrame.")
        return

    df_tac = df[df["Regi√≥n"] == "Tacna"]
    df_moq = df[df["Regi√≥n"] == "Moquegua"]

    st.markdown("---")
    st.markdown("#### **An√°lisis de Clientes (Cantidad)**")

    total_tac = df_tac["Cantidad"].sum()
    total_moq = df_moq["Cantidad"].sum()
    st.info(f"üëâ **Tacna** tiene un total de **{total_tac} clientes**, mientras que **Moquegua** tiene **{total_moq} clientes**.")

    if total_tac > total_moq:
        st.success(f"Tacna tiene una base de clientes m√°s grande, lo que sugiere una mayor presencia de mercado.")
    elif total_moq > total_tac:
        st.success(f"Moquegua tiene una base de clientes m√°s grande, indicando una mayor penetraci√≥n en esa regi√≥n.")
    else:
        st.info("Ambas regiones tienen un n√∫mero similar de clientes.")

    st.markdown("---")
    st.markdown("#### **An√°lisis de Valor Monetario**")

    total_monto_tac = df_tac["Monto_Total"].sum()
    total_monto_moq = df_moq["Monto_Total"].sum()
    st.info(f"üëâ El valor total de ingresos en **Tacna** es de **S/ {total_monto_tac:.2f}**, y en **Moquegua** es de **S/ {total_monto_moq:.2f}**.")

    if total_monto_tac > total_monto_moq:
        st.success("A pesar de la base de clientes, Tacna genera un mayor volumen de ingresos total.")
    elif total_monto_moq > total_monto_tac:
        st.success("Moquegua es la regi√≥n que genera el mayor volumen de ingresos total.")
    else:
        st.info("Ambas regiones generan un valor monetario similar.")

    st.markdown("---")
    st.markdown("#### **An√°lisis de Ticket Promedio**")

    # Se calcula el ticket promedio global para cada regi√≥n
    ticket_promedio_tac = df_tac["Monto_Total"].sum() / df_tac["Cantidad"].sum() if df_tac["Cantidad"].sum() > 0 else 0
    ticket_promedio_moq = df_moq["Monto_Total"].sum() / df_moq["Cantidad"].sum() if df_moq["Cantidad"].sum() > 0 else 0
    st.info(f"üëâ El ticket promedio global es de **S/ {ticket_promedio_tac:.2f}** en Tacna y **S/ {ticket_promedio_moq:.2f}** en Moquegua.")

    if ticket_promedio_tac > ticket_promedio_moq:
        st.success("El ticket promedio por cliente es m√°s alto en Tacna, lo que sugiere clientes con mayor capacidad de gasto.")
    elif ticket_promedio_moq > ticket_promedio_tac:
        st.success("El ticket promedio por cliente es m√°s alto en Moquegua, lo que indica que los clientes gastan m√°s por transacci√≥n.")
    else:
        st.info("El ticket promedio es similar en ambas regiones.")


# --- Bloque corregido para tab14 ---
with tab14:
    st.subheader("‚öñÔ∏è Diagn√≥stico Comparativo entre Regiones")
    st.caption("Analiza c√≥mo se comportan los segmentos RFM entre Tacna y Moquegua en t√©rminos de volumen, valor monetario y ticket promedio.")

    # Aseg√∫rate de tener los DataFrames df_tac y df_moq definidos globalmente o pasados
    # de lo contrario, esto fallar√°. Asumiendo que est√°n definidos.
    # df_tac = ...
    # df_moq = ...

    # üîç Agrupaci√≥n por regi√≥n y cl√∫ster
    resumen_tac = df_tac.groupby("Cluster_Label").agg(
        Cantidad=("C_CLIEN", "count"),
        Monto_Total=("Monetary", "sum"),
        Ticket_Promedio=("Monetary", "mean")
    ).reset_index()
    resumen_tac["Regi√≥n"] = "Tacna"

    resumen_moq = df_moq.groupby("Cluster_Label").agg(
        Cantidad=("C_CLIEN", "count"),
        Monto_Total=("Monetary", "sum"),
        Ticket_Promedio=("Monetary", "mean")
    ).reset_index()
    resumen_moq["Regi√≥n"] = "Moquegua"

    resumen_total = pd.concat([resumen_tac, resumen_moq], ignore_index=True)

    # üö® Se actualiza el orden de los cl√∫steres a 5
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    # Filtra los cl√∫steres que no existen en el DataFrame antes de crear la categor√≠a
    resumen_total_filtered = resumen_total[resumen_total["Cluster_Label"].isin(orden)]
    resumen_total_filtered["Cluster_Label"] = pd.Categorical(resumen_total_filtered["Cluster_Label"], categories=orden, ordered=True)
    resumen_total_filtered = resumen_total_filtered.sort_values(["Cluster_Label", "Regi√≥n"])


    # üé® Gr√°fico: Distribuci√≥n de clientes por cl√∫ster y regi√≥n
    st.markdown("### üìä Distribuci√≥n de Clientes por Cl√∫ster")
    fig1 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Cantidad",
        color="Regi√≥n",
        barmode="group",
        text="Cantidad",
        title="Cantidad de Clientes por Cl√∫ster y Regi√≥n",
        color_discrete_sequence=px.colors.qualitative.Set2
    )
    st.plotly_chart(fig1, use_container_width=True)

    # üí∞ Gr√°fico: Monto total por cl√∫ster y regi√≥n
    st.markdown("### üí∞ Valor Monetario Total por Cl√∫ster")
    fig2 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Monto_Total",
        color="Regi√≥n",
        barmode="group",
        text_auto=".2s",
        title="Suma Total de Consumo por Regi√≥n y Cl√∫ster",
        color_discrete_sequence=px.colors.qualitative.Set3
    )
    st.plotly_chart(fig2, use_container_width=True)

    # üéüÔ∏è Gr√°fico: Ticket promedio
    st.markdown("### üéüÔ∏è Ticket Promedio por Cl√∫ster")
    fig3 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Ticket_Promedio",
        color="Regi√≥n",
        barmode="group",
        text_auto=".2f",
        title="Comparaci√≥n de Ticket Promedio",
        color_discrete_sequence=px.colors.qualitative.Safe
    )
    st.plotly_chart(fig3, use_container_width=True)

    # üìë Tabla resumen y exportaci√≥n
    st.markdown("### üßæ Tabla Resumen Gerencial")
    resumen_formato = resumen_total_filtered.copy()
    resumen_formato["Ticket_Promedio"] = resumen_formato["Ticket_Promedio"].round(2)
    resumen_formato["Monto_Total"] = resumen_formato["Monto_Total"].round(2)
    st.dataframe(resumen_formato, use_container_width=True)

    # üß† Interpretaci√≥n comparativa autom√°tica
    interpretar_comparativa_regional(resumen_total_filtered)

    # üì• Bot√≥n de descarga Excel
    excel_buf = io.BytesIO()
    resumen_formato.to_excel(excel_buf, index=False)
    excel_buf.seek(0)

    st.download_button(
        "üì• Descargar Comparativa Regional",
        data=excel_buf,
        file_name="Comparativa_Regional_Tacna_vs_Moquegua.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

def cargar_csv_desde_zip(region_slug):
    """Funci√≥n simulada para cargar datos de ventas.
    En una implementaci√≥n real, se adaptar√≠a."""
    try:
        df_ventas = pd.read_csv("clientes_segmentados_moquegua.csv")
        df_ventas = df_ventas.rename(columns={"Monetary": "TOTAL_VENTA", "Recency": "FECHA"})
        df_ventas["FECHA"] = pd.to_datetime(df_ventas["FECHA"], unit="D", origin="2024-01-01")
        return df_ventas
    except FileNotFoundError:
        st.error(f"‚ùå No se encontr√≥ el archivo de ventas para la regi√≥n {region_slug}.")
        return None

with tab15:
    st.subheader("üìÜ Evoluci√≥n Mensual de Clientes y Predicci√≥n Estrat√©gica")
    st.caption(f"Eval√∫a el comportamiento mensual de clientes en la regi√≥n **{region}** seg√∫n perfil predictivo.")

    region_slug = region.lower()
    df_ventas = cargar_csv_desde_zip(region_slug)

    if df_ventas is None:
        st.stop()
    else:
        st.success(f"‚úÖ Datos cargados correctamente para {region}")

    df_ventas["FECHA"] = pd.to_datetime(df_ventas["FECHA"], errors="coerce")
    fechas_validas = df_ventas["FECHA"].notna().sum()
    st.caption(f"üóìÔ∏è Fechas v√°lidas detectadas: {fechas_validas:,}")
    if fechas_validas == 0:
        st.error("‚ùå Ninguna fecha v√°lida fue detectada en los datos de ventas.")
        st.stop()

    df_ventas["PERIODO_MES"] = df_ventas["FECHA"].dt.to_period("M").astype(str)

    df_cluster = df_tac.copy() if region == "Tacna" else df_moq.copy()
    df_ventas["C_CLIEN"] = df_ventas["C_CLIEN"].astype(str)
    df_cluster["C_CLIEN"] = df_cluster["C_CLIEN"].astype(str)

    # üö® Correcci√≥n: Asegura que las columnas de probabilidad existan antes de usarlas.
    # Esto maneja el caso donde el archivo de datos original no las tiene.
    if "Probabilidad_Ascenso_Oro" not in df_cluster.columns and "Probabilidad_Ascenso" in df_cluster.columns:
        df_cluster = df_cluster.rename(columns={"Probabilidad_Ascenso": "Probabilidad_Ascenso_Oro"})

    if "Probabilidad_Descenso_Bronce" not in df_cluster.columns and "Probabilidad_Bronce" in df_cluster.columns:
        df_cluster = df_cluster.rename(columns={"Probabilidad_Bronce": "Probabilidad_Descenso_Bronce"})

    df_cluster["Probabilidad_Ascenso_Oro"] = pd.to_numeric(df_cluster["Probabilidad_Ascenso_Oro"], errors="coerce")
    df_cluster["Probabilidad_Descenso_Bronce"] = pd.to_numeric(df_cluster["Probabilidad_Descenso_Bronce"], errors="coerce")

    df_full = df_ventas.merge(df_cluster, on="C_CLIEN", how="inner")
    st.write(f"üîç Registros tras el merge: {len(df_full):,}")
    if df_full.empty:
        st.warning("‚ö†Ô∏è No hay coincidencias entre ventas y clustering.")
        st.stop()

    def clasificar_segmento(row):
        if row["Probabilidad_Ascenso_Oro"] >= 0.8 and row["Probabilidad_Descenso_Bronce"] <= 0.3:
            return "Cliente Estrella"
        elif row["Probabilidad_Ascenso_Oro"] < 0.5 and row["Probabilidad_Descenso_Bronce"] >= 0.7:
            return "Riesgo de Abandono"
        elif 0.5 <= row["Probabilidad_Ascenso_Oro"] < 0.8 and 0.3 < row["Probabilidad_Descenso_Bronce"] < 0.7:
            return "Zona de Desarrollo"
        else:
            return "Segmento Estable"

    df_full["Segmento Estrat√©gico"] = df_full.apply(clasificar_segmento, axis=1)

    periodos_disponibles = sorted(df_full["PERIODO_MES"].dropna().unique())
    if len(periodos_disponibles) == 0:
        st.warning("‚ö†Ô∏è No hay periodos v√°lidos tras la fusi√≥n.")
        st.stop()

    periodo_ini, periodo_fin = st.select_slider(
        "Selecciona el rango de meses a analizar:",
        options=periodos_disponibles,
        value=(periodos_disponibles[0], periodos_disponibles[-1])
    )
    df_full = df_full[df_full["PERIODO_MES"].between(periodo_ini, periodo_fin)]

    resumen_mensual = df_full.groupby("PERIODO_MES").agg(
        Prom_Ascenso=("Probabilidad_Ascenso_Oro", "mean"),
        Prom_Caida=("Probabilidad_Descenso_Bronce", "mean"),
        Total_Clientes=("C_CLIEN", "nunique")
    ).reset_index()

    fig1 = go.Figure()
    fig1.add_trace(go.Scatter(x=resumen_mensual["PERIODO_MES"], y=resumen_mensual["Prom_Ascenso"],
                              name='Prob. Ascenso a Oro', mode='lines+markers', line=dict(color="green")))
    fig1.add_trace(go.Scatter(x=resumen_mensual["PERIODO_MES"], y=resumen_mensual["Prom_Caida"],
                              name='Prob. Ca√≠da a Bronce', mode='lines+markers', line=dict(color="firebrick")))
    fig1.update_layout(title="üìà Probabilidad Predictiva Promedio Mensual", xaxis_title="Mes", yaxis_title="Probabilidad")
    st.plotly_chart(fig1, use_container_width=True)

    if "Recency" in df_full.columns:
        df_full["Recency"] = pd.to_numeric(df_full["Recency"], errors="coerce")
        recency_mensual = df_full.groupby("PERIODO_MES")["Recency"].mean().reset_index()

        fig_rec = go.Figure()
        fig_rec.add_trace(go.Scatter(
            x=recency_mensual["PERIODO_MES"],
            y=recency_mensual["Recency"],
            mode='lines+markers',
            line=dict(color="royalblue")
        ))
        fig_rec.update_layout(
            title="üìâ Recencia Promedio (d√≠as sin compra)",
            xaxis_title="Mes",
            yaxis_title="D√≠as sin Compra"
        )
        st.plotly_chart(fig_rec, use_container_width=True)

    st.markdown("### üß≠ Evoluci√≥n de Segmento Estrat√©gico")
    dist_segmento = df_full.groupby(["PERIODO_MES", "Segmento Estrat√©gico"]).agg(
        Cantidad=("C_CLIEN", "nunique")
    ).reset_index()
    total_mes = df_full.groupby("PERIODO_MES")["C_CLIEN"].nunique().reset_index(name="Total")
    dist_segmento = dist_segmento.merge(total_mes, on="PERIODO_MES")
    dist_segmento["%"] = 100 * dist_segmento["Cantidad"] / dist_segmento["Total"]

    fig2 = px.area(
        dist_segmento,
        x="PERIODO_MES", y="%", color="Segmento Estrat√©gico",
        groupnorm="percent",
        color_discrete_sequence=px.colors.qualitative.Pastel,
        title="üìä Distribuci√≥n de Segmentos Estrat√©gicos por Mes"
    )
    st.plotly_chart(fig2, use_container_width=True)

    with st.expander("üß† Ver interpretaci√≥n de tendencias"):
        if not resumen_mensual.empty:
            mes_max = resumen_mensual.loc[resumen_mensual["Prom_Ascenso"].idxmax(), "PERIODO_MES"]
            max_asc = resumen_mensual["Prom_Ascenso"].max()
            mes_min = resumen_mensual.loc[resumen_mensual["Prom_Caida"].idxmin(), "PERIODO_MES"]
            min_caida = resumen_mensual["Prom_Caida"].min()
            top_seg = dist_segmento.groupby("Segmento Estrat√©gico")["Cantidad"].sum().idxmax()

            st.markdown(f"- üü¢ Mayor ascenso promedio a Oro: **{mes_max}** (`{max_asc:.2f}`)")
            st.markdown(f"- ‚úÖ Menor riesgo de ca√≠da a Bronce: **{mes_min}** (`{min_caida:.2f}`)")
            st.markdown(f"- üìå Segmento m√°s frecuente: **{top_seg}**")
        else:
            st.info("No hay datos suficientes en el rango de fechas seleccionado.")

    excel_buf = io.BytesIO()
    resumen_mensual.to_excel(excel_buf, index=False)
    excel_buf.seek(0)

    st.download_button(
        label="üì§ Descargar Excel de Evoluci√≥n Mensual",
        data=excel_buf,
        file_name=f"Evolucion_Predictiva_{region}.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

    with st.expander("üîé Consulta de comportamiento por cliente espec√≠fico"):
        clientes_disponibles = sorted(df_full["C_CLIEN"].unique())

        if not clientes_disponibles:
            st.info("No hay clientes disponibles en el per√≠odo y regi√≥n seleccionados.")
        else:
            cod_cliente = st.selectbox(
                "Selecciona un cliente:",
                clientes_disponibles,
                key="cliente_selector"
            )

            df_cliente = df_full[df_full["C_CLIEN"] == cod_cliente]

            if df_cliente.empty:
                st.warning("‚ö†Ô∏è Cliente no encontrado en los datos actuales.")
            else:
                st.markdown(f"### üìå Evoluci√≥n mensual para cliente **{cod_cliente}**")

                fig_ind = go.Figure()
                fig_ind.add_trace(go.Scatter(
                    x=df_cliente["PERIODO_MES"],
                    y=df_cliente["Probabilidad_Ascenso_Oro"],
                    name="Prob. Ascenso a Oro",
                    mode="lines+markers",
                    line=dict(color="green")
                ))
                fig_ind.add_trace(go.Scatter(
                    x=df_cliente["PERIODO_MES"],
                    y=df_cliente["Probabilidad_Descenso_Bronce"],
                    name="Prob. Ca√≠da a Bronce",
                    mode="lines+markers",
                    line=dict(color="firebrick")
                ))
                fig_ind.update_layout(
                    xaxis_title="Mes",
                    yaxis_title="Probabilidad",
                    title="üìà Perfil predictivo individual por mes"
                )
                st.plotly_chart(fig_ind, use_container_width=True)

                if "Recency" in df_cliente.columns and df_cliente["Recency"].notna().any():
                    fig_ind_rec = go.Figure()
                    fig_ind_rec.add_trace(go.Scatter(
                        x=df_cliente["PERIODO_MES"],
                        y=df_cliente["Recency"],
                        mode="lines+markers",
                        name="Recency",
                        line=dict(color="royalblue")
                    ))
                    fig_ind_rec.update_layout(
                        title="üìâ Recencia mensual (d√≠as sin compra)",
                        xaxis_title="Mes",
                        yaxis_title="D√≠as sin Compra"
                    )
                    st.plotly_chart(fig_ind_rec, use_container_width=True)

                buf_cliente = io.BytesIO()
                df_export = df_cliente[["PERIODO_MES", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce", "Recency"]].copy()
                df_export.columns = ["Mes", "Probabilidad de Ascenso a Oro", "Probabilidad de Ca√≠da a Bronce", "Recencia (d√≠as)"]
                df_export.to_excel(buf_cliente, index=False)
                buf_cliente.seek(0)

                st.download_button(
                    label="üì§ Descargar historial de este cliente",
                    data=buf_cliente,
                    file_name=f"Historial_Cliente_{cod_cliente}_{region}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )

                st.caption("Puedes comparar estas curvas con el promedio regional para detectar oportunidades de intervenci√≥n temprana.")

with tab16:
    st.subheader("üìå Estrategias Sugeridas por Cl√∫ster")
    st.caption(f"Estrategias basadas en la distribuci√≥n actual de clientes en **{region}**")

    # üîç Selecci√≥n din√°mica del DataFrame seg√∫n regi√≥n
    # Aseg√∫rate de que df_tac y df_moq est√°n definidos en el √°mbito global o en el contexto de tu aplicaci√≥n Streamlit
    try:
        df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    except NameError:
        st.error("Error: Los DataFrames 'df_tac' o 'df_moq' no est√°n definidos. Aseg√∫rate de cargarlos previamente.")
        st.stop()

    df_region["Cluster_Label"] = df_region["Cluster_Label"].fillna("Desconocido")
    total = df_region["C_CLIEN"].nunique()

    # üö® Se actualiza el orden y la paleta para 5 cl√∫steres
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "blue",
        "Oro": "gold",
        "Plata": "silver",
        "Cobre": "#B87333",
        "Bronce": "brown"
    }

    # üßÆ Conteo por segmento
    conteo = df_region.groupby("Cluster_Label")["C_CLIEN"].nunique().reindex(orden_clusters).fillna(0).astype(int)

    st.markdown("### üìä Distribuci√≥n actual de clientes")

    col1, col2, col3, col4, col5, col6 = st.columns(6)
    col1.metric("üë• Totales", f"{total:,}")
    col2.metric("üíé Diamante", f"{conteo['Diamante']:,}")
    col3.metric("üü° Oro", f"{conteo['Oro']:,}")
    col4.metric("‚ö™ Plata", f"{conteo['Plata']:,}")
    col5.metric("üü† Cobre", f"{conteo['Cobre']:,}")
    col6.metric("üü§ Bronce", f"{conteo['Bronce']:,}")

    st.markdown("---")
    st.markdown("üß† Estas recomendaciones se basan en el perfil de valor y comportamiento transaccional de cada cl√∫ster:")

    col1, col2 = st.columns(2)
    with col1:
        st.markdown("### üíé Diamante")
        st.success("Clientes de m√°ximo valor y lealtad")
        st.markdown("""
- ü§ù **Relaci√≥n exclusiva:** Trato preferencial, acceso a eventos privados.
- üéÅ **Servicios a medida:** Ofertas personalizadas, productos exclusivos.
- üí¨ **Feedback directo:** Considerar sus opiniones para la mejora del negocio.
- üéâ **Celebraciones:** Felicitaciones en fechas especiales, detalles de alto valor.
""")

    with col2:
        st.markdown("### üü° Oro")
        st.info("Clientes muy valiosos y recurrentes")
        st.markdown("""
- ü•á **Up-selling:** Incentivos para aumentar su ticket promedio.
- üéÅ **Recompensas VIP:** Programas de lealtad por puntos, beneficios tangibles.
- üìû **Atenci√≥n preferente:** Canal de soporte r√°pido y eficaz.
- üõí **Recomendaciones:** Productos complementarios que ya son de su inter√©s.
""")

    st.markdown("---")

    col1, col2 = st.columns(2)
    with col1:
        st.markdown("### ‚ö™ Plata")
        st.info("Clientes con potencial de crecimiento")
        st.markdown("""
- üìà **Activaci√≥n de frecuencia:** Cupones o descuentos por compras repetidas.
- üí° **Recomendaciones:** Sugerir productos con buen margen para aumentar el valor.
- üìß **Comunicaci√≥n constante:** Newsletters con contenido de valor y promociones.
- üõçÔ∏è **Bundles de productos:** Ofertas por la compra de paquetes de productos.
""")

    with col2:
        st.markdown("### üü† Cobre")
        st.warning("Clientes con riesgo de inactividad")
        st.markdown("""
- üîÑ **Reactivaci√≥n:** Campa√±as de email/SMS/WhatsApp para traerlos de vuelta.
- üéÅ **Ofertas agresivas:** Descuentos o promociones exclusivas para su siguiente compra.
- üîé **Identificaci√≥n de dolor:** Encuestas para entender por qu√© baj√≥ su frecuencia.
- ‚è≥ **Urgency marketing:** Ofertas de tiempo limitado para motivar la compra.
""")

    st.markdown("---")
    st.markdown("### üü§ Bronce")
    st.warning("Clientes inactivos o de bajo valor")
    st.markdown("""
- üìâ **Coste-efectividad:** No invertir grandes recursos, enfocarse en campa√±as masivas.
- üéØ **Ofertas de entrada:** Promociones muy bajas para una primera (o segunda) compra.
- üóëÔ∏è **Limpieza de base:** Considerar su eliminaci√≥n de listas de marketing si no hay respuesta.
- üì£ **Awareness:** Mantener la marca en su mente con contenido de bajo coste.
""")


    st.markdown("---")
    st.caption("Estas estrategias est√°n alineadas con el an√°lisis RFM y patrones hist√≥ricos de clientes en cada regi√≥n.")

    # üîÆ Recomendaciones predictivas por perfil
    st.markdown("### üß≠ Recomendaciones seg√∫n Cuadrante Estrat√©gico (Predicci√≥n de Evoluci√≥n)")

    with st.expander("üìâ Ver estrategias por perfil de riesgo y ascenso"):
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### üü¢ Cliente Estrella")
            st.success("Alta probabilidad de ascenso, bajo riesgo de ca√≠da")
            st.markdown("""
- üéØ **Activaci√≥n inmediata de beneficios:** Activar beneficios 'Oro' o 'Diamante'.
- üõçÔ∏è **Ofertas personalizadas:** Incentivar la recompra con productos exclusivos.
- üß† **Feedback directo:** Recopilar sus opiniones para mejorar la experiencia.
- ü™Ñ **Recomendaciones cruzadas:** Sugerir productos de alto valor que a√∫n no ha probado.
""")

            st.markdown("### üü° Zona de Desarrollo")
            st.info("Valores intermedios, potencial latente")
            st.markdown("""
- ü§ù **Acompa√±amiento:** Campa√±as educativas sobre el uso de otros productos.
- üìà **Probar upgrades:** Ofrecer descuentos para motivar compras de mayor valor.
- üí¨ **Encuestas o din√°micas:** Activar su inter√©s con contenido interactivo.
- üìä **Monitoreo peri√≥dico:** Evaluar su evoluci√≥n de cl√∫ster trimestralmente.
""")

        with col2:
            st.markdown("### üî¥ Riesgo de Abandono")
            st.warning("Alta probabilidad de ca√≠da")
            st.markdown("""
- üö® **Campa√±as urgentes de retenci√≥n:** Incentivos agresivos para una compra inmediata.
- üß≤ **Incentivos de regreso:** Ofrecer cupones de alto valor o descuentos significativos.
- üìû **Llamadas o mensajes directos:** Contacto personal para recuperar al cliente.
- üîç **Evaluaci√≥n de fricciones:** Analizar si hubo un problema o mala experiencia de servicio.
""")

            st.markdown("### ‚ö™ Segmento Estable")
            st.info("Bajo ascenso y bajo riesgo")
            st.markdown("""
- ü§ñ **Automatizaci√≥n de marketing:** Mantenerlos informados con newsletters y contenido.
- üîÑ **Reforzar el awareness:** Recordar la marca con contenido √∫til y relevante.
- üß≠ **Potencial de activaci√≥n:** Promociones selectivas para motivar la compra.
- ‚è±Ô∏è **Revisi√≥n trimestral:** Monitorear su comportamiento para detectar cambios.
""")

        st.caption("Basado en la matriz predictiva de ascenso a **Oro** y ca√≠da a **Bronce** desarrollada en la pesta√±a de evoluci√≥n.")

with tab17:
    st.subheader("üìò Manual de Navegaci√≥n y Uso Estrat√©gico")
    st.caption("Recomendaciones para interpretar, navegar y aprovechar al m√°ximo el dashboard.")

    with st.expander("ÔøΩ ¬øCu√°l es el objetivo general del dashboard?"):
        st.markdown("""
Este sistema fue dise√±ado para **explorar, segmentar, predecir y activar estrategias** sobre clientes a partir de informaci√≥n transaccional, con enfoque regional en **Tacna** y **Moquegua**.

- Aplica an√°lisis RFM (Recency, Frequency, Monetary)
- Integra **clustering de 5 segmentos** y an√°lisis de evoluci√≥n
- Permite exportaci√≥n y activaci√≥n de campa√±as
""")

    with st.expander("üß≠ ¬øC√≥mo est√° estructurado el dashboard?"):
        st.markdown("""
- **Tabs 1‚Äì5:** Validaci√≥n inicial de cl√∫steres y m√©tricas RFM
- **Tabs 6‚Äì8:** Identificaci√≥n, alerta y predicci√≥n de comportamiento
- **Tabs 9‚Äì11:** Exploraci√≥n de distribuci√≥n por variable y segmento
- **Tabs 12‚Äì14:** Correlaci√≥n, perfiles y comparativa regional
- **Tab 15:** Evoluci√≥n temporal estrat√©gica de clientes
- **Tab 16:** Recomendaciones estrat√©gicas
- **Tab 17:** Esta gu√≠a interactiva
""")

    with st.expander("üí° ¬øQu√© buenas pr√°cticas debo seguir?"):
        st.markdown("""
- Selecciona siempre la **regi√≥n** antes de explorar
- Ajusta los **umbrales de riesgo y ascenso** seg√∫n el escenario
- Exporta datos con los botones üì• donde est√©n disponibles
- Revisa las interpretaciones bajo expanders üß† para mayor contexto
""")

    with st.expander("üìé ¬øQu√© tipo de campa√±as se recomiendan seg√∫n el perfil del cliente?"):
        st.markdown("""
- üíé **Diamante:** Fidelizaci√≥n extrema y servicios exclusivos.
- üü° **Oro:** Fidelizaci√≥n avanzada y beneficios exclusivos.
- ‚ö™ **Plata:** Incentivo a la frecuencia y seguimiento.
- üü† **Cobre:** Intervenci√≥n proactiva para evitar la inactividad.
- üü§ **Bronce:** Reactivaci√≥n o atenci√≥n cautiva.
- üß≠ **Cliente Estrella:** Activaci√≥n de recompensas inmediatas.
- üî¥ **Riesgo:** Contacto urgente o incentivo de retenci√≥n.
- ‚ö™ **Estables:** Automatizaci√≥n y monitoreo pasivo.
""")

    st.markdown("---")
    st.caption("üìå Esta gu√≠a est√° dise√±ada para onboarding de analistas, equipos comerciales y responsables regionales.")