# -*- coding: utf-8 -*-
"""app4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGlpDJrQS46Az5I9p71qRZUSioljahMx
"""

import streamlit as st
st.set_page_config(layout="wide")

st.write("âœ… App iniciada correctamente â€“ Tablero App3")

import seaborn as sns
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import io
from datetime import datetime
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import MiniBatchKMeans
from sklearn.metrics import silhouette_score
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.drawing.image import Image as XLImage
import zipfile, os

def cargar_csv_desde_zip(empresa="adargar", region="tacna"):
    """
    Carga un archivo CSV de ventas desde un archivo ZIP.
    """
    # Construir el nombre del archivo ZIP y del CSV interno
    archivo_zip = f"sales_{empresa.lower()}_{region.lower()}_2024_2025.zip"
    nombre_csv = f"sales_{empresa.lower()}_{region.lower()}_2024_2025.csv"

    # Verificar si el archivo ZIP existe en el directorio de la app
    if not os.path.exists(archivo_zip):
        st.error(f"âŒ No se encontrÃ³ el archivo: {archivo_zip}")
        return None

    try:
        with zipfile.ZipFile(archivo_zip) as zf:
            with zf.open(nombre_csv) as file:
                df = pd.read_csv(file, dtype={"COD_PRO": str})
        return df
    except Exception as e:
        st.error(f"âš ï¸ Error al leer el archivo {nombre_csv} dentro del ZIP: {e}")
        return None

# ğŸ“¦ 1. Cargar datasets de segmentaciÃ³n por regiÃ³n
df_tac = pd.read_csv("clientes_segmentados_tacna.csv", encoding="utf-8")
df_moq = pd.read_csv("clientes_segmentados_moquegua.csv", encoding="utf-8")

# ğŸ§¼ 2. Corregir formato y encoding
# Los nuevos archivos tienen encabezados y codificaciÃ³n correctos.
df_tac.rename(columns=lambda col: col.strip(), inplace=True)
df_moq.rename(columns=lambda col: col.strip(), inplace=True)

# ğŸ” 3. Unificar ambos en un solo DataFrame para entrenamiento
rfm = pd.concat([df_tac, df_moq], ignore_index=True)
rfm.columns = rfm.columns.str.strip()

# ğŸ§  4. Entrenamiento predictivo
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split

# Validar columna de clÃºster. Ahora el clÃºster objetivo es 'Cluster_Label'.
if "Cluster_Label" in rfm.columns:
    y = rfm["Cluster_Label"]
else:
    raise ValueError("âš ï¸ No se encontrÃ³ la columna 'Cluster_Label' para el entrenamiento.")

X = rfm[["Recency", "Frequency", "Monetary"]]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

modelo = RandomForestClassifier(n_estimators=100, random_state=42)
modelo.fit(X_train, y_train)

# ğŸ“ˆ 5. Aplicar predicciÃ³n y probabilidades
rfm["Cluster_Predicho"] = modelo.predict(X)
rfm["Probabilidades"] = modelo.predict_proba(X).tolist()

# ğŸ§­ 6. Mapear Ã­ndices de clÃºsteres
# Crear un mapeo de etiquetas a Ã­ndices para las probabilidades
etiquetas_modelo = list(modelo.classes_)
idx_oro = etiquetas_modelo.index("Oro")
idx_bronce = etiquetas_modelo.index("Bronce")
idx_cobre = etiquetas_modelo.index("Cobre")
idx_plata = etiquetas_modelo.index("Plata")
idx_diamante = etiquetas_modelo.index("Diamante")

# ğŸ§® 7. Calcular probabilidades predictivas
rfm["Probabilidad_Ascenso_Oro"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_oro], 4))
rfm["Probabilidad_Ascenso_Plata"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_plata], 4))
rfm["Probabilidad_Descenso_Cobre"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_cobre], 4))
rfm["Probabilidad_Descenso_Bronce"] = rfm["Probabilidades"].apply(lambda p: round(p[idx_bronce], 4))

# ğŸ’¾ 8. Actualizar df_tac y df_moq ya enriquecidos con predicciÃ³n
df_tac = rfm[rfm["Region"] == "Tacna"].copy()
df_moq = rfm[rfm["Region"] == "Moquegua"].copy()

# âœ… Validaciones de columnas crÃ­ticas por regiÃ³n
assert "Cluster_Label" in df_tac.columns and df_tac["Cluster_Label"].notna().all(), "âŒ Falta columna o hay valores nulos en df_tac['Cluster_Label']"
assert "Cluster_Label" in df_moq.columns and df_moq["Cluster_Label"].notna().all(), "âŒ Falta columna o hay valores nulos en df_moq['Cluster_Label']"

for col in ["Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce"]:
    assert col in df_tac.columns and df_tac[col].notna().all(), f"âŒ Falta columna o hay valores nulos en df_tac['{col}']"
    assert col in df_moq.columns and df_moq[col].notna().all(), f"âŒ Falta columna o hay valores nulos en df_moq['{col}']"

# ğŸ¨ Diccionario de colores y estrategias para 5 clÃºsteres
colores_k5 = {
    "Diamante": "#00FFFF",
    "Oro": "#FFD700",
    "Plata": "#C0C0C0",
    "Cobre": "#B87333",
    "Bronce": "#CD7F32"
}

estrategias = {
    "Diamante": "ğŸ’ Crecimiento y retenciÃ³n: programas de lealtad exclusivos y anticipaciÃ³n de necesidades.",
    "Oro": "ğŸ“ˆ Fidelizar y potenciar: promociones exclusivas y membresÃ­as premium.",
    "Plata": "ğŸ¤ Incentivar y escalar: motivar recurrencia con descuentos personalizados.",
    "Cobre": "ğŸ’¡ Oportunidad de venta: enfoque en productos complementarios y reactivaciÃ³n con ofertas de valor.",
    "Bronce": "ğŸ§² Reactivar: campaÃ±as de recuperaciÃ³n o win-back por inactividad."
}

# ğŸ”· TÃ­tulo central del dashboard
st.markdown("""
    <h1 style='text-align: center; color: #003366; margin-bottom: 0.2em;'>
        Dashboard Predictivo â€“ Adargar-Tacna SRL
    </h1>
    <h4 style='text-align: center; color: gray; font-weight: normal; margin-top: 0;'>
        AnÃ¡lisis y estrategias por segmento RFM
    </h4>
    <hr style='margin-top: 0.5em; margin-bottom: 1.5em;'>
""", unsafe_allow_html=True)

# ğŸ“‹ DefiniciÃ³n de las 17 pestaÃ±as del dashboard
tabs = st.tabs([
    "ğŸ’  DispersiÃ³n RFM",
    "ğŸ“Š EstadÃ­sticas RFM por ClÃºster",
    "ğŸ“¦ DistribuciÃ³n de Clientes por Segmento",
    "ğŸ’¼ Recomendaciones por Segmento",
    "ğŸ“Š Boxplots RFM",
    "ğŸ… Clientes de Alto Valor",
    "ğŸ›ï¸ Clientes con Recencia CrÃ­tica por Segmento",
    "ğŸ”® PredicciÃ³n de EvoluciÃ³n de Clientes",
    "ğŸ“Š Histogramas RFM por ClÃºster",
    "ğŸ» Densidad y DispersiÃ³n por ClÃºster",
    "ğŸŒŒ Scatter 3D RFM por ClÃºster",
    "ğŸ§¬ Mapa de CorrelaciÃ³n (RFM & PredicciÃ³n)",
    "ğŸ§­ Radar de Perfiles RFM por ClÃºster",
    "âš–ï¸ Comparativa Regional Tacna vs Moquegua",
    "ğŸ“† EvoluciÃ³n Temporal EstratÃ©gica",
    "ğŸ“Œ Recomendaciones EstratÃ©gicas",
    "ğŸ“˜ GuÃ­a de Usuario"
])
(tab1, tab2, tab3, tab4, tab5, tab6, tab7, tab8, tab9, tab10,
 tab11, tab12, tab13, tab14, tab15, tab16, tab17) = tabs

# ğŸ§  FunciÃ³n robusta para ordenar segmentos con validaciÃ³n
def ordenar_segmentos_seguro(df_agrupado, orden=None, nombre_var="Cluster_Label"):
    if orden is None:
        orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    if not isinstance(df_agrupado.index, pd.Index):
        st.warning(f"âš ï¸ El objeto proporcionado no tiene un Ã­ndice vÃ¡lido.")
        return df_agrupado

    if not set(orden).issubset(df_agrupado.index):
        st.warning(f"âš ï¸ Algunos segmentos de {orden} no estÃ¡n presentes en el Ã­ndice actual.")
        # Intentar reordenar con los segmentos que sÃ­ existen
        presentes = [s for s in orden if s in df_agrupado.index]
        return df_agrupado.reindex(presentes)

    return df_agrupado.reindex(orden)

# ğŸ§­ Layout general y encabezado inicial
# st.set_page_config(layout="wide") # Ya se estableciÃ³ en un bloque anterior

# st.title("ğŸ“Š Dashboard Predictivo â€“ Comercial Adargar")
# st.caption("AnÃ¡lisis estratÃ©gico de clientes basado en RFM, clustering y modelos de evoluciÃ³n (2024â€“2025)")

# st.write("âœ… App iniciada correctamente â€“ App4")

# ğŸ›ï¸ Sidebar profesional

with st.sidebar:
    # AsegÃºrate de tener el logo de Adargar en la carpeta de tu repositorio
    st.image("logo_adargar.jpg", width=190)

    st.markdown("### ğŸ“Š App4 â€“ EvoluciÃ³n Inteligente de Clientes para Adargar-Tacna")
    st.caption("SoluciÃ³n diseÃ±ada por Ing. Marco ValcÃ¡rcel")

    # SelecciÃ³n de regiÃ³n
    region = st.selectbox("ğŸ“ Selecciona regiÃ³n", ["Tacna", "Moquegua"], key="region_sidebar")

    st.markdown("---")
    st.markdown("### ğŸ“Œ Clientes por Nivel")

    try:
        df_preview = df_tac if region == "Tacna" else df_moq
        total = df_preview["C_CLIEN"].nunique()
        diamante = df_preview.query("Cluster_Label == 'Diamante'")["C_CLIEN"].nunique()
        oro = df_preview.query("Cluster_Label == 'Oro'")["C_CLIEN"].nunique()
        plata = df_preview.query("Cluster_Label == 'Plata'")["C_CLIEN"].nunique()
        cobre = df_preview.query("Cluster_Label == 'Cobre'")["C_CLIEN"].nunique()
        bronce = df_preview.query("Cluster_Label == 'Bronce'")["C_CLIEN"].nunique()

        st.metric("ğŸŸ¡ Total Ãºnicos", total)
        st.metric("ğŸ’ Diamante", diamante)
        st.metric("ğŸŸ¢ Oro", oro)
        st.metric("ğŸ”µ Plata", plata)
        st.metric("ğŸ’¡ Cobre", cobre)
        st.metric("ğŸŸ¤ Bronce", bronce)
    except Exception as e:
        st.info(f"â„¹ï¸ Las mÃ©tricas de clientes se activarÃ¡n una vez se cargue el dataframe. Error: {e}")

def interpretar_histograma_rfm(df, variable, region=""):


    st.markdown(f"### ğŸ“Œ InterpretaciÃ³n de la variable **{variable}** en {region}")

    grupos = df.groupby("Cluster_Label")[variable]

    for segmento, valores in grupos:
        desc = valores.describe()
        media = desc["mean"]
        mediana = desc["50%"]
        std = desc["std"]
        asimetrÃ­a = valores.skew()
        dispersiÃ³n = "alta" if std > valores.mean() * 0.5 else "moderada" if std > 0 else "baja"

        st.markdown(f"#### ğŸ¯ Segmento **{segmento}**")
        st.markdown(
            f"- Media: **{media:.2f}**, Mediana: **{mediana:.2f}**"
            f"\n- DesviaciÃ³n estÃ¡ndar: **{std:.2f}** ({dispersiÃ³n})"
            f"\n- AsimetrÃ­a: **{asimetrÃ­a:.2f}** {'ğŸ”º positiva' if asimetrÃ­a > 0 else 'ğŸ”» negativa' if asimetrÃ­a < 0 else 'âš–ï¸ simÃ©trica'}"
        )

        # Comentario general
        if asimetrÃ­a > 1:
            st.info("DistribuciÃ³n sesgada a la derecha: mayorÃ­a de valores bajos con algunos muy altos.")
        elif asimetrÃ­a < -1:
            st.info("DistribuciÃ³n sesgada a la izquierda: mayorÃ­a de clientes con valores altos en esta mÃ©trica.")
        elif dispersiÃ³n == "alta":
            st.info("Existe alta variabilidad entre los clientes de este segmento.")
        else:
            st.info("DistribuciÃ³n relativamente equilibrada.")

    st.caption("ğŸ’¡ Esta lectura puede ayudarte a detectar segmentos con outliers o con comportamiento atÃ­pico para intervenciones personalizadas.")

def interpretar_histograma_probabilidad(df, columna_probabilidad, region=""):
    """
    FunciÃ³n de interpretaciÃ³n automÃ¡tica para cualquier columna de probabilidad.
    """

    if columna_probabilidad not in df.columns:
        st.error(f"âŒ La columna '{columna_probabilidad}' no se encuentra en el DataFrame.")
        return

    max_prob = df[columna_probabilidad].max()
    min_prob = df[columna_probabilidad].min()
    media = df[columna_probabilidad].mean()
    mediana = df[columna_probabilidad].median()

    # Extraer el tipo de probabilidad (Ascenso/Descenso) y el segmento (Oro/Bronce)
    partes = columna_probabilidad.replace("Probabilidad_", "").split("_")
    tipo_prob = partes[0]
    segmento_destino = partes[-1]

    st.markdown("---")
    st.markdown(f"ğŸ§  **InterpretaciÃ³n AutomÃ¡tica del Histograma: {tipo_prob} a {segmento_destino}**")

    if np.isclose(max_prob, 1.0):
        st.markdown(f"- ğŸ¯ Hay un grupo de clientes con {tipo_prob} asegurado al segmento **{segmento_destino}** (probabilidad ~1.0). Son casos prioritarios para intervenciÃ³n inmediata.")
    if np.isclose(min_prob, 0.0):
        st.markdown("- âš ï¸ Se detecta una base con probabilidad cero. Revisar si son clientes inactivos o sin historial suficiente.")

    st.markdown(f"- ğŸ“Š En **{region}**, la media de {tipo_prob} es **{media:.2f}** y la mediana es **{mediana:.2f}**."
                f"Esto sugiere{' potencial activo' if media > 0.5 else ' baja disposiciÃ³n al cambio'} al segmento **{segmento_destino}**.")

    st.caption("ğŸ’¡ Esta lectura puede ayudarte a detectar oportunidades de crecimiento o de riesgo en tu cartera.")

# --- Ejemplo de cÃ³mo se llamarÃ­a la funciÃ³n ---
# interpretar_histograma_probabilidad(df_tac, "Probabilidad_Ascenso_Oro", "Tacna")
# interpretar_histograma_probabilidad(df_moq, "Probabilidad_Descenso_Bronce", "Moquegua")

def interpretar_violin_rfm(df, variable, region):
    st.markdown("ğŸ§  **InterpretaciÃ³n AutomÃ¡tica del ViolÃ­n Plot:**")

    # Agrupamos y forzamos el orden lÃ³gico
    resumen_bruto = df.groupby("Cluster_Label")[variable].describe()[["mean", "std"]].round(2)
    resumen = ordenar_segmentos_seguro(resumen_bruto)

    if resumen is not None and not resumen.empty:
        mayor_media = resumen["mean"].idxmax()
        menor_media = resumen["mean"].idxmin()

        st.markdown(f"- ğŸ“ En **{region}**, el clÃºster con mayor valor promedio de `{variable}` es **{mayor_media}**.")
        st.markdown(f"- ğŸ§­ El clÃºster con menor valor promedio es **{menor_media}**.")

        if resumen["std"].max() > 0.5 * resumen["mean"].max():
            st.markdown("- âš ï¸ Hay alta dispersiÃ³n en algunos clÃºsteres, indicando comportamiento variado o presencia de outliers.")
        else:
            st.markdown("- âœ… Las distribuciones son consistentes, lo que sugiere que los clÃºsteres estÃ¡n bien definidos en esta variable.")
    else:
        st.warning("âš ï¸ No se pudo calcular resumen estadÃ­stico confiable para esta mÃ©trica.")

def interpretar_kde_rfm(df, variable, region):
    st.markdown("ğŸ§  **InterpretaciÃ³n AutomÃ¡tica del KDE Plot:**")

    try:
        resumen_bruto = df.groupby("Cluster_Label")[variable].describe()[["mean", "std"]].round(2)
        resumen = ordenar_segmentos_seguro(resumen_bruto)

        if resumen is not None and not resumen.empty:
            rangos = resumen["mean"].max() - resumen["mean"].min()
            st.markdown(f"- En **{region}**, los valores medios de `{variable}` por clÃºster varÃ­an en un rango de **{rangos:.2f}**.")

            if rangos < 0.1 * resumen["mean"].mean():
                st.markdown("- âš ï¸ Las curvas KDE se solapan bastante. Puede haber clÃºsteres con comportamiento poco diferenciado en esta variable.")
            else:
                st.markdown("- âœ… Hay buena separaciÃ³n entre clÃºsteres en tÃ©rminos de densidad. La segmentaciÃ³n parece sÃ³lida.")

            dispersion = resumen["std"].mean()
            if dispersion > 0.3 * resumen["mean"].mean():
                st.markdown(f"- La desviaciÃ³n estÃ¡ndar promedio es **{dispersion:.2f}**, lo que indica **alta** dispersiÃ³n interna en los grupos.")
            else:
                st.markdown(f"- La desviaciÃ³n estÃ¡ndar promedio es **{dispersion:.2f}**, lo que indica **baja** dispersiÃ³n interna en los grupos.")
        else:
            st.warning("âš ï¸ No hay suficientes datos agrupados para interpretar el KDE.")
    except Exception as e:
        st.error(f"âŒ Error al interpretar el grÃ¡fico KDE: {e}")

def interpretar_radar_rfm(df_region, region):
    st.markdown("ğŸ§  **InterpretaciÃ³n del Perfil RFM por ClÃºster:**")

    try:
        mean_raw = df_region.groupby("Cluster_Label")[["Recency", "Frequency", "Monetary"]].mean().round(1)
        mean_profiles = ordenar_segmentos_seguro(mean_raw)

        if mean_profiles is not None and not mean_profiles.empty:
            # Identificamos clÃºster con mÃ¡ximos por mÃ©trica
            estrella = mean_profiles["Frequency"].idxmax()
            rezagado = mean_profiles["Recency"].idxmax()
            ticket_alto = mean_profiles["Monetary"].idxmax()

            st.markdown(f"- â­ **{estrella}** destaca por su **alta frecuencia de compra**.")
            st.markdown(f"- âŒ› **{rezagado}** muestra el **mayor tiempo desde la Ãºltima compra (Recency)**.")
            st.markdown(f"- ğŸ’° **{ticket_alto}** tiene el **mayor gasto promedio por cliente**.")

            # ğŸ§  AnÃ¡lisis cruzado: Â¿hay un clÃºster que lidera en mÃ¡s de una mÃ©trica?
            contador_dominancia = {}
            for cluster in [estrella, rezagado, ticket_alto]:
                contador_dominancia[cluster] = contador_dominancia.get(cluster, 0) + 1

            dominante = [k for k, v in contador_dominancia.items() if v >= 2]

            if dominante:
                for clus in dominante:
                    st.success(f"ğŸ¥‡ **{clus}** lidera en **{contador_dominancia[clus]} mÃ©tricas** clave. Es un segmento estratÃ©gico con alto potencial.")
            else:
                st.info("ğŸ” No hay un Ãºnico clÃºster dominante en mÃ¡s de una mÃ©trica. La segmentaciÃ³n presenta especializaciones distintas.")

        else:
            st.warning("âš ï¸ No se pudo generar interpretaciÃ³n: el resumen promedio estÃ¡ vacÃ­o o mal estructurado.")

    except Exception as e:
        st.error(f"âŒ Error al interpretar perfil RFM: {e}")

def interpretar_comparativa_regional(df):
    st.markdown("ğŸ§  **InterpretaciÃ³n Comparativa Regional:**")

    resumen = df.groupby("RegiÃ³n").agg({
        "Cantidad": "sum",
        "Monto_Total": "sum",
        "Ticket_Promedio": "mean"
    }).round(2)

    region_lider_volumen = resumen["Cantidad"].idxmax()
    region_lider_valor = resumen["Monto_Total"].idxmax()
    region_lider_ticket = resumen["Ticket_Promedio"].idxmax()

    st.markdown(f"- ğŸ“¦ **{region_lider_volumen}** tiene mayor cantidad total de clientes.")
    st.markdown(f"- ğŸ’° **{region_lider_valor}** lidera en valor monetario acumulado.")
    st.markdown(f"- ğŸŸï¸ **{region_lider_ticket}** posee el ticket promedio mÃ¡s alto.")

    # DetecciÃ³n de disparidad en clÃºster Oro
    df_oro = df[df["Cluster_Label"] == "Oro"]
    top_oro = df_oro.groupby("RegiÃ³n")["Cantidad"].sum().idxmax()
    st.markdown(f"- ğŸ¥‡ En el segmento Oro, la mayorÃ­a de clientes proviene de **{top_oro}**.")

def interpretar_predicciones(region, df_region):
    st.markdown("ğŸ§  **InterpretaciÃ³n automÃ¡tica del perfil predictivo:**")

    try:
        media_ascenso = df_region["Probabilidad_Ascenso_Oro"].mean()
        media_bronce = df_region["Probabilidad_Descenso_Bronce"].mean()

        # InterpretaciÃ³n general
        if media_ascenso > 0.6:
            st.markdown(f"- ğŸ¯ En **{region}**, existe **alto potencial de ascenso a Oro** (media: {media_ascenso:.2f}).")
        elif media_ascenso < 0.4:
            st.markdown(f"- âš ï¸ La probabilidad media de ascenso a Oro es baja ({media_ascenso:.2f}). Requiere campaÃ±as proactivas.")
        else:
            st.markdown(f"- ğŸŸ¡ El ascenso a Oro promedio es intermedio ({media_ascenso:.2f}). Hay potencial para desarrollar.")

        if media_bronce > 0.6:
            st.markdown(f"- ğŸ”» TambiÃ©n hay **alto riesgo de caÃ­da a Bronce** (media: {media_bronce:.2f}), lo que requiere contenciÃ³n.")
        elif media_bronce < 0.3:
            st.markdown(f"- âœ… Riesgo de caÃ­da a Bronce controlado (media: {media_bronce:.2f}).")
        else:
            st.markdown(f"- ğŸ§­ Riesgo moderado de caÃ­da a Bronce detectado (media: {media_bronce:.2f}).")

        # AgrupaciÃ³n robusta
        ascenso_por_cluster = ordenar_segmentos_seguro(
            df_region.groupby("Cluster_Label")["Probabilidad_Ascenso_Oro"].mean().round(2)
        )
        bronce_por_cluster = ordenar_segmentos_seguro(
            df_region.groupby("Cluster_Label")["Probabilidad_Descenso_Bronce"].mean().round(2)
        )

        # VerificaciÃ³n
        if ascenso_por_cluster is not None and not ascenso_por_cluster.empty:
            mejor_cluster = ascenso_por_cluster.idxmax()
            st.markdown(f"- ğŸŸ© **{mejor_cluster}** tiene la mayor probabilidad promedio de **ascenso a Oro** ({ascenso_por_cluster[mejor_cluster]:.2f}).")
        else:
            st.warning("âš ï¸ No se pudo interpretar el clÃºster con mayor probabilidad de ascenso a Oro.")

        if bronce_por_cluster is not None and not bronce_por_cluster.empty:
            peor_cluster = bronce_por_cluster.idxmax()
            st.markdown(f"- ğŸŸ¥ **{peor_cluster}** concentra el mayor riesgo de **caÃ­da a Bronce** ({bronce_por_cluster[peor_cluster]:.2f}).")
        else:
            st.warning("âš ï¸ No se pudo interpretar el clÃºster con mayor riesgo de caÃ­da a Bronce.")

        # RecomendaciÃ³n tÃ¡ctica
        if (
            ascenso_por_cluster is not None and bronce_por_cluster is not None
            and not ascenso_por_cluster.empty and not bronce_por_cluster.empty
        ):
            asc_val = ascenso_por_cluster[ascenso_por_cluster.idxmax()]
            bron_val = bronce_por_cluster[bronce_por_cluster.idxmax()]

            if asc_val > 0.7 and bron_val > 0.7:
                st.markdown("- ğŸ”€ Se recomienda una estrategia **dual**: potenciar ascenso en segmentos listos y retener segmentos crÃ­ticos simultÃ¡neamente.")
            elif asc_val > 0.7:
                st.markdown("- ğŸ¯ Enfocar las campaÃ±as en el clÃºster con mayor potencial de ascenso.")
            elif bron_val > 0.7:
                st.markdown("- ğŸ›‘ Priorizar contenciÃ³n sobre el clÃºster mÃ¡s riesgoso antes que se desactive.")
        else:
            st.info("ğŸ” No se pudo emitir una recomendaciÃ³n tÃ¡ctica por datos incompletos.")

    except Exception as e:
        st.error(f"âŒ Error durante la interpretaciÃ³n de predicciones: {e}")

def plot_scatter_rfm(df, eje_x, eje_y, titulo="RFM Scatter"):
    """
    Crea un grÃ¡fico de dispersiÃ³n interactivo usando Plotly.
    Plotly es la librerÃ­a recomendada para grÃ¡ficos en Streamlit.
    """
    # Usamos plotly.express para crear el grÃ¡fico de dispersiÃ³n de manera sencilla.
    # El diccionario de colores se mapea directamente a la columna 'Cluster_Label'
    fig = px.scatter(
        df,
        x=eje_x,
        y=eje_y,
        color="Cluster_Label",
        title=titulo,
        color_discrete_map=colores_k5,
        hover_data=['C_CLIEN', 'Recency', 'Frequency', 'Monetary'] # AÃ±adimos informaciÃ³n en el tooltip
    )

    # Actualizamos el diseÃ±o para una mejor visualizaciÃ³n
    fig.update_layout(
        title={
            'text': titulo,
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        legend_title_text='Segmento',
        hovermode="closest"
    )

    return fig

with tab1:
    st.subheader("ğŸ“ DistribuciÃ³n General de Clientes por Segmento")
    st.caption(f"VisualizaciÃ³n de clientes por segmento en la regiÃ³n seleccionada, para la empresa **Adargar**")

    # SelecciÃ³n de ejes
    variables_disponibles = ["Recency", "Frequency", "Monetary"]
    col1, col2 = st.columns(2)
    with col1:
        eje_x = st.selectbox("Eje X", variables_disponibles, key="x1")
    with col2:
        eje_y = st.selectbox("Eje Y", variables_disponibles, index=1, key="y1")

    # Obtener el DataFrame de la regiÃ³n seleccionada
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # Generar el grÃ¡fico de dispersiÃ³n llamando a la funciÃ³n corregida con Plotly
    # Se reemplaza la lÃ³gica de Matplotlib para usar la funciÃ³n plot_scatter_rfm.
    fig = plot_scatter_rfm(df_region, eje_x, eje_y, titulo=f"{region} - {eje_y} vs {eje_x}")
    st.plotly_chart(fig)

    st.caption("ğŸ“Š DistribuciÃ³n actual de clientes por segmento en la regiÃ³n seleccionada:")
    st.dataframe(
        df_region["Cluster_Label"]
        .value_counts()
        .rename_axis("Segmento")
        .reset_index(name="Clientes")
    )

# Dado que ya integramos arriba ese tipo de visualizaciÃ³n en el tab1 dinÃ¡mico (donde el usuario puede seleccionar cualquier combinaciÃ³n
# de ejes RFM y la regiÃ³n), este segundo bloque tambiÃ©n queda totalmente abarcado por el tab1, es por eso que las lÃ­neas de
# cÃ³digo estan comentadas con #

# Moquegua â€“ Frequency vs Monetary
# plot_scatter_rfm(df_moq, "Frequency", "Monetary", "ğŸ“ Moquegua â€“ Frecuencia vs Monto Gastado")

# Tacna â€“ Frequency vs Monetary
# plot_scatter_rfm(df_tac, "Frequency", "Monetary", "ğŸ“ Tacna â€“ Frecuencia vs Monto Gastado")

# Idem al bloque anterior

# Moquegua â€“ Recency vs Monetary
# plot_scatter_rfm(df_moq, "Recency", "Monetary", "ğŸ“ Moquegua â€“ Recency vs Monto Gastado")

# Tacna â€“ Recency vs Monetary
# plot_scatter_rfm(df_tac, "Recency", "Monetary", "ğŸ“ Tacna â€“ Recency vs Monto Gastado")

with tab2:
    st.subheader("ğŸ“Š EstadÃ­sticas de Valor por ClÃºster RFM")
    st.caption(f"Visualiza promedios de Recency, Frequency y Monetary en clientes de **{region}**")

    # ğŸ§© Dataset segÃºn regiÃ³n activa
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    df_region["Cluster_Label"] = df_region["Cluster_Label"].fillna("Desconocido")

    # ğŸš¨ Nuevo orden con 5 clÃºsteres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    df_region["Cluster_Label"] = pd.Categorical(df_region["Cluster_Label"], categories=orden, ordered=True)

    # ğŸ“ˆ Tabla: Promedio RFM por segmento
    st.markdown("### ğŸ“Œ Promedios por ClÃºster RFM")
    resumen = df_region.groupby("Cluster_Label").agg({
        "Recency": "mean",
        "Frequency": "mean",
        "Monetary": "mean"
    }).round(1).reset_index()
    resumen.rename(columns={
        "Recency": "Recency (dÃ­as)",
        "Frequency": "Frecuencia",
        "Monetary": "Monetary (S/.)"
    }, inplace=True)
    st.dataframe(resumen.style.format({
        "Recency (dÃ­as)": "{:.1f}",
        "Frecuencia": "{:.1f}",
        "Monetary (S/.)": "S/ {:.1f}"
    }), use_container_width=True)

    # ğŸ‘¥ Tabla: Cantidad por segmento
    st.markdown("### ğŸ‘¥ Cantidad de Clientes por ClÃºster")
    conteo = df_region["Cluster_Label"].value_counts().reindex(orden).fillna(0).astype(int).reset_index()
    conteo.columns = ["ClÃºster", "Clientes"]
    st.dataframe(conteo, use_container_width=True)

    # ğŸ§  InterpretaciÃ³n automÃ¡tica
    with st.expander("ğŸ§  InterpretaciÃ³n automÃ¡tica"):
        if not conteo.empty:
            top_segmento = conteo.loc[conteo["Clientes"].idxmax(), "ClÃºster"]
            r_max = resumen.loc[resumen["Cluster_Label"] == top_segmento, "Recency (dÃ­as)"].values[0]
            m_max = resumen.loc[resumen["Cluster_Label"] == top_segmento, "Monetary (S/.)"].values[0]
            st.markdown(f"- ğŸ† El clÃºster mÃ¡s numeroso es **{top_segmento}**, con recency promedio de **{r_max:.1f} dÃ­as** y consumo medio de **S/ {m_max:.1f}**.")

            # ğŸš¨ LÃ³gica de interpretaciÃ³n actualizada para los nuevos umbrales
            if top_segmento == "Diamante":
                 st.success("ğŸ’ El segmento mÃ¡s numeroso es de alto valor. Â¡Excelente!")
            elif r_max <= 30:
                st.info("ğŸ” Recency bajo: indica clientes recientemente activos.")
            elif m_max >= 500:
                st.info("ğŸ’° Ticket promedio elevado: estos clientes tienen alto valor monetario.")
            else:
                st.info("ğŸ” No se encontraron patrones destacados en el segmento mÃ¡s numeroso.")
        else:
            st.warning("âš ï¸ No se pudo realizar la interpretaciÃ³n automÃ¡tica. DataFrame vacÃ­o.")

def ordenar_segmentos_seguro(series_segmentos, nombre_var="Cluster_Label"):
    """
    FunciÃ³n robusta para ordenar segmentos de manera segura.
    Se asegura de que el orden jerÃ¡rquico se respete,
    y aÃ±ade cualquier segmento inesperado al final.
    """
    # Definimos el orden jerÃ¡rquico deseado para los 5 clÃºsteres
    orden_jerarquico = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    # Obtenemos los segmentos que realmente existen en los datos (el Ã­ndice de la serie)
    segmentos_existentes = list(series_segmentos.index)

    # Creamos el orden final filtrando el orden jerÃ¡rquico con los segmentos existentes
    orden_final = [seg for seg in orden_jerarquico if seg in segmentos_existentes]

    # AÃ±adimos cualquier segmento existente que no estÃ© en nuestra lista jerÃ¡rquica
    # Esto es Ãºtil si aparece un clÃºster no esperado en el futuro
    for seg in segmentos_existentes:
        if seg not in orden_final:
            orden_final.append(seg)

    # Reindexamos la serie con el orden final y devolvemos el resultado
    return series_segmentos.reindex(orden_final)

def graficar_tamaÃ±o_cluster(df, region=""):
    """
    FunciÃ³n para graficar el tamaÃ±o de los clÃºsteres usando Plotly.
    Plotly es la librerÃ­a recomendada y compatible con Streamlit.
    """
    # ğŸš¨ Usamos el orden y los colores de los 5 clÃºsteres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # Contamos los clientes por clÃºster y reindexamos para el orden correcto
    conteo = df["Cluster_Label"].value_counts().reindex(orden).fillna(0).astype(int).reset_index()
    conteo.columns = ["Cluster", "Clientes"]

    # Creamos el grÃ¡fico de barras interactivo con Plotly
    fig = px.bar(
        conteo,
        x="Cluster",
        y="Clientes",
        color="Cluster",
        color_discrete_map=colores_k5,
        labels={"Cluster": "Segmento", "Clientes": "Nro. de Clientes"},
        title=f"ğŸ“Š DistribuciÃ³n de clientes por segmento â€“ {region}",
    )

    # AÃ±adimos las etiquetas de texto encima de las barras
    fig.update_traces(texttemplate='%{y}', textposition='outside')
    fig.update_layout(
        title={
            'text': f"ğŸ“Š DistribuciÃ³n de clientes por segmento â€“ {region}",
            'y': 0.9,
            'x': 0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        xaxis={'categoryorder': 'array', 'categoryarray': orden}, # Aseguramos el orden en el eje X
        hovermode="x unified",
        showlegend=False # La informaciÃ³n ya estÃ¡ en el eje X
    )

    return fig

# Ejemplo de cÃ³mo se llamarÃ­a la funciÃ³n en Streamlit:
# fig_tamano = graficar_tamaÃ±o_cluster(df_region, region)
# st.plotly_chart(fig_tamano)

with tab3:
    st.subheader("ğŸ“¦ DistribuciÃ³n de Clientes por Segmento RFM")
    st.caption(f"Visualiza cuÃ¡ntos clientes pertenecen a cada clÃºster en la regiÃ³n de **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # ğŸ‘ï¸ Mostrar grÃ¡fico de barras adaptado con Plotly
    # Se ha cambiado st.pyplot por st.plotly_chart para un grÃ¡fico interactivo.
    st.plotly_chart(graficar_tamaÃ±o_cluster(df_region, region))

    # ğŸ§® Mostrar tabla resumen de conteo por clÃºster
    conteo = ordenar_segmentos_seguro(df_region["Cluster_Label"].value_counts()).reset_index()
    conteo.columns = ["Segmento", "Clientes"]
    st.dataframe(conteo, use_container_width=True)

    # ğŸ§  InterpretaciÃ³n automÃ¡tica
    with st.expander("ğŸ§  InterpretaciÃ³n automÃ¡tica"):
        segmento_max = conteo.loc[conteo["Clientes"].idxmax(), "Segmento"]
        st.markdown(f"- ğŸ† El segmento dominante en **{region}** es **{segmento_max}**.")

        # ï¿½ LÃ³gica de interpretaciÃ³n actualizada para 5 clÃºsteres
        if segmento_max == "Diamante":
            st.success("ğŸ’ Excelente: predominan los clientes mÃ¡s valiosos y leales.")
        elif segmento_max == "Oro":
            st.success("âœ¨ Excelente: predominan clientes de alto valor y leales.")
        elif segmento_max == "Plata":
            st.info("ğŸ“ˆ Gran oportunidad: clientes constantes con potencial de crecimiento.")
        elif segmento_max == "Cobre":
            st.warning("ğŸ’¡ AtenciÃ³n: mayorÃ­a de clientes en estado de oportunidad o riesgo de inactividad.")
        elif segmento_max == "Bronce":
            st.error("âš ï¸ Alerta: el segmento mÃ¡s numeroso requiere una estrategia urgente de reactivaciÃ³n.")

with tab4:
    st.subheader("ğŸ’¼ Estrategias de CampaÃ±a por ClÃºster RFM")
    st.caption("Aplicables a clientes segÃºn su clasificaciÃ³n por Recency, Frequency y Monetary.")

    tabla_html = """
    <div style="border:1px solid #ddd; border-radius:10px; padding:15px; background-color:#fefefe; box-shadow:2px 2px 8px rgba(0,0,0,0.05); margin-top:15px;">

    <h4 style="margin-bottom:10px;">ğŸ“Œ Recomendaciones de CampaÃ±a por Segmento</h4>

    <table style="width:100%; border-collapse: collapse; font-family: 'Segoe UI', sans-serif; font-size:15px;">
      <thead style="background-color:#e0e0e0;">
        <tr>
          <th style="border: 1px solid #ccc; padding: 8px;">ClÃºster</th>
          <th style="border: 1px solid #ccc; padding: 8px;">Perfil</th>
          <th style="border: 1px solid #ccc; padding: 8px;">Objetivo</th>
          <th style="border: 1px solid #ccc; padding: 8px;">AcciÃ³n Recomendada</th>
        </tr>
      </thead>
      <tbody>
        <tr style="background-color:#e6f8ff;">
          <td style="border: 1px solid #eee; padding: 8px;">ğŸ’ Diamante</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes Ã©lite, de alto valor</td>
          <td style="border: 1px solid #eee; padding: 8px;">FidelizaciÃ³n y crecimiento</td>
          <td style="border: 1px solid #eee; padding: 8px;">Programas de lealtad exclusivos y anticipaciÃ³n de necesidades.</td>
        </tr>
        <tr style="background-color:#fffbe6;">
          <td style="border: 1px solid #eee; padding: 8px;">ğŸŸ¡ Oro</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes muy valiosos y leales</td>
          <td style="border: 1px solid #eee; padding: 8px;">FidelizaciÃ³n y potenciar</td>
          <td style="border: 1px solid #eee; padding: 8px;">Ofrecer programas VIP y seguimiento personalizado.</td>
        </tr>
        <tr style="background-color:#f0f9ff;">
          <td style="border: 1px solid #eee; padding: 8px;">ğŸ”µ Plata</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes con frecuencia y valor medio</td>
          <td style="border: 1px solid #eee; padding: 8px;">Impulso de recurrencia y up-selling</td>
          <td style="border: 1px solid #eee; padding: 8px;">Enviar promociones segmentadas y correos de recordatorio.</td>
        </tr>
        <tr style="background-color:#fff8f6;">
          <td style="border: 1px solid #eee; padding: 8px;">ğŸ’¡ Cobre</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes en riesgo de inactividad</td>
          <td style="border: 1px solid #eee; padding: 8px;">RetenciÃ³n y oportunidad</td>
          <td style="border: 1px solid #eee; padding: 8px;">Enfoque en productos complementarios y reactivaciÃ³n con ofertas de valor.</td>
        </tr>
        <tr style="background-color:#f6e6ff;">
          <td style="border: 1px solid #eee; padding: 8px;">ğŸŸ¤ Bronce</td>
          <td style="border: 1px solid #eee; padding: 8px;">Clientes de bajo ticket o inactivos</td>
          <td style="border: 1px solid #eee; padding: 8px;">ReactivaciÃ³n</td>
          <td style="border: 1px solid #eee; padding: 8px;">Lanzar campaÃ±as con ofertas de bienvenida o combos accesibles.</td>
        </tr>
      </tbody>
    </table>
    </div>
    """
    st.markdown(tabla_html, unsafe_allow_html=True)

def plot_boxplots_rfm(df, region):
    """
    FunciÃ³n que genera boxplots interactivos para las variables RFM por clÃºster
    usando Plotly. Se utiliza la tÃ©cnica de 'melt' para reestructurar los datos
    y graficar los tres boxplots en una sola llamada a Plotly.
    """
    # ğŸš¨ Usamos el orden y los colores de los 5 clÃºsteres
    orden_k5 = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # Seleccionamos las variables RFM y el clÃºster
    rfm_vars = ["Recency", "Frequency", "Monetary"]
    df_plot = df[["Cluster_Label"] + rfm_vars].copy()

    # Se utiliza pd.melt para "derretir" el DataFrame de un formato ancho a uno largo,
    # lo cual es ideal para graficar mÃºltiples variables en un mismo grÃ¡fico de Plotly.
    df_melt = df_plot.melt(id_vars="Cluster_Label", value_vars=rfm_vars, var_name="Variable", value_name="Valor")

    # Creamos el grÃ¡fico de boxplots utilizando facetas para cada variable
    fig = px.box(
        df_melt,
        x="Cluster_Label",
        y="Valor",
        color="Cluster_Label",
        facet_col="Variable",
        facet_col_wrap=3, # Se muestran los 3 boxplots uno al lado del otro
        category_orders={"Cluster_Label": orden_k5}, # Aseguramos el orden de los clÃºsteres
        color_discrete_map=colores_k5,
        title=f"DistribuciÃ³n RFM por ClÃºster â€“ {region}",
        labels={"Cluster_Label": "Segmento", "Valor": "Valor"},
    )

    # Ajustes de diseÃ±o para mejorar la visualizaciÃ³n
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1])) # Elimina el "Variable=" del tÃ­tulo de la faceta
    fig.update_layout(
        title={
            'text': f"DistribuciÃ³n RFM por ClÃºster â€“ {region}",
            'y': 0.9,
            'x': 0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        hovermode="closest",
        legend_title_text='Segmento',
    )

    return fig

# Nueva funciÃ³n para interpretar boxplots
def interpretar_boxplot_rfm(df, variable, region):
    """
    FunciÃ³n de interpretaciÃ³n automÃ¡tica para un boxplot de cualquier variable RFM.
    """
    st.markdown("ğŸ§  **InterpretaciÃ³n AutomÃ¡tica del Boxplot:**")
    try:
        resumen_bruto = df.groupby("Cluster_Label")[variable].describe()[["mean", "25%", "50%", "75%"]].round(2)
        resumen = ordenar_segmentos_seguro(resumen_bruto)

        if resumen is not None and not resumen.empty:
            mayor_media = resumen["mean"].idxmax()
            menor_media = resumen["mean"].idxmin()
            q3_max = resumen["75%"].max()

            st.markdown(f"- ğŸ“ En **{region}**, el clÃºster con mayor valor promedio de `{variable}` es **{mayor_media}**.")
            st.markdown(f"- ğŸ§­ El clÃºster con menor valor promedio es **{menor_media}**.")

            # AnÃ¡lisis de outliers
            outliers_detectados = False
            for segmento in resumen.index:
                q1 = resumen.loc[segmento, "25%"]
                q3 = resumen.loc[segmento, "75%"]
                iqr = q3 - q1
                limite_superior_teorico = q3 + 1.5 * iqr

                max_real = df[df["Cluster_Label"] == segmento][variable].max()

                if max_real > limite_superior_teorico:
                    st.warning(f"âš ï¸ El segmento **{segmento}** tiene **valores atÃ­picos** altos en `{variable}`, indicando clientes con comportamiento extremo.")
                    outliers_detectados = True

            if not outliers_detectados:
                st.info("âœ… No se detectaron valores atÃ­picos significativos. Los clÃºsteres son bastante homogÃ©neos.")

        else:
            st.warning("âš ï¸ No se pudo calcular el resumen estadÃ­stico confiable para esta mÃ©trica.")
    except Exception as e:
        st.error(f"âŒ Error al interpretar el grÃ¡fico Boxplot: {e}")

# --- Bloque corregido para tab5 ---
with tab5:
    st.subheader("ğŸ“Š DistribuciÃ³n de mÃ©tricas RFM por segmento")
    st.caption(f"ComparaciÃ³n visual de dispersiÃ³n y valores atÃ­picos segÃºn el segmento en **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    fig = plot_boxplots_rfm(df_region, region)
    # ğŸš¨ LÃNEA CORREGIDA: Se usa st.plotly_chart para un grÃ¡fico interactivo
    st.plotly_chart(fig)

    st.markdown("---") # Separador para mejor lectura
    st.markdown("### ğŸ“Œ InterpretaciÃ³n automÃ¡tica por mÃ©trica")
    for variable in ("Recency", "Frequency", "Monetary"):
        with st.expander(f"ğŸ“ AnÃ¡lisis de {variable} por segmento"):
            # ğŸš¨ Se llama a la nueva funciÃ³n de interpretaciÃ³n para boxplots
            interpretar_boxplot_rfm(df_region, variable, region)

with tab6:
    st.subheader("ğŸ… Top Clientes de Alto Valor: Diamante y Oro")
    st.caption(f"Listado de clientes 'Diamante' y 'Oro' ordenados por valor monetario en **{region}**")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # ğŸš¨ Se filtra por los 2 segmentos de mayor valor
    df_top_segmentos = df_region[df_region["Cluster_Label"].isin(["Diamante", "Oro"])].copy()

    top_n = st.slider("Selecciona cuÃ¡ntos clientes de alto valor mostrar:", min_value=5, max_value=50, value=10, step=5)

    if not df_top_segmentos.empty:
        top_df = df_top_segmentos.sort_values(by="Monetary", ascending=False).head(top_n).reset_index(drop=True)
        top_df.index += 1

        st.dataframe(
            top_df[["C_CLIEN", "Recency", "Frequency", "Monetary", "Cluster_Label"]].round(1).rename(columns={
                "C_CLIEN": "CÃ³digo Cliente",
                "Recency": "Recencia (dÃ­as)",
                "Frequency": "Frecuencia (compras)",
                "Monetary": "Valor Monetario (S/)",
                "Cluster_Label": "Segmento"
            }),
            use_container_width=True
        )

        # ğŸ§¾ Excel exportaciÃ³n
        output = io.BytesIO()
        wb = Workbook()
        resumen_sheet = wb.active
        resumen_sheet.title = "Resumen de Top Clientes"

        # ğŸ¨ Estilos
        header_font = Font(bold=True, color="FFFFFF")
        align_center = Alignment(horizontal="center")
        border = Border(bottom=Side(style="thin"))

        # ğŸš¨ Nuevo diccionario con 5 colores para los clÃºsteres
        cluster_fills = {
            "Diamante": PatternFill(start_color="00FFFF", fill_type="solid"),
            "Oro": PatternFill(start_color="FFD700", fill_type="solid"),
            "Plata": PatternFill(start_color="C0C0C0", fill_type="solid"),
            "Cobre": PatternFill(start_color="B87333", fill_type="solid"),
            "Bronce": PatternFill(start_color="CD7F32", fill_type="solid")
        }

        # ğŸ–¼ï¸ Logo (si existe)
        try:
            logo = XLImage("logo_adargar.jpg")
            logo.width = 220
            logo.height = 70
            resumen_sheet.add_image(logo, "A1")
        except:
            pass

        # ğŸ“‹ TÃ­tulo + fecha
        resumen_sheet["A5"] = f"ğŸ“Š Reporte de Clientes Diamante y Oro â€“ RegiÃ³n: {region}"
        resumen_sheet["A5"].font = Font(bold=True, size=12)
        resumen_sheet["A5"].alignment = align_center
        resumen_sheet.merge_cells("A5:E5")
        resumen_sheet["A6"] = f"Fecha de generaciÃ³n: {datetime.today().strftime('%d/%m/%Y')}"
        resumen_sheet["A6"].font = Font(italic=True, size=10)

        # ğŸ§© Encabezado
        headers = ["CÃ³digo Cliente", "Recencia (dÃ­as)", "Frecuencia (compras)", "Valor Monetario (S/)", "Segmento"]
        for i, h in enumerate(headers, start=1):
            cell = resumen_sheet.cell(row=10, column=i, value=h)
            cell.font = header_font
            cell.alignment = align_center
            cell.fill = cluster_fills.get(top_df["Cluster_Label"].iloc[0], cluster_fills["Oro"]) # ğŸš¨ Ajuste para color
            cell.border = border

        # ğŸ‘¤ Datos
        for i, row in enumerate(top_df.itertuples(index=False), start=11):
            resumen_sheet.cell(row=i, column=1, value=row.C_CLIEN)
            resumen_sheet.cell(row=i, column=2, value=row.Recency)
            resumen_sheet.cell(row=i, column=3, value=row.Frequency)
            resumen_sheet.cell(row=i, column=4, value=row.Monetary)
            cell_cluster = resumen_sheet.cell(row=i, column=5, value=row.Cluster_Label)
            cell_cluster.fill = cluster_fills.get(row.Cluster_Label, None)

        for col in "ABCDE":
            resumen_sheet.column_dimensions[col].width = 20

        # ğŸ—‚ï¸ Otras hojas por clÃºster
        # ğŸš¨ Se itera sobre los 5 clÃºsteres
        for label in ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]:
            df_cl = df_region[df_region["Cluster_Label"] == label].copy()
            hoja = wb.create_sheet(f"ClÃºster {label}")
            hoja.append(["CÃ³digo Cliente", "Recencia (dÃ­as)", "Frecuencia", "Valor Monetario (S/)", "Cluster_Label", "Color", "RegiÃ³n"])
            for r in df_cl.itertuples(index=False):
                hoja.append([
                    r.C_CLIEN, r.Recency, r.Frequency, r.Monetary,
                    r.Cluster_Label, r.Color, r.Region
                ])
            for cell in hoja["1:1"]:
                cell.font = header_font
                cell.fill = cluster_fills[label]
                cell.border = border
                cell.alignment = align_center
            for col in "ABCDEFG":
                hoja.column_dimensions[col].width = 18
            hoja.append([])
            hoja.append(["ğŸ“Œ Estrategia:", estrategias.get(label, "")])

        if "Sheet" in wb.sheetnames:
            del wb["Sheet"]

        wb.save(output)
        output.seek(0)

        st.download_button(
            label=f"ğŸ“˜ Descargar Reporte Excel â€“ {region}",
            data=output,
            # ğŸš¨ Se actualiza el nombre del archivo
            file_name=f"Reporte_Clientes_Diamante_Oro_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.warning(f"âš ï¸ No se encontraron clientes de alto valor (Diamante o Oro) en la regiÃ³n {region}.")

with tab7:
    st.subheader("ğŸ›ï¸ Clientes con Recencia CrÃ­tica por Segmento")
    st.caption(f"Filtra y descarga clientes con seÃ±ales de abandono en la regiÃ³n **{region}** para activar campaÃ±as de retenciÃ³n segmentada.")

    # SelecciÃ³n de regiÃ³n
    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # ğŸš¨ SelecciÃ³n de clÃºster actualizada
    segmentos = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    segmento_seleccionado = st.selectbox("ğŸ¯ Selecciona el segmento a analizar:", segmentos, key="seg_critico")

    df_segmento = df_region[df_region["Cluster_Label"] == segmento_seleccionado].copy()

    modo_alerta = st.radio("ğŸ“Š Criterio de alerta:", ["Recency > percentil 75", "Recency > 90 dÃ­as"], index=0, key="modo_alerta")

    if modo_alerta == "Recency > percentil 75":
        if not df_segmento.empty:
            umbral = df_segmento["Recency"].quantile(0.75)
            st.markdown(f"ğŸ” Clientes con Recency > **{umbral:.0f} dÃ­as** serÃ¡n marcados como en riesgo.")
        else:
            umbral = 0
            st.markdown("ğŸ” No hay datos para este segmento. No se puede calcular el umbral.")
    else:
        umbral = 90
        st.markdown("ğŸ” Clientes con Recency > **90 dÃ­as** serÃ¡n marcados como en riesgo.")

    clientes_riesgo = df_segmento[df_segmento["Recency"] > umbral].copy()
    clientes_riesgo = clientes_riesgo.sort_values(by="Recency", ascending=False).reset_index(drop=True)

    col1, col2, col3 = st.columns(3)
    col1.metric(f"Clientes {segmento_seleccionado} Totales", len(df_segmento))
    col2.metric("Clientes en Riesgo", len(clientes_riesgo))
    porcentaje = f"{(100 * len(clientes_riesgo) / len(df_segmento)):.1f}%" if len(df_segmento) > 0 else "0%"
    col3.metric("% en Riesgo", porcentaje)

    if not clientes_riesgo.empty:
        st.markdown("### ğŸ“‹ Detalle de clientes en riesgo:")
        st.dataframe(
            clientes_riesgo[["C_CLIEN", "Recency", "Frequency", "Monetary", "Cluster_Label"]].round(1).rename(columns={
                "C_CLIEN": "CÃ³digo Cliente",
                "Recency": "Recencia (dÃ­as)",
                "Frequency": "Frecuencia (compras)",
                "Monetary": "Valor Monetario (S/)",
                "Cluster_Label": "Segmento"
            }),
            use_container_width=True
        )

        buffer = io.BytesIO()
        wb = Workbook()
        ws = wb.active
        ws.title = f"Alerta {segmento_seleccionado} â€“ {region}"

        ws["A1"] = f"ğŸ“‹ Clientes {segmento_seleccionado} en Riesgo â€“ {region}"
        ws["A1"].font = Font(bold=True)
        ws.merge_cells("A1:D1")
        ws.append(["CÃ³digo Cliente", "Recencia", "Frecuencia", "Monetario"])

        for r in clientes_riesgo.itertuples(index=False):
            ws.append([r.C_CLIEN, r.Recency, r.Frequency, r.Monetary])

        for col in "ABCD":
            ws.column_dimensions[col].width = 20

        wb.save(buffer)
        buffer.seek(0)

        st.download_button(
            label=f"ğŸ“„ Descargar Excel â€“ {segmento_seleccionado} â€“ {region}",
            data=buffer,
            file_name=f"Alerta_{segmento_seleccionado}_Riesgo_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.success(f"ğŸ‰ No hay clientes {segmento_seleccionado} en riesgo con los criterios actuales.")

    st.markdown("---")
    st.markdown("### ğŸ“Œ RecomendaciÃ³n EstratÃ©gica")

    # ğŸš¨ Diccionario de estrategias actualizado
    estrategias = {
        "Diamante": "Contactar con atenciÃ³n premium, beneficios exclusivos y encuestas de satisfacciÃ³n.",
        "Oro": "Ofrecer programas VIP y seguimiento personalizado para mantener la lealtad.",
        "Plata": "Ofrecer promociones segmentadas, cupones de incentivo o encuestas de vinculaciÃ³n.",
        "Cobre": "Aplicar campaÃ±as de reactivaciÃ³n con ofertas de valor, cross-selling y comunicaciÃ³n proactiva.",
        "Bronce": "Lanzar campaÃ±as con ofertas de bienvenida o combos accesibles para reactivar la base."
    }
    st.info(estrategias.get(segmento_seleccionado, "Estrategia no definida para este segmento."))

# ğŸ› ï¸ Recalcular df_tac y df_moq despuÃ©s de entrenar el modelo
df_tac = rfm[rfm["Region"] == "Tacna"].copy()
df_moq = rfm[rfm["Region"] == "Moquegua"].copy()

# FunciÃ³n para interpretar las predicciones, asumiendo que existe
# Es recomendable definir esta funciÃ³n en otro bloque de cÃ³digo.
def interpretar_predicciones(region, df):
    # LÃ³gica de interpretaciÃ³n para los clÃºsteres...
    st.markdown(f"**AnÃ¡lisis Predictivo en la RegiÃ³n {region}:**")
    for cluster in ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]:
        df_cluster = df[df["Cluster_Label"] == cluster]
        if not df_cluster.empty:
            prob_ascenso_mean = df_cluster["Probabilidad_Ascenso_Oro"].mean()
            prob_descenso_mean = df_cluster["Probabilidad_Descenso_Bronce"].mean()
            st.markdown(f"---")
            st.markdown(f"**Segmento {cluster}:**")
            st.markdown(f"- Probabilidad promedio de ascenso a Oro: **{prob_ascenso_mean:.2f}**")
            st.markdown(f"- Probabilidad promedio de caÃ­da a Bronce: **{prob_descenso_mean:.2f}**")

# --- Bloque corregido para tab8 ---
with tab8:
    st.subheader("ğŸ”® Modelo de EvoluciÃ³n de Clientes por RegiÃ³n")
    st.caption(f"AnÃ¡lisis predictivo aplicado a la regiÃ³n **{region}** para anticipar evoluciÃ³n y riesgo de clientes.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # Se usan las nuevas columnas de predicciÃ³n
    df_region["Probabilidad_Ascenso_Oro"] = pd.to_numeric(df_region["Probabilidad_Ascenso_Oro"], errors="coerce")
    df_region["Probabilidad_Descenso_Bronce"] = pd.to_numeric(df_region["Probabilidad_Descenso_Bronce"], errors="coerce")

    # Vista de clientes con alta probabilidad de ascenso
    st.markdown("### ğŸ“ˆ Clientes con potencial de ascenso")
    umbral = st.slider("ğŸ“ˆ Umbral de probabilidad de ascenso a Oro:", 0.5, 1.0, 0.75, step=0.05)

    df_filtrado = df_region[df_region["Probabilidad_Ascenso_Oro"] >= umbral].copy()
    df_filtrado = df_filtrado.sort_values("Probabilidad_Ascenso_Oro", ascending=False).reset_index(drop=True)

    def definir_campaÃ±a(row):
        if row["Cluster_Label"] in ["Bronce", "Cobre"] and row["Probabilidad_Ascenso_Oro"] >= umbral:
            return "ğŸ¯ Activar con Oferta Especial"
        elif row["Cluster_Label"] == "Plata" and row["Probabilidad_Ascenso_Oro"] >= umbral:
            return "ğŸ“ˆ Seguimiento Comercial y Up-selling"
        elif row["Cluster_Label"] in ["Oro", "Diamante"] and row["Probabilidad_Descenso_Bronce"] >= 0.5:
            return "âš ï¸ Retener Urgentemente"
        else:
            return "ğŸ¤ Mantenimiento EstratÃ©gico"

    if not df_filtrado.empty:
        df_filtrado["CampaÃ±a Sugerida"] = df_filtrado.apply(definir_campaÃ±a, axis=1)

        st.markdown(f"ğŸ“‹ Se identificaron **{len(df_filtrado)}** clientes con alta probabilidad de ascenso a Oro.")
        st.dataframe(
            df_filtrado[[
                "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "CampaÃ±a Sugerida"
            ]].rename(columns={
                "C_CLIEN": "CÃ³digo Cliente",
                "Cluster_Label": "ClÃºster Actual",
                "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro"
            }).round(3),
            use_container_width=True
        )

        excel_buff = io.BytesIO()
        df_exportar = df_filtrado[[
            "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "CampaÃ±a Sugerida"
        ]].rename(columns={
            "C_CLIEN": "CÃ³digo Cliente",
            "Cluster_Label": "ClÃºster Actual",
            "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro"
        })
        df_exportar.to_excel(excel_buff, index=False)
        excel_buff.seek(0)

        st.download_button(
            "ğŸ“¥ Descargar Excel de Clientes en EvoluciÃ³n",
            data=excel_buff,
            file_name=f"Prediccion_Evolucion_{region}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.info("ğŸ” No se encontraron clientes que cumplan el umbral de probabilidad establecido.")

    st.subheader("ğŸ“Š DistribuciÃ³n â€“ Probabilidad de Ascenso a Oro")
    if df_region["Probabilidad_Ascenso_Oro"].notna().sum() > 0:
        # LÃNEA CORREGIDA: Se usa plotly.express para el histograma interactivo
        fig = px.histogram(
            df_region, x="Probabilidad_Ascenso_Oro", nbins=20,
            title=f"DistribuciÃ³n â€“ Probabilidad de Ascenso a Oro ({region})",
            labels={"Probabilidad_Ascenso_Oro": "Probabilidad", "count": "Clientes"}
        )
        st.plotly_chart(fig)

        with st.expander("ğŸ§  Ver interpretaciÃ³n predictiva automÃ¡tica por clÃºster"):
            interpretar_predicciones(region, df_region)
    else:
        st.warning("âš ï¸ No hay datos numÃ©ricos vÃ¡lidos para graficar.")

    st.subheader("ğŸ“ˆ Vista estratÃ©gica de Riesgo y Oportunidad (Ascenso vs CaÃ­da)")
    st.markdown("ğŸ” Analiza clientes segÃºn su **probabilidad de ascenso a Oro** y **riesgo de caÃ­da a Bronce**.")

    col1, col2 = st.columns(2)
    with col1:
        umbral_ascenso = st.slider("ğŸ¯ Umbral de ascenso alto", 0.6, 1.0, 0.8, step=0.05, key="umbral_ascenso_plot")
    with col2:
        umbral_caida = st.slider("ğŸ›‘ Umbral de caÃ­da alta", 0.4, 1.0, 0.6, step=0.05, key="umbral_caida_plot")

    def clasificar_cuadrante(row):
        # ğŸš¨ LÃ³gica de clasificaciÃ³n actualizada con las nuevas columnas
        if row["Probabilidad_Ascenso_Oro"] >= umbral_ascenso:
            if row["Probabilidad_Descenso_Bronce"] <= 1 - umbral_caida:
                return "Cliente Estrella (Ascenso Seguro)"
            else:
                return "Potencial de Ascenso y Riesgo"
        elif row["Probabilidad_Descenso_Bronce"] >= umbral_caida:
            if row["Probabilidad_Ascenso_Oro"] <= 1 - umbral_ascenso:
                return "Riesgo de Abandono (CaÃ­da Segura)"
            else:
                return "Riesgo con Potencial"
        else:
            return "Zona de Desarrollo y Estabilidad"

    df_region["Segmento EstratÃ©gico"] = df_region.apply(clasificar_cuadrante, axis=1)

    st.markdown(f"ğŸ“Œ Se han clasificado **{df_region.shape[0]}** clientes segÃºn su perfil estratÃ©gico.")
    st.dataframe(
        df_region[[
            "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce", "Segmento EstratÃ©gico"
        ]].rename(columns={
            "C_CLIEN": "CÃ³digo Cliente",
            "Cluster_Label": "ClÃºster Actual",
            "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro",
            "Probabilidad_Descenso_Bronce": "Prob. CaÃ­da a Bronce"
        }).round(3),
        use_container_width=True
    )

    # LÃNEA CORREGIDA: Se usa plotly.express para el scatter plot interactivo
    fig = px.scatter(
        df_region,
        x="Probabilidad_Ascenso_Oro", y="Probabilidad_Descenso_Bronce",
        color="Segmento EstratÃ©gico",
        title=f"Matriz EstratÃ©gica de EvoluciÃ³n â€“ {region}",
        labels={
            "Probabilidad_Ascenso_Oro": "Probabilidad de Ascenso a Oro",
            "Probabilidad_Descenso_Bronce": "Probabilidad de CaÃ­da a Bronce"
        },
        height=500
    )
    # Ajustamos la posiciÃ³n de la leyenda y los ejes
    fig.update_layout(legend_title_text='Segmento EstratÃ©gico')
    # AÃ±adimos las lÃ­neas de los umbrales
    fig.add_vline(x=umbral_ascenso, line_width=1, line_dash="dash", line_color="gray")
    fig.add_hline(y=umbral_caida, line_width=1, line_dash="dash", line_color="gray")
    st.plotly_chart(fig)

    excel_buffer = io.BytesIO()
    df_exportar_cuadrantes = df_region[[
        "C_CLIEN", "Cluster_Label", "Probabilidad_Ascenso_Oro",
        "Probabilidad_Descenso_Bronce", "Segmento EstratÃ©gico"
    ]].rename(columns={
        "C_CLIEN": "CÃ³digo Cliente",
        "Cluster_Label": "ClÃºster Actual",
        "Probabilidad_Ascenso_Oro": "Prob. Ascenso a Oro",
        "Probabilidad_Descenso_Bronce": "Prob. CaÃ­da a Bronce"
    })
    df_exportar_cuadrantes.to_excel(excel_buffer, index=False)
    excel_buffer.seek(0)

    st.download_button(
        "ğŸ“¥ Descargar Excel de Clientes Segmentados",
        data=excel_buffer,
        file_name=f"Matriz_Estrategica_{region}.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

# Nueva funciÃ³n para la interpretaciÃ³n de histogramas RFM
def interpretar_histograma_rfm(df, variable, region):
    st.markdown("### ğŸ” AnÃ¡lisis de la distribuciÃ³n por clÃºster:")

    # Orden de los clÃºsteres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden:
        subset = df[df["Cluster_Label"] == label][variable].dropna()
        if not subset.empty:
            media = subset.mean()
            mediana = subset.median()
            st.markdown(f"**{label}**:")
            st.markdown(f"- Media: **{media:.2f}**, Mediana: **{mediana:.2f}**")

            # LÃ³gica de interpretaciÃ³n bÃ¡sica
            if variable == "Recency":
                if media < 30:
                    st.success(f" Â - ğŸ‰ Los clientes de este segmento han comprado recientemente (media < 30 dÃ­as).")
                elif media > 180:
                    st.error(f" Â - â³ Los clientes de este segmento estÃ¡n inactivos (media > 180 dÃ­as).")
                else:
                    st.info(f" Â - ğŸ“ˆ Compras a intervalos moderados. Oportunidad de marketing. ")

            elif variable == "Frequency":
                if media >= 10:
                    st.success(f" Â - ğŸ›’ Clientes muy recurrentes, compran frecuentemente (media >= 10).")
                elif media >= 3:
                    st.info(f" Â - ğŸ”„ Clientes con frecuencia moderada. Se puede impulsar mÃ¡s compras.")
                else:
                    st.warning(f" Â - ğŸ“‰ Clientes poco recurrentes. Fomentar la repeticiÃ³n de compra.")

            elif variable == "Monetary":
                if media >= 2000:
                    st.success(f" Â - ğŸ’° Alto valor monetario. Clientes muy valiosos (media >= S/ 2000).")
                elif media >= 500:
                    st.info(f" Â - ğŸ“ˆ Valor monetario moderado. Potencial para aumentar el ticket promedio.")
                else:
                    st.warning(f" Â - ğŸ’¸ Bajo valor monetario. Se puede incentivar compras de mayor valor.")

# --- Bloque corregido para tab9 ---
with tab9:
    st.subheader("ğŸ“Š DistribuciÃ³n de Comportamiento RFM por ClÃºster")
    st.caption(f"Visualiza la distribuciÃ³n de mÃ©tricas RFM para los diferentes segmentos en **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    variable = st.selectbox("Selecciona la variable RFM a analizar:", ["Recency", "Frequency", "Monetary"])

    st.markdown(f"ğŸ” Histograma de **{variable}** segmentado por **Cluster_Label** en **{region}**")

    # ğŸš¨ Diccionario de colores actualizado para los 5 clÃºsteres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # ğŸ“Š Histograma apilado con Plotly Express
    fig = px.histogram(
        df_region,
        x=variable,
        color="Cluster_Label",
        color_discrete_map=colores_k5,
        title=f"DistribuciÃ³n de {variable} por ClÃºster â€“ {region}",
        labels={variable: variable, "count": "Cantidad de Clientes"}
    )
    # Mejora: El modo `stack` es el valor por defecto, pero se puede explicitar si es necesario
    # fig.update_layout(barmode='stack')
    st.plotly_chart(fig)

    # ğŸ§  InterpretaciÃ³n automÃ¡tica
    with st.expander("ğŸ§  Ver interpretaciÃ³n por clÃºster"):
        # ğŸš¨ Llamada a la nueva funciÃ³n de interpretaciÃ³n
        interpretar_histograma_rfm(df_region, variable, region)

# ğŸš¨ Nueva funciÃ³n para interpretar los violin plots
def interpretar_violin_rfm(df, variable, region):
    st.markdown("### ğŸ§  InterpretaciÃ³n de la DistribuciÃ³n (Violin Plot)")
    st.markdown(f"El ancho del grÃ¡fico de violÃ­n representa la **densidad de clientes** en cada valor de `{variable}`.")

    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden_clusters:
        subset = df[df["Cluster_Label"] == label][variable].dropna()
        if not subset.empty:
            media = subset.mean()
            q1 = subset.quantile(0.25)
            q3 = subset.quantile(0.75)
            st.markdown(f"**{label}**:")
            if variable == "Recency":
                if media < 30:
                    st.success(f"- Clientes muy recientes. La mayorÃ­a de compras ocurrieron en los Ãºltimos {q1:.0f}-{q3:.0f} dÃ­as.")
                elif media > 90:
                    st.warning(f"- Clientes con alta recencia. La mediana se encuentra en **{subset.median():.0f} dÃ­as**.")
                else:
                    st.info(f"- Compras en un perÃ­odo de tiempo moderado.")
            elif variable == "Frequency":
                if q3 >= 10:
                    st.success(f"- El 75% de los clientes ha realizado **{q3:.0f} o mÃ¡s compras**. Muy alta frecuencia.")
                elif media < 2:
                    st.warning(f"- La mayorÃ­a de los clientes solo ha comprado 1 o 2 veces. Alta inactividad.")
                else:
                    st.info(f"- Frecuencia de compra moderada, con un ticket promedio alto.")
            elif variable == "Monetary":
                if subset.median() > 2000:
                    st.success(f"- Alto valor monetario. El 50% de los clientes gastÃ³ mÃ¡s de S/ {subset.median():.0f}.")
                else:
                    st.info(f"- ConcentraciÃ³n de gasto en valores mÃ¡s bajos. Oportunidad de up-selling.")

# ğŸš¨ Nueva funciÃ³n para interpretar los KDE plots
def interpretar_kde_rfm(df, variable, region):
    st.markdown("### ğŸ§  InterpretaciÃ³n de la Densidad (KDE Plot)")
    st.markdown(f"Las curvas de densidad suavizada (KDE) muestran la **concentraciÃ³n de clientes** en los valores de `{variable}`.")
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    for label in orden_clusters:
        subset = df[df["Cluster_Label"] == label][variable].dropna()
        if not subset.empty:
            media = subset.mean()
            st.markdown(f"**{label}**:")
            if variable == "Recency":
                if media < 30:
                    st.success(f"- La curva tiene un pico en valores bajos, indicando alta concentraciÃ³n de clientes recientes.")
                else:
                    st.info(f"- La curva tiene un pico en valores altos, indicando inactividad en la mayorÃ­a de clientes.")
            elif variable == "Frequency":
                if media > 5:
                    st.success(f"- La curva se extiende a la derecha, mostrando que muchos clientes compran frecuentemente.")
                else:
                    st.info(f"- La curva se concentra en valores bajos, indicando que la mayorÃ­a de clientes tienen pocas compras.")
            elif variable == "Monetary":
                if media > 1000:
                    st.success(f"- La curva muestra una cola larga a la derecha, indicando un grupo de clientes con muy alto gasto.")
                else:
                    st.info(f"- La curva se concentra en valores bajos, indicando que la mayorÃ­a de los clientes tienen un gasto menor.")

# --- Bloque para tab10 ---
with tab10:
    st.subheader("ğŸ» AnÃ¡lisis de DistribuciÃ³n y Densidad por Variable RFM")
    st.caption(f"Explora la dispersiÃ³n de mÃ©tricas RFM segÃºn el segmento y regiÃ³n seleccionada: **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    variable = st.selectbox("ğŸ“Œ Variable a analizar:", ["Recency", "Frequency", "Monetary"], key="var_violin")
    df_region[variable] = pd.to_numeric(df_region[variable], errors="coerce")

    # ğŸš¨ Nueva paleta y orden oficial de 5 clÃºsteres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]

    # ğŸ¼ Violin Plot con Plotly
    st.markdown(f"ğŸ¼ **DistribuciÃ³n tipo ViolÃ­n** de `{variable}` por ClÃºster")
    fig1 = px.violin(
        df_region,
        x="Cluster_Label",
        y=variable,
        color="Cluster_Label",
        category_orders={"Cluster_Label": orden_clusters},
        color_discrete_map=colores_k5,
        box=True,
        points="all",
        title=f"Violin Plot â€“ {variable} por ClÃºster ({region})",
        labels={"Cluster_Label": "Segmento", variable: variable}
    )
    st.plotly_chart(fig1)

    with st.expander("ğŸ§  Ver interpretaciÃ³n del Violin Plot"):
        interpretar_violin_rfm(df_region, variable, region)

    # ğŸ“ˆ KDE Plot con Plotly
    st.markdown(f"ğŸ“ˆ **DistribuciÃ³n Suavizada (KDE)** de `{variable}` por ClÃºster")
    fig2 = px.histogram(
        df_region,
        x=variable,
        color="Cluster_Label",
        color_discrete_map=colores_k5,
        marginal="rug",
        title=f"KDE Plot (Aproximado) â€“ {variable} por ClÃºster ({region})",
        labels={variable: variable, "count": "Cantidad de Clientes"},
        histnorm='density'
    )
    fig2.update_traces(opacity=0.7)
    st.plotly_chart(fig2)

    with st.expander("ğŸ§  Ver interpretaciÃ³n del KDE Plot"):
        interpretar_kde_rfm(df_region, variable, region)

    # ğŸ“Š Histograma clÃ¡sico por clÃºster con Plotly
    with st.expander("ğŸ“Š Visual adicional: Histograma clÃ¡sico por clÃºster"):
        st.markdown("ComparaciÃ³n directa de la forma bruta de la distribuciÃ³n por segmento.")
        fig3 = px.histogram(
            df_region,
            x=variable,
            color="Cluster_Label",
            color_discrete_map=colores_k5,
            title=f"Histograma Comparativo â€“ {variable} ({region})",
            labels={variable: variable, "count": "Cantidad de Clientes"},
            barmode="overlay",
            opacity=0.7
        )
        st.plotly_chart(fig3)

with tab11:
    st.subheader("ğŸŒŒ VisualizaciÃ³n 3D de SegmentaciÃ³n RFM")
    st.caption(f"Cada punto representa un cliente posicionado en el espacio RFM. Colores indican su clÃºster asignado para la regiÃ³n **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # âœ… Limpieza de datos numÃ©ricos
    for var in ["Recency", "Frequency", "Monetary"]:
        df_region[var] = pd.to_numeric(df_region[var], errors="coerce")

    # ğŸ“Š Conteo por clÃºster
    conteo = df_region["Cluster_Label"].value_counts().reset_index()
    conteo.columns = ["ClÃºster", "Cantidad de Clientes"]
    st.dataframe(conteo, hide_index=True, use_container_width=True)

    # ğŸš¨ Se actualiza el orden y los colores para los 5 clÃºsteres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }

    # ğŸ¯ Filtro opcional por clÃºster
    cluster_focus = st.selectbox(
        "Filtrar por clÃºster:",
        ["Todos"] + [c for c in orden if c in df_region["Cluster_Label"].unique()],
        key="filtro_cl3d"
    )

    df_plot = df_region if cluster_focus == "Todos" else df_region[df_region["Cluster_Label"] == cluster_focus]

    # Limpieza de etiquetas para asegurar coincidencia exacta
    df_plot["Cluster_Label"] = df_plot["Cluster_Label"].astype(str).str.strip()

    # GrÃ¡fico 3D con colores oficiales
    fig = px.scatter_3d(
        df_plot,
        x="Recency",
        y="Frequency",
        z="Monetary",
        color="Cluster_Label",
        # ğŸš¨ Se usa el nuevo diccionario de colores
        color_discrete_map=colores_k5,
        hover_data=["C_CLIEN", "Recency", "Frequency", "Monetary"],
        opacity=0.75,
        title=f"SegmentaciÃ³n RFM en 3D â€“ RegiÃ³n {region}"
    )

    fig.update_traces(marker=dict(size=4))
    fig.update_layout(
        scene=dict(
            xaxis_title='Recency',
            yaxis_title='Frequency',
            zaxis_title='Monetary'
        ),
        legend_title="ClÃºster",
        margin=dict(l=0, r=0, b=0, t=40)
    )

    st.plotly_chart(fig, use_container_width=True)

with tab12:
    st.subheader("ğŸ§¬ Mapa de CorrelaciÃ³n â€“ RFM y Variables Predictivas")
    st.caption(f"Analiza la relaciÃ³n entre las mÃ©tricas RFM y las probabilidades de evoluciÃ³n de los clientes para la regiÃ³n **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    # ğŸš¨ Se usan los nuevos nombres de columnas predictivas
    variables_corr = ["Recency", "Frequency", "Monetary", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce"]

    # Limpieza y validaciÃ³n de datos
    df_corr = df_region[variables_corr].apply(pd.to_numeric, errors="coerce").dropna()

    if df_corr.empty:
        st.warning("âš ï¸ No hay suficientes datos vÃ¡lidos para construir la matriz de correlaciÃ³n.")
    else:
        matriz_corr = df_corr.corr()

        fig = go.Figure(data=go.Heatmap(
            z=matriz_corr.values,
            x=matriz_corr.columns,
            y=matriz_corr.index,
            colorscale='Bluered',
            zmin=-1,
            zmax=1,
            showscale=True
        ))

        fig.update_layout(
            title=f"Mapa de CorrelaciÃ³n â€“ {region}",
            xaxis_nticks=len(matriz_corr.columns),
            yaxis_nticks=len(matriz_corr.columns),
            autosize=True,
            margin=dict(l=50, r=50, b=50, t=50)
        )

        # AÃ±adir anotaciones de texto
        for i in range(len(matriz_corr.index)):
            for j in range(len(matriz_corr.columns)):
                fig.add_annotation(
                    x=matriz_corr.columns[j],
                    y=matriz_corr.index[i],
                    text=f"{matriz_corr.iloc[i, j]:.2f}",
                    showarrow=False,
                    font=dict(color='black' if np.abs(matriz_corr.iloc[i, j]) < 0.5 else 'white')
                )

        st.plotly_chart(fig, use_container_width=True)

        # ğŸ§  InterpretaciÃ³n automÃ¡tica
        st.markdown("### ğŸ§  InterpretaciÃ³n inicial:")

        # ğŸš¨ AnÃ¡lisis de correlaciÃ³n de ascenso a Oro
        top_corr_ascenso = matriz_corr["Probabilidad_Ascenso_Oro"].drop("Probabilidad_Ascenso_Oro").sort_values(ascending=False)
        mejor_factor_ascenso = top_corr_ascenso.idxmax()
        valor_max_ascenso = top_corr_ascenso.max()
        st.info(f"ğŸ† La mÃ©trica mÃ¡s correlacionada con la **probabilidad de ascenso a Oro** es **{mejor_factor_ascenso}** (`{valor_max_ascenso:.2f}`). Esto revela un patrÃ³n clave para campaÃ±as de up-selling y escalamiento.")

        # ğŸš¨ AnÃ¡lisis de correlaciÃ³n de caÃ­da a Bronce
        top_corr_caida = matriz_corr["Probabilidad_Descenso_Bronce"].drop("Probabilidad_Descenso_Bronce").sort_values(ascending=False)
        mejor_factor_caida = top_corr_caida.idxmax()
        valor_max_caida = top_corr_caida.max()
        st.warning(f"ğŸ“‰ La mÃ©trica mÃ¡s correlacionada con la **probabilidad de caÃ­da a Bronce** es **{mejor_factor_caida}** (`{valor_max_caida:.2f}`). Identifica el factor principal de riesgo para campaÃ±as de retenciÃ³n o reactivaciÃ³n.")

# ğŸš¨ Nueva funciÃ³n para la interpretaciÃ³n del grÃ¡fico de radar
def interpretar_radar_rfm(df, region):
    st.markdown("### ğŸ§  InterpretaciÃ³n de los Perfiles RFM")
    st.markdown("Cada eje del grÃ¡fico de radar representa una mÃ©trica RFM normalizada. Cuanto mÃ¡s cerca del borde, mayor es el valor promedio del clÃºster para esa mÃ©trica.")

    perfiles = df.groupby("Cluster_Label")[["Recency", "Frequency", "Monetary"]].mean()

    st.markdown("---")
    st.markdown("#### **Perfil Diamante (MÃ¡ximo Valor y Lealtad)**")
    st.markdown("ğŸŒŸ **Recency Baja:** Sus clientes han comprado muy recientemente.")
    st.markdown("ğŸŒŸ **Frequency Alta:** Tienen un alto nÃºmero de compras repetidas.")
    st.markdown("ğŸŒŸ **Monetary Alta:** Generan el mayor valor de ingresos por cliente.")
    st.markdown("Este segmento es la base de clientes mÃ¡s valiosa y leal. La estrategia debe ser la **fidelizaciÃ³n extrema** y la **anticipaciÃ³n de sus necesidades** para asegurar su permanencia.")

    st.markdown("---")
    st.markdown("#### **Perfil Oro (Alto Valor)**")
    st.markdown("ğŸ“ˆ **Recency Baja:** Compran con regularidad y estÃ¡n activos.")
    st.markdown("ğŸ“ˆ **Frequency Alta:** Tienen un buen historial de compras.")
    st.markdown("ğŸ“ˆ **Monetary Alta:** Su gasto promedio es significativamente alto.")
    st.markdown("Son la segunda base mÃ¡s valiosa. El objetivo es convertirlos en clientes **'Diamante'** a travÃ©s de **programas VIP y atenciÃ³n personalizada**.")

    st.markdown("---")
    st.markdown("#### **Perfil Plata (Frecuencia Media)**")
    st.markdown("ğŸ”„ **Recency Media:** Su Ãºltima compra no es tan reciente, pero tampoco muy lejana.")
    st.markdown("ğŸ”„ **Frequency Media:** Compran con una frecuencia moderada.")
    st.markdown("ğŸ”„ **Monetary Media:** El gasto por cliente es estable y no alcanza los valores mÃ¡s altos.")
    st.markdown("Este segmento tiene un gran potencial de crecimiento. La estrategia es **impulsar la recurrencia** y el **up-selling** con promociones y recordatorios segmentados.")

    st.markdown("---")
    st.markdown("#### **Perfil Cobre (En Riesgo)**")
    st.markdown("âš ï¸ **Recency Alta:** Ha pasado mucho tiempo desde su Ãºltima compra.")
    st.markdown("âš ï¸ **Frequency Baja:** Suelen tener pocas compras.")
    st.markdown("âš ï¸ **Monetary Baja:** El valor total de su gasto no es muy alto.")
    st.markdown("Este segmento se encuentra en un punto crÃ­tico, con alto riesgo de abandono. Las campaÃ±as deben centrarse en la **retenciÃ³n proactiva** y la **reactivaciÃ³n** con ofertas de valor cruzado.")

    st.markdown("---")
    st.markdown("#### **Perfil Bronce (Bajo Valor/Inactivos)**")
    st.markdown("ğŸ’” **Recency Muy Alta:** Son clientes inactivos o que han dejado de comprar.")
    st.markdown("ğŸ’” **Frequency Baja:** El nÃºmero de compras es muy bajo.")
    st.markdown("ğŸ’” **Monetary Baja:** Tienen el menor gasto acumulado.")
    st.markdown("Son clientes de bajo valor. Las campaÃ±as deben ser de **reactivaciÃ³n masiva** con ofertas agresivas para intentar recuperarlos.")


# --- Bloque corregido para tab13 ---
with tab13:
    st.subheader("ğŸ§­ Perfil Comparativo por ClÃºster (RFM)")
    st.caption(f"Compara visualmente los promedios normalizados de las mÃ©tricas RFM por segmento para la regiÃ³n **{region}**.")

    df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()

    variables = ["Recency", "Frequency", "Monetary"]
    df_radar = df_region.groupby("Cluster_Label")[variables].mean().reset_index()

    # NormalizaciÃ³n entre 0 y 1 para el radar
    df_norm = df_radar.copy()
    for var in variables:
        min_val = df_radar[var].min()
        max_val = df_radar[var].max()
        rango = max_val - min_val + 1e-8
        df_norm[var] = (df_radar[var] - min_val) / rango

    # ğŸ¯ Radar Plot
    fig = go.Figure()
    # ğŸš¨ Se actualiza el diccionario de colores para los 5 clÃºsteres
    colores_k5 = {
        "Diamante": "#00FFFF",
        "Oro": "#FFD700",
        "Plata": "#C0C0C0",
        "Cobre": "#B87333",
        "Bronce": "#CD7F32"
    }
    # ğŸš¨ Se actualiza el orden de los clÃºsteres
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    df_norm["Cluster_Label"] = pd.Categorical(df_norm["Cluster_Label"], categories=orden, ordered=True)
    df_norm = df_norm.sort_values("Cluster_Label")

    for _, row in df_norm.iterrows():
        fig.add_trace(go.Scatterpolar(
            r=row[variables].values,
            theta=variables,
            fill='toself',
            name=row['Cluster_Label'],
            line=dict(color=colores_k5.get(row['Cluster_Label'], "#888"))
        ))

    fig.update_layout(
        polar=dict(radialaxis=dict(visible=True, range=[0, 1])),
        title=f"Perfiles Normalizados por ClÃºster â€“ {region}",
        showlegend=True,
        margin=dict(t=50, l=0, r=0, b=0)
    )
    st.plotly_chart(fig, use_container_width=True)

    # ğŸ§  InterpretaciÃ³n automÃ¡tica
    interpretar_radar_rfm(df_region, region)

# ğŸš¨ Nueva funciÃ³n de interpretaciÃ³n comparativa
def interpretar_comparativa_regional(df):
    st.markdown("### ğŸ§  AnÃ¡lisis Comparativo AutomÃ¡tico")

    # Aseguramos que las columnas existen para evitar errores
    if "RegiÃ³n" not in df.columns or "Cantidad" not in df.columns or "Monto_Total" not in df.columns:
        st.error("Error: Las columnas 'RegiÃ³n', 'Cantidad' o 'Monto_Total' no se encuentran en el DataFrame.")
        return

    df_tac = df[df["RegiÃ³n"] == "Tacna"]
    df_moq = df[df["RegiÃ³n"] == "Moquegua"]

    st.markdown("---")
    st.markdown("#### **AnÃ¡lisis de Clientes (Cantidad)**")

    total_tac = df_tac["Cantidad"].sum()
    total_moq = df_moq["Cantidad"].sum()
    st.info(f"ğŸ‘‰ **Tacna** tiene un total de **{total_tac} clientes**, mientras que **Moquegua** tiene **{total_moq} clientes**.")

    if total_tac > total_moq:
        st.success(f"Tacna tiene una base de clientes mÃ¡s grande, lo que sugiere una mayor presencia de mercado.")
    elif total_moq > total_tac:
        st.success(f"Moquegua tiene una base de clientes mÃ¡s grande, indicando una mayor penetraciÃ³n en esa regiÃ³n.")
    else:
        st.info("Ambas regiones tienen un nÃºmero similar de clientes.")

    st.markdown("---")
    st.markdown("#### **AnÃ¡lisis de Valor Monetario**")

    total_monto_tac = df_tac["Monto_Total"].sum()
    total_monto_moq = df_moq["Monto_Total"].sum()
    st.info(f"ğŸ‘‰ El valor total de ingresos en **Tacna** es de **S/ {total_monto_tac:.2f}**, y en **Moquegua** es de **S/ {total_monto_moq:.2f}**.")

    if total_monto_tac > total_monto_moq:
        st.success("A pesar de la base de clientes, Tacna genera un mayor volumen de ingresos total.")
    elif total_monto_moq > total_monto_tac:
        st.success("Moquegua es la regiÃ³n que genera el mayor volumen de ingresos total.")
    else:
        st.info("Ambas regiones generan un valor monetario similar.")

    st.markdown("---")
    st.markdown("#### **AnÃ¡lisis de Ticket Promedio**")

    # Se calcula el ticket promedio global para cada regiÃ³n
    ticket_promedio_tac = df_tac["Monto_Total"].sum() / df_tac["Cantidad"].sum() if df_tac["Cantidad"].sum() > 0 else 0
    ticket_promedio_moq = df_moq["Monto_Total"].sum() / df_moq["Cantidad"].sum() if df_moq["Cantidad"].sum() > 0 else 0
    st.info(f"ğŸ‘‰ El ticket promedio global es de **S/ {ticket_promedio_tac:.2f}** en Tacna y **S/ {ticket_promedio_moq:.2f}** en Moquegua.")

    if ticket_promedio_tac > ticket_promedio_moq:
        st.success("El ticket promedio por cliente es mÃ¡s alto en Tacna, lo que sugiere clientes con mayor capacidad de gasto.")
    elif ticket_promedio_moq > ticket_promedio_tac:
        st.success("El ticket promedio por cliente es mÃ¡s alto en Moquegua, lo que indica que los clientes gastan mÃ¡s por transacciÃ³n.")
    else:
        st.info("El ticket promedio es similar en ambas regiones.")


# --- Bloque corregido para tab14 ---
with tab14:
    st.subheader("âš–ï¸ DiagnÃ³stico Comparativo entre Regiones")
    st.caption("Analiza cÃ³mo se comportan los segmentos RFM entre Tacna y Moquegua en tÃ©rminos de volumen, valor monetario y ticket promedio.")

    # AsegÃºrate de tener los DataFrames df_tac y df_moq definidos globalmente o pasados
    # de lo contrario, esto fallarÃ¡. Asumiendo que estÃ¡n definidos.
    # df_tac = ...
    # df_moq = ...

    # ğŸ” AgrupaciÃ³n por regiÃ³n y clÃºster
    resumen_tac = df_tac.groupby("Cluster_Label").agg(
        Cantidad=("C_CLIEN", "count"),
        Monto_Total=("Monetary", "sum"),
        Ticket_Promedio=("Monetary", "mean")
    ).reset_index()
    resumen_tac["RegiÃ³n"] = "Tacna"

    resumen_moq = df_moq.groupby("Cluster_Label").agg(
        Cantidad=("C_CLIEN", "count"),
        Monto_Total=("Monetary", "sum"),
        Ticket_Promedio=("Monetary", "mean")
    ).reset_index()
    resumen_moq["RegiÃ³n"] = "Moquegua"

    resumen_total = pd.concat([resumen_tac, resumen_moq], ignore_index=True)

    # ğŸš¨ Se actualiza el orden de los clÃºsteres a 5
    orden = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    # Filtra los clÃºsteres que no existen en el DataFrame antes de crear la categorÃ­a
    resumen_total_filtered = resumen_total[resumen_total["Cluster_Label"].isin(orden)]
    resumen_total_filtered["Cluster_Label"] = pd.Categorical(resumen_total_filtered["Cluster_Label"], categories=orden, ordered=True)
    resumen_total_filtered = resumen_total_filtered.sort_values(["Cluster_Label", "RegiÃ³n"])


    # ğŸ¨ GrÃ¡fico: DistribuciÃ³n de clientes por clÃºster y regiÃ³n
    st.markdown("### ğŸ“Š DistribuciÃ³n de Clientes por ClÃºster")
    fig1 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Cantidad",
        color="RegiÃ³n",
        barmode="group",
        text="Cantidad",
        title="Cantidad de Clientes por ClÃºster y RegiÃ³n",
        color_discrete_sequence=px.colors.qualitative.Set2
    )
    st.plotly_chart(fig1, use_container_width=True)

    # ğŸ’° GrÃ¡fico: Monto total por clÃºster y regiÃ³n
    st.markdown("### ğŸ’° Valor Monetario Total por ClÃºster")
    fig2 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Monto_Total",
        color="RegiÃ³n",
        barmode="group",
        text_auto=".2s",
        title="Suma Total de Consumo por RegiÃ³n y ClÃºster",
        color_discrete_sequence=px.colors.qualitative.Set3
    )
    st.plotly_chart(fig2, use_container_width=True)

    # ğŸŸï¸ GrÃ¡fico: Ticket promedio
    st.markdown("### ğŸŸï¸ Ticket Promedio por ClÃºster")
    fig3 = px.bar(
        resumen_total_filtered,
        x="Cluster_Label",
        y="Ticket_Promedio",
        color="RegiÃ³n",
        barmode="group",
        text_auto=".2f",
        title="ComparaciÃ³n de Ticket Promedio",
        color_discrete_sequence=px.colors.qualitative.Safe
    )
    st.plotly_chart(fig3, use_container_width=True)

    # ğŸ“‘ Tabla resumen y exportaciÃ³n
    st.markdown("### ğŸ§¾ Tabla Resumen Gerencial")
    resumen_formato = resumen_total_filtered.copy()
    resumen_formato["Ticket_Promedio"] = resumen_formato["Ticket_Promedio"].round(2)
    resumen_formato["Monto_Total"] = resumen_formato["Monto_Total"].round(2)
    st.dataframe(resumen_formato, use_container_width=True)

    # ğŸ§  InterpretaciÃ³n comparativa automÃ¡tica
    interpretar_comparativa_regional(resumen_total_filtered)

    # ğŸ“¥ BotÃ³n de descarga Excel
    excel_buf = io.BytesIO()
    resumen_formato.to_excel(excel_buf, index=False)
    excel_buf.seek(0)

    st.download_button(
        "ğŸ“¥ Descargar Comparativa Regional",
        data=excel_buf,
        file_name="Comparativa_Regional_Tacna_vs_Moquegua.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

def cargar_csv_desde_zip(region_slug):
    """FunciÃ³n simulada para cargar datos de ventas.
    En una implementaciÃ³n real, se adaptarÃ­a."""
    try:
        df_ventas = pd.read_csv("clientes_segmentados_moquegua.csv")
        df_ventas = df_ventas.rename(columns={"Monetary": "TOTAL_VENTA", "Recency": "FECHA"})
        df_ventas["FECHA"] = pd.to_datetime(df_ventas["FECHA"], unit="D", origin="2024-01-01")
        return df_ventas
    except FileNotFoundError:
        st.error(f"âŒ No se encontrÃ³ el archivo de ventas para la regiÃ³n {region_slug}.")
        return None

with tab15:
    st.subheader("ğŸ“† EvoluciÃ³n Mensual de Clientes y PredicciÃ³n EstratÃ©gica")
    st.caption(f"EvalÃºa el comportamiento mensual de clientes en la regiÃ³n **{region}** segÃºn perfil predictivo.")

    region_slug = region.lower()
    df_ventas = cargar_csv_desde_zip(region_slug)

    if df_ventas is None:
        st.stop()
    else:
        st.success(f"âœ… Datos cargados correctamente para {region}")

    df_ventas["FECHA"] = pd.to_datetime(df_ventas["FECHA"], errors="coerce")
    fechas_validas = df_ventas["FECHA"].notna().sum()
    st.caption(f"ğŸ—“ï¸ Fechas vÃ¡lidas detectadas: {fechas_validas:,}")
    if fechas_validas == 0:
        st.error("âŒ Ninguna fecha vÃ¡lida fue detectada en los datos de ventas.")
        st.stop()

    df_ventas["PERIODO_MES"] = df_ventas["FECHA"].dt.to_period("M").astype(str)

    df_cluster = df_tac.copy() if region == "Tacna" else df_moq.copy()
    df_ventas["C_CLIEN"] = df_ventas["C_CLIEN"].astype(str)
    df_cluster["C_CLIEN"] = df_cluster["C_CLIEN"].astype(str)

    # ğŸš¨ CorrecciÃ³n: Asegura que las columnas de probabilidad existan antes de usarlas.
    # Esto maneja el caso donde el archivo de datos original no las tiene.
    if "Probabilidad_Ascenso_Oro" not in df_cluster.columns and "Probabilidad_Ascenso" in df_cluster.columns:
        df_cluster = df_cluster.rename(columns={"Probabilidad_Ascenso": "Probabilidad_Ascenso_Oro"})

    if "Probabilidad_Descenso_Bronce" not in df_cluster.columns and "Probabilidad_Bronce" in df_cluster.columns:
        df_cluster = df_cluster.rename(columns={"Probabilidad_Bronce": "Probabilidad_Descenso_Bronce"})

    df_cluster["Probabilidad_Ascenso_Oro"] = pd.to_numeric(df_cluster["Probabilidad_Ascenso_Oro"], errors="coerce")
    df_cluster["Probabilidad_Descenso_Bronce"] = pd.to_numeric(df_cluster["Probabilidad_Descenso_Bronce"], errors="coerce")

    df_full = df_ventas.merge(df_cluster, on="C_CLIEN", how="inner")
    st.write(f"ğŸ” Registros tras el merge: {len(df_full):,}")
    if df_full.empty:
        st.warning("âš ï¸ No hay coincidencias entre ventas y clustering.")
        st.stop()

    def clasificar_segmento(row):
        if row["Probabilidad_Ascenso_Oro"] >= 0.8 and row["Probabilidad_Descenso_Bronce"] <= 0.3:
            return "Cliente Estrella"
        elif row["Probabilidad_Ascenso_Oro"] < 0.5 and row["Probabilidad_Descenso_Bronce"] >= 0.7:
            return "Riesgo de Abandono"
        elif 0.5 <= row["Probabilidad_Ascenso_Oro"] < 0.8 and 0.3 < row["Probabilidad_Descenso_Bronce"] < 0.7:
            return "Zona de Desarrollo"
        else:
            return "Segmento Estable"

    df_full["Segmento EstratÃ©gico"] = df_full.apply(clasificar_segmento, axis=1)

    periodos_disponibles = sorted(df_full["PERIODO_MES"].dropna().unique())
    if len(periodos_disponibles) == 0:
        st.warning("âš ï¸ No hay periodos vÃ¡lidos tras la fusiÃ³n.")
        st.stop()

    periodo_ini, periodo_fin = st.select_slider(
        "Selecciona el rango de meses a analizar:",
        options=periodos_disponibles,
        value=(periodos_disponibles[0], periodos_disponibles[-1])
    )
    df_full = df_full[df_full["PERIODO_MES"].between(periodo_ini, periodo_fin)]

    resumen_mensual = df_full.groupby("PERIODO_MES").agg(
        Prom_Ascenso=("Probabilidad_Ascenso_Oro", "mean"),
        Prom_Caida=("Probabilidad_Descenso_Bronce", "mean"),
        Total_Clientes=("C_CLIEN", "nunique")
    ).reset_index()

    fig1 = go.Figure()
    fig1.add_trace(go.Scatter(x=resumen_mensual["PERIODO_MES"], y=resumen_mensual["Prom_Ascenso"],
                              name='Prob. Ascenso a Oro', mode='lines+markers', line=dict(color="green")))
    fig1.add_trace(go.Scatter(x=resumen_mensual["PERIODO_MES"], y=resumen_mensual["Prom_Caida"],
                              name='Prob. CaÃ­da a Bronce', mode='lines+markers', line=dict(color="firebrick")))
    fig1.update_layout(title="ğŸ“ˆ Probabilidad Predictiva Promedio Mensual", xaxis_title="Mes", yaxis_title="Probabilidad")
    st.plotly_chart(fig1, use_container_width=True)

    if "Recency" in df_full.columns:
        df_full["Recency"] = pd.to_numeric(df_full["Recency"], errors="coerce")
        recency_mensual = df_full.groupby("PERIODO_MES")["Recency"].mean().reset_index()

        fig_rec = go.Figure()
        fig_rec.add_trace(go.Scatter(
            x=recency_mensual["PERIODO_MES"],
            y=recency_mensual["Recency"],
            mode='lines+markers',
            line=dict(color="royalblue")
        ))
        fig_rec.update_layout(
            title="ğŸ“‰ Recencia Promedio (dÃ­as sin compra)",
            xaxis_title="Mes",
            yaxis_title="DÃ­as sin Compra"
        )
        st.plotly_chart(fig_rec, use_container_width=True)

    st.markdown("### ğŸ§­ EvoluciÃ³n de Segmento EstratÃ©gico")
    dist_segmento = df_full.groupby(["PERIODO_MES", "Segmento EstratÃ©gico"]).agg(
        Cantidad=("C_CLIEN", "nunique")
    ).reset_index()
    total_mes = df_full.groupby("PERIODO_MES")["C_CLIEN"].nunique().reset_index(name="Total")
    dist_segmento = dist_segmento.merge(total_mes, on="PERIODO_MES")
    dist_segmento["%"] = 100 * dist_segmento["Cantidad"] / dist_segmento["Total"]

    fig2 = px.area(
        dist_segmento,
        x="PERIODO_MES", y="%", color="Segmento EstratÃ©gico",
        groupnorm="percent",
        color_discrete_sequence=px.colors.qualitative.Pastel,
        title="ğŸ“Š DistribuciÃ³n de Segmentos EstratÃ©gicos por Mes"
    )
    st.plotly_chart(fig2, use_container_width=True)

    with st.expander("ğŸ§  Ver interpretaciÃ³n de tendencias"):
        if not resumen_mensual.empty:
            mes_max = resumen_mensual.loc[resumen_mensual["Prom_Ascenso"].idxmax(), "PERIODO_MES"]
            max_asc = resumen_mensual["Prom_Ascenso"].max()
            mes_min = resumen_mensual.loc[resumen_mensual["Prom_Caida"].idxmin(), "PERIODO_MES"]
            min_caida = resumen_mensual["Prom_Caida"].min()
            top_seg = dist_segmento.groupby("Segmento EstratÃ©gico")["Cantidad"].sum().idxmax()

            st.markdown(f"- ğŸŸ¢ Mayor ascenso promedio a Oro: **{mes_max}** (`{max_asc:.2f}`)")
            st.markdown(f"- âœ… Menor riesgo de caÃ­da a Bronce: **{mes_min}** (`{min_caida:.2f}`)")
            st.markdown(f"- ğŸ“Œ Segmento mÃ¡s frecuente: **{top_seg}**")
        else:
            st.info("No hay datos suficientes en el rango de fechas seleccionado.")

    excel_buf = io.BytesIO()
    resumen_mensual.to_excel(excel_buf, index=False)
    excel_buf.seek(0)

    st.download_button(
        label="ğŸ“¤ Descargar Excel de EvoluciÃ³n Mensual",
        data=excel_buf,
        file_name=f"Evolucion_Predictiva_{region}.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

    with st.expander("ğŸ” Consulta de comportamiento por cliente especÃ­fico"):
        clientes_disponibles = sorted(df_full["C_CLIEN"].unique())

        if not clientes_disponibles:
            st.info("No hay clientes disponibles en el perÃ­odo y regiÃ³n seleccionados.")
        else:
            cod_cliente = st.selectbox(
                "Selecciona un cliente:",
                clientes_disponibles,
                key="cliente_selector"
            )

            df_cliente = df_full[df_full["C_CLIEN"] == cod_cliente]

            if df_cliente.empty:
                st.warning("âš ï¸ Cliente no encontrado en los datos actuales.")
            else:
                st.markdown(f"### ğŸ“Œ EvoluciÃ³n mensual para cliente **{cod_cliente}**")

                fig_ind = go.Figure()
                fig_ind.add_trace(go.Scatter(
                    x=df_cliente["PERIODO_MES"],
                    y=df_cliente["Probabilidad_Ascenso_Oro"],
                    name="Prob. Ascenso a Oro",
                    mode="lines+markers",
                    line=dict(color="green")
                ))
                fig_ind.add_trace(go.Scatter(
                    x=df_cliente["PERIODO_MES"],
                    y=df_cliente["Probabilidad_Descenso_Bronce"],
                    name="Prob. CaÃ­da a Bronce",
                    mode="lines+markers",
                    line=dict(color="firebrick")
                ))
                fig_ind.update_layout(
                    xaxis_title="Mes",
                    yaxis_title="Probabilidad",
                    title="ğŸ“ˆ Perfil predictivo individual por mes"
                )
                st.plotly_chart(fig_ind, use_container_width=True)

                if "Recency" in df_cliente.columns and df_cliente["Recency"].notna().any():
                    fig_ind_rec = go.Figure()
                    fig_ind_rec.add_trace(go.Scatter(
                        x=df_cliente["PERIODO_MES"],
                        y=df_cliente["Recency"],
                        mode="lines+markers",
                        name="Recency",
                        line=dict(color="royalblue")
                    ))
                    fig_ind_rec.update_layout(
                        title="ğŸ“‰ Recencia mensual (dÃ­as sin compra)",
                        xaxis_title="Mes",
                        yaxis_title="DÃ­as sin Compra"
                    )
                    st.plotly_chart(fig_ind_rec, use_container_width=True)

                buf_cliente = io.BytesIO()
                df_export = df_cliente[["PERIODO_MES", "Probabilidad_Ascenso_Oro", "Probabilidad_Descenso_Bronce", "Recency"]].copy()
                df_export.columns = ["Mes", "Probabilidad de Ascenso a Oro", "Probabilidad de CaÃ­da a Bronce", "Recencia (dÃ­as)"]
                df_export.to_excel(buf_cliente, index=False)
                buf_cliente.seek(0)

                st.download_button(
                    label="ğŸ“¤ Descargar historial de este cliente",
                    data=buf_cliente,
                    file_name=f"Historial_Cliente_{cod_cliente}_{region}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )

                st.caption("Puedes comparar estas curvas con el promedio regional para detectar oportunidades de intervenciÃ³n temprana.")

with tab16:
    st.subheader("ğŸ“Œ Estrategias Sugeridas por ClÃºster")
    st.caption(f"Estrategias basadas en la distribuciÃ³n actual de clientes en **{region}**")

    # ğŸ” SelecciÃ³n dinÃ¡mica del DataFrame segÃºn regiÃ³n
    # AsegÃºrate de que df_tac y df_moq estÃ¡n definidos en el Ã¡mbito global o en el contexto de tu aplicaciÃ³n Streamlit
    try:
        df_region = df_tac.copy() if region == "Tacna" else df_moq.copy()
    except NameError:
        st.error("Error: Los DataFrames 'df_tac' o 'df_moq' no estÃ¡n definidos. AsegÃºrate de cargarlos previamente.")
        st.stop()

    df_region["Cluster_Label"] = df_region["Cluster_Label"].fillna("Desconocido")
    total = df_region["C_CLIEN"].nunique()

    # ğŸš¨ Se actualiza el orden y la paleta para 5 clÃºsteres
    orden_clusters = ["Diamante", "Oro", "Plata", "Cobre", "Bronce"]
    colores_k5 = {
        "Diamante": "blue",
        "Oro": "gold",
        "Plata": "silver",
        "Cobre": "#B87333",
        "Bronce": "brown"
    }

    # ğŸ§® Conteo por segmento
    conteo = df_region.groupby("Cluster_Label")["C_CLIEN"].nunique().reindex(orden_clusters).fillna(0).astype(int)

    st.markdown("### ğŸ“Š DistribuciÃ³n actual de clientes")

    col1, col2, col3, col4, col5, col6 = st.columns(6)
    col1.metric("ğŸ‘¥ Totales", f"{total:,}")
    col2.metric("ğŸ’ Diamante", f"{conteo['Diamante']:,}")
    col3.metric("ğŸŸ¡ Oro", f"{conteo['Oro']:,}")
    col4.metric("âšª Plata", f"{conteo['Plata']:,}")
    col5.metric("ğŸŸ  Cobre", f"{conteo['Cobre']:,}")
    col6.metric("ğŸŸ¤ Bronce", f"{conteo['Bronce']:,}")

    st.markdown("---")
    st.markdown("ğŸ§  Estas recomendaciones se basan en el perfil de valor y comportamiento transaccional de cada clÃºster:")

    col1, col2 = st.columns(2)
    with col1:
        st.markdown("### ğŸ’ Diamante")
        st.success("Clientes de mÃ¡ximo valor y lealtad")
        st.markdown("""
- ğŸ¤ **RelaciÃ³n exclusiva:** Trato preferencial, acceso a eventos privados.
- ğŸ **Servicios a medida:** Ofertas personalizadas, productos exclusivos.
- ğŸ’¬ **Feedback directo:** Considerar sus opiniones para la mejora del negocio.
- ğŸ‰ **Celebraciones:** Felicitaciones en fechas especiales, detalles de alto valor.
""")

    with col2:
        st.markdown("### ğŸŸ¡ Oro")
        st.info("Clientes muy valiosos y recurrentes")
        st.markdown("""
- ğŸ¥‡ **Up-selling:** Incentivos para aumentar su ticket promedio.
- ğŸ **Recompensas VIP:** Programas de lealtad por puntos, beneficios tangibles.
- ğŸ“ **AtenciÃ³n preferente:** Canal de soporte rÃ¡pido y eficaz.
- ğŸ›’ **Recomendaciones:** Productos complementarios que ya son de su interÃ©s.
""")

    st.markdown("---")

    col1, col2 = st.columns(2)
    with col1:
        st.markdown("### âšª Plata")
        st.info("Clientes con potencial de crecimiento")
        st.markdown("""
- ğŸ“ˆ **ActivaciÃ³n de frecuencia:** Cupones o descuentos por compras repetidas.
- ğŸ’¡ **Recomendaciones:** Sugerir productos con buen margen para aumentar el valor.
- ğŸ“§ **ComunicaciÃ³n constante:** Newsletters con contenido de valor y promociones.
- ğŸ›ï¸ **Bundles de productos:** Ofertas por la compra de paquetes de productos.
""")

    with col2:
        st.markdown("### ğŸŸ  Cobre")
        st.warning("Clientes con riesgo de inactividad")
        st.markdown("""
- ğŸ”„ **ReactivaciÃ³n:** CampaÃ±as de email/SMS/WhatsApp para traerlos de vuelta.
- ğŸ **Ofertas agresivas:** Descuentos o promociones exclusivas para su siguiente compra.
- ğŸ” **IdentificaciÃ³n de dolor:** Encuestas para entender por quÃ© bajÃ³ su frecuencia.
- â³ **Urgency marketing:** Ofertas de tiempo limitado para motivar la compra.
""")

    st.markdown("---")
    st.markdown("### ğŸŸ¤ Bronce")
    st.warning("Clientes inactivos o de bajo valor")
    st.markdown("""
- ğŸ“‰ **Coste-efectividad:** No invertir grandes recursos, enfocarse en campaÃ±as masivas.
- ğŸ¯ **Ofertas de entrada:** Promociones muy bajas para una primera (o segunda) compra.
- ğŸ—‘ï¸ **Limpieza de base:** Considerar su eliminaciÃ³n de listas de marketing si no hay respuesta.
- ğŸ“£ **Awareness:** Mantener la marca en su mente con contenido de bajo coste.
""")


    st.markdown("---")
    st.caption("Estas estrategias estÃ¡n alineadas con el anÃ¡lisis RFM y patrones histÃ³ricos de clientes en cada regiÃ³n.")

    # ğŸ”® Recomendaciones predictivas por perfil
    st.markdown("### ğŸ§­ Recomendaciones segÃºn Cuadrante EstratÃ©gico (PredicciÃ³n de EvoluciÃ³n)")

    with st.expander("ğŸ“‰ Ver estrategias por perfil de riesgo y ascenso"):
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### ğŸŸ¢ Cliente Estrella")
            st.success("Alta probabilidad de ascenso, bajo riesgo de caÃ­da")
            st.markdown("""
- ğŸ¯ **ActivaciÃ³n inmediata de beneficios:** Activar beneficios 'Oro' o 'Diamante'.
- ğŸ›ï¸ **Ofertas personalizadas:** Incentivar la recompra con productos exclusivos.
- ğŸ§  **Feedback directo:** Recopilar sus opiniones para mejorar la experiencia.
- ğŸª„ **Recomendaciones cruzadas:** Sugerir productos de alto valor que aÃºn no ha probado.
""")

            st.markdown("### ğŸŸ¡ Zona de Desarrollo")
            st.info("Valores intermedios, potencial latente")
            st.markdown("""
- ğŸ¤ **AcompaÃ±amiento:** CampaÃ±as educativas sobre el uso de otros productos.
- ğŸ“ˆ **Probar upgrades:** Ofrecer descuentos para motivar compras de mayor valor.
- ğŸ’¬ **Encuestas o dinÃ¡micas:** Activar su interÃ©s con contenido interactivo.
- ğŸ“Š **Monitoreo periÃ³dico:** Evaluar su evoluciÃ³n de clÃºster trimestralmente.
""")

        with col2:
            st.markdown("### ğŸ”´ Riesgo de Abandono")
            st.warning("Alta probabilidad de caÃ­da")
            st.markdown("""
- ğŸš¨ **CampaÃ±as urgentes de retenciÃ³n:** Incentivos agresivos para una compra inmediata.
- ğŸ§² **Incentivos de regreso:** Ofrecer cupones de alto valor o descuentos significativos.
- ğŸ“ **Llamadas o mensajes directos:** Contacto personal para recuperar al cliente.
- ğŸ” **EvaluaciÃ³n de fricciones:** Analizar si hubo un problema o mala experiencia de servicio.
""")

            st.markdown("### âšª Segmento Estable")
            st.info("Bajo ascenso y bajo riesgo")
            st.markdown("""
- ğŸ¤– **AutomatizaciÃ³n de marketing:** Mantenerlos informados con newsletters y contenido.
- ğŸ”„ **Reforzar el awareness:** Recordar la marca con contenido Ãºtil y relevante.
- ğŸ§­ **Potencial de activaciÃ³n:** Promociones selectivas para motivar la compra.
- â±ï¸ **RevisiÃ³n trimestral:** Monitorear su comportamiento para detectar cambios.
""")

        st.caption("Basado en la matriz predictiva de ascenso a **Oro** y caÃ­da a **Bronce** desarrollada en la pestaÃ±a de evoluciÃ³n.")

with tab17:
    st.subheader("ğŸ“˜ Manual de NavegaciÃ³n y Uso EstratÃ©gico")
    st.caption("Recomendaciones para interpretar, navegar y aprovechar al mÃ¡ximo el dashboard.")

    with st.expander("ï¿½ Â¿CuÃ¡l es el objetivo general del dashboard?"):
        st.markdown("""
Este sistema fue diseÃ±ado para **explorar, segmentar, predecir y activar estrategias** sobre clientes a partir de informaciÃ³n transaccional, con enfoque regional en **Tacna** y **Moquegua**.

- Aplica anÃ¡lisis RFM (Recency, Frequency, Monetary)
- Integra **clustering de 5 segmentos** y anÃ¡lisis de evoluciÃ³n
- Permite exportaciÃ³n y activaciÃ³n de campaÃ±as
""")

    with st.expander("ğŸ§­ Â¿CÃ³mo estÃ¡ estructurado el dashboard?"):
        st.markdown("""
- **Tabs 1â€“5:** ValidaciÃ³n inicial de clÃºsteres y mÃ©tricas RFM
- **Tabs 6â€“8:** IdentificaciÃ³n, alerta y predicciÃ³n de comportamiento
- **Tabs 9â€“11:** ExploraciÃ³n de distribuciÃ³n por variable y segmento
- **Tabs 12â€“14:** CorrelaciÃ³n, perfiles y comparativa regional
- **Tab 15:** EvoluciÃ³n temporal estratÃ©gica de clientes
- **Tab 16:** Recomendaciones estratÃ©gicas
- **Tab 17:** Esta guÃ­a interactiva
""")

    with st.expander("ğŸ’¡ Â¿QuÃ© buenas prÃ¡cticas debo seguir?"):
        st.markdown("""
- Selecciona siempre la **regiÃ³n** antes de explorar
- Ajusta los **umbrales de riesgo y ascenso** segÃºn el escenario
- Exporta datos con los botones ğŸ“¥ donde estÃ©n disponibles
- Revisa las interpretaciones bajo expanders ğŸ§  para mayor contexto
""")

    with st.expander("ğŸ“ Â¿QuÃ© tipo de campaÃ±as se recomiendan segÃºn el perfil del cliente?"):
        st.markdown("""
- ğŸ’ **Diamante:** FidelizaciÃ³n extrema y servicios exclusivos.
- ğŸŸ¡ **Oro:** FidelizaciÃ³n avanzada y beneficios exclusivos.
- âšª **Plata:** Incentivo a la frecuencia y seguimiento.
- ğŸŸ  **Cobre:** IntervenciÃ³n proactiva para evitar la inactividad.
- ğŸŸ¤ **Bronce:** ReactivaciÃ³n o atenciÃ³n cautiva.
- ğŸ§­ **Cliente Estrella:** ActivaciÃ³n de recompensas inmediatas.
- ğŸ”´ **Riesgo:** Contacto urgente o incentivo de retenciÃ³n.
- âšª **Estables:** AutomatizaciÃ³n y monitoreo pasivo.
""")

    st.markdown("---")
    st.caption("ğŸ“Œ Esta guÃ­a estÃ¡ diseÃ±ada para onboarding de analistas, equipos comerciales y responsables regionales.")